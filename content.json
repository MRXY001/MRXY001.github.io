[{"title":"工厂模式","date":"2019-10-12T12:18:00.000Z","path":"2019/10/12/工厂模式/","text":"工厂模式在平时编程中，构建对象最常用的方式是 new 一个对象。乍一看这种做法没什么不好，而实际上这也属于一种硬编码。每 new 一个对象，相当于调用者多知道了一个类，增加了类与类之间的联系，不利于程序的松耦合。其实构建过程可以被封装起来，工厂模式便是用于封装对象的设计模式。 简单工厂模式举个例子，直接 new 对象的方式相当于当我们需要一个苹果时，我们需要知道苹果的构造方法，需要一个梨子时，需要知道梨子的构造方法。更好的实现方式是有一个水果工厂，我们告诉工厂需要什么种类的水果，水果工厂将我们需要的水果制造出来给我们就可以了。这样我们就无需知道苹果、梨子是怎么种出来的，只用和水果工厂打交道即可。 水果工厂： 123456789public class FruitFactory { public Fruit create(String type){ switch (type){ case \"苹果\": return new Apple(); case \"梨子\": return new Pear(); default: throw new IllegalArgumentException(\"暂时没有这种水果\"); } }} 调用： 123456789public class User { private void eat(){ FruitFactory fruitFactory = new FruitFactory(); Fruit apple = fruitFactory.create(\"苹果\"); Fruit pear = fruitFactory.create(\"梨子\"); apple.eat(); pear.eat(); }} 事实上，将构建过程封装的好处不仅可以降低耦合，如果某个产品构造方法相当复杂，使用工厂模式可以大大减少代码重复。 简单工厂模式就是让一个工厂类承担构建所有对象的职责。调用者需要什么产品，让工厂生产出来即可。它的弊端也显而易见： 一是如果需要生产的产品过多，此模式会导致工厂类过于庞大，承担过多的职责，变成超级类。当苹果生产过程需要修改时，要来修改此工厂。梨子生产过程需要修改时，也要来修改此工厂。也就是说这个类不止一个引起修改的原因。违背了单一职责原则。 二是当要生产新的产品时，必须在工厂类中添加新的分支。而开闭原则告诉我们：类应该对修改封闭。我们希望在添加新功能时，只需增加新的类，而不是修改既有的类，所以这就违背了开闭原则。 工厂方法模式为了解决简单工厂模式的这两个弊端，工厂方法模式应运而生，它规定每个产品都有一个专属工厂。比如苹果有专属的苹果工厂，梨子有专属的梨子工厂，Java 代码如下： 苹果工厂： 12345public class AppleFactory { public Fruit create(){ return new Apple(); }} 梨子工厂： 12345public class PearFactory { public Fruit create(){ return new Pear(); }} 调用者： 12345678910public class User { private void eat(){ AppleFactory appleFactory = new AppleFactory(); Fruit apple = appleFactory.create(); PearFactory pearFactory = new PearFactory(); Fruit pear = pearFactory.create(); apple.eat(); pear.eat(); }} 调用者虽然不需要和 Apple 、Pear 类打交道了，但却需要和 AppleFactory、PearFactory 类打交道。有几种水果就需要知道几个工厂类，耦合度完全没有下降啊，甚至还增加了代码量！ 仔细想一想，工厂模式的第二个优点在工厂方法模式中还是存在的。当构建过程相当复杂时，工厂将构建过程封装起来，调用者可以很方便的直接使用，同样以苹果生产为例： 12345678public class AppleFactory { public Fruit create(){ AppleSeed appleSeed = new AppleSeed(); Sunlight sunlight = new Sunlight(); Water water = new Water(); return new Apple(appleSeed, sunlight, water); }} 调用者无需知道苹果的生产细节，当生产过程需要修改时也无需更改调用端。同时，工厂方法模式解决了简单工厂模式的两个弊端。 当生产的产品种类越来越多时，工厂类不会变成超级类。工厂类会越来越多，保持灵活。不会越来越大、变得臃肿。如果苹果的生产过程需要修改时，只需修改苹果工厂。梨子的生产过程需要修改时，只需修改梨子工厂。符合单一职责原则。 当需要生产新的产品时，无需更改既有的工厂，只需要添加新的工厂即可。保持了面向对象的可扩展性，符合开闭原则。 抽象工厂模式工厂方法模式可以进一步优化，提取出工厂接口： 123public interface IFactory { Fruit create();} 然后苹果工厂和梨子工厂都实现此接口： 123456public class AppleFactory implements IFactory { @Override public Fruit create(){ return new Apple(); }} 123456public class PearFactory implements IFactory { @Override public Fruit create(){ return new Pear(); }} 此时，调用者可以将 AppleFactory 和 PearFactory 统一作为 IFactory 对象使用： 12345678910public class User { private void eat(){ IFactory appleFactory = new AppleFactory(); Fruit apple = appleFactory.create(); IFactory pearFactory = new PearFactory(); Fruit pear = pearFactory.create(); apple.eat(); pear.eat(); }} 可以看到，我们在创建时指定了具体的工厂类后，在使用时就无需再关心是哪个工厂类，只需要将此工厂当作抽象的 IFactory 接口使用即可。这种经过抽象的工厂方法模式被称作抽象工厂模式。 由于客户端只和 IFactory 打交道了，调用的是接口中的方法，使用时根本不需要知道是在哪个具体工厂中实现的这些方法，这就使得替换工厂变得非常容易。 例如： 1234567public class User { private void eat(){ IFactory factory = new AppleFactory(); Fruit fruit = factory.create(); fruit.eat(); }} 如果需要替换为吃梨子，只需要更改一行代码即可： 1234567public class User { private void eat(){ IFactory factory = new PearFactory(); Fruit fruit = factory.create(); fruit.eat(); }} IFactory 中只有一个抽象方法时，或许还看不出抽象工厂模式的威力。实际上抽象工厂模式主要用于替换一系列方法。例如将程序中的 SQL Server 数据库整个替换为 Access 数据库，使用抽象方法模式的话，只需在 IFactory 接口中定义好增删改查四个方法，让 SQLFactory 和 AccessFactory 实现此接口，调用时直接使用 IFactory 中的抽象方法即可，调用者无需知道使用的什么数据库，我们就可以非常方便的整个替换程序的数据库，并且让客户端毫不知情。 抽象工厂模式很好的发挥了开闭原则、依赖倒置原则，但缺点是抽象工厂模式太重了，如果 IFactory 接口需要新增功能，则会影响到所有的具体工厂类。使用抽象工厂模式，替换具体工厂时只需更改一行代码，但要新增抽象方法则需要修改所有的具体工厂类。所以抽象工厂模式适用于增加同类工厂这样的横向扩展需求，不适合新增功能这样的纵向扩展。 参考：https://zhuanlan.zhihu.com/p/85624457 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://blog.iwxyi.com/tags/设计模式/"}]},{"title":"单例模式","date":"2019-10-12T12:17:00.000Z","path":"2019/10/12/单例模式/","text":"单例模式单例模式非常常见，某个对象全局只需要一个实例时，就可以使用单例模式。它的优点也显而易见： 它能够避免对象重复创建，节约空间并提升效率 避免由于操作不同实例导致的逻辑错误 单例模式有两种实现方式：饿汉式和懒汉式。 饿汉式饿汉式：变量在声明时便初始化。 1234567891011public class Singleton { private static Singleton instance = new Singleton(); private Singleton() { } public static Singleton getInstance() { return instance; }} 可以看到，我们将构造方法定义为 private，这就保证了其他类无法实例化此类，必须通过 getInstance 方法才能获取到唯一的 instance 实例，非常直观。但饿汉式有一个弊端，那就是即使这个单例不需要使用，它也会在类加载之后立即创建出来，占用一块内存，并增加类初始化时间。就好比一个电工在修理灯泡时，先把所有工具拿出来，不管是不是所有的工具都用得上。就像一个饥不择食的饿汉，所以称之为饿汉式。 懒汉式懒汉式：先声明一个空变量，需要用时才初始化。 1234567891011121314public class Singleton { private static Singleton instance = null; private Singleton() { } public static Singleton getInstance(){ if (instance == null) { instance = new Singleton(); } return instance; }} 我们先声明了一个初始值为 null 的 instance 变量，当需要使用时判断此变量是否已被初始化，没有初始化的话才 new 一个实例出来。就好比电工在修理灯泡时，开始比较偷懒，什么工具都不拿，当发现需要使用螺丝刀时，才把螺丝刀拿出来。当需要用钳子时，再把钳子拿出来。就像一个不到万不得已不会行动的懒汉，所以称之为懒汉式。 懒汉式解决了饿汉式的弊端，好处是按需加载，避免了内存浪费，减少了类初始化时间。 双检锁方式：线程安全上述代码的懒汉式单例乍一看没什么问题，但其实它不是线程安全的。如果有多个线程同一时间调用 getInstance 方法，instance 变量可能会被实例化多次。为了保证线程安全，我们需要给判空过程加上锁： 12345678910111213141516public class Singleton { private static Singleton instance = null; private Singleton() { } public static Singleton getInstance() { synchronized (Singleton.class) { if (instance == null) { instance = new Singleton(); } } return instance; }} 这样就能保证多个线程调用 getInstance 时，一次最多只有一个线程能够执行判空并 new 出实例的操作，所以 instance 只会实例化一次。 双检锁提高性能但这样的写法仍然有问题，当多个线程调用 getInstance 时，每次都需要执行 synchronized 同步化方法，这样会严重影响程序的执行效率。所以更好的做法是在同步化之前，再加上一层检查： 123456789101112131415161718public class Singleton { private static Singleton instance = null; private Singleton() { } public static Singleton getInstance() { if (instance == null) { synchronized (Singleton.class) { if (instance == null) { instance = new Singleton(); } } } return instance; }} 这样增加一种检查方式后，如果 instance 已经被实例化，则不会执行同步化操作，大大提升了程序效率。上面这种写法也就是我们平时较常用的双检锁方式实现的线程安全的单例模式。 静态内部类方式除了双检锁方式外，还有一种比较常见的静态内部类方式保证懒汉式单例的线程安全： 12345678910111213public class Singleton { private static class SingletonHolder { public static Singleton instance = new Singleton(); } private Singleton() { } public static Singleton getInstance() { return SingletonHolder.instance; }} 虽然我们经常使用这种静态内部类的懒加载方式，但其中的原理不一定每个人都清楚。接下来我们便来分析其原理，搞清楚两个问题： 静态内部类方式是怎么实现懒加载的 静态内部类方式是怎么保证线程安全的 Java 类的加载过程包括：加载、验证、准备、解析、初始化。初始化阶段即执行类的 clinit 方法（clinit = class + initialize），包括为类的静态变量赋初始值和执行静态代码块中的内容。但不会立即加载内部类，内部类会在使用时才加载。所以当此 Singleton 类加载时，SingletonHolder 并不会被立即加载，所以不会像饿汉式那样占用内存。 另外，Java 虚拟机规定，当访问一个类的静态字段时，如果该类尚未初始化，则立即初始化此类。当调用Singleton 的 getInstance 方法时，由于其使用了 SingletonHolder 的静态变量 instance，所以这时才会去初始化 SingletonHolder，在 SingletonHolder 中 new 出 Singleton 对象。这就实现了懒加载。 第二个问题的答案是 Java 虚拟机的设计是非常稳定的，早已经考虑到了多线程并发执行的情况。虚拟机在加载类的 clinit 方法时，会保证 clinit 在多线程中被正确的加锁、同步。即使有多个线程同时去初始化一个类，一次也只有一个线程可以执行 clinit 方法，其他线程都需要阻塞等待，从而保证了线程安全。 懒汉式的缺点就是将程序加载时间从启动时延后到了运行时，虽然启动时间缩短了，但我们浏览页面时就会看到数据的 loading 过程。 一般的建议是：对于构建不复杂，加载完成后会立即使用的单例对象，推荐使用饿汉式。对于构建过程耗时较长，并不是所有使用此类都会用到的单例对象，推荐使用懒汉式。 参考：https://zhuanlan.zhihu.com/p/85624457 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://blog.iwxyi.com/tags/设计模式/"}]},{"title":"修电脑","date":"2019-09-24T12:39:00.000Z","path":"2019/09/24/修电脑/","text":"WIN无操作自动休眠这是系统无人值守时睡眠时间的设定，默认是两分钟。 解决方法： regedit进入注册表管理器，定位到HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Power\\PowerSettings\\238C9FA8-0AAD-41ED-83F4-97BE242C8F20\\7bc4a2f9-d8fc-4469-b07b-33eb785aaca0，修改attributes的值为2。 进入高级电源设置，在睡眠选项中会出现“无人参与系统睡眠超时”，将默认的2分钟修改成你想要的时间。 开关注册中心regedit进入注册表编辑器，计算机\\HKEY_CURRENT_USER\\Software\\Policies\\Microsoft\\Windows\\Explorer新建项DisableNotificationCenter，值为1时关闭操作中心。重启电脑生效。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Windows","slug":"Windows","permalink":"http://blog.iwxyi.com/tags/Windows/"}]},{"title":"小顶堆TopN","date":"2019-07-07T12:48:00.000Z","path":"2019/07/07/小顶堆TopN/","text":"应用场景：10亿个数中取前1000大的数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105import java.util.Arrays;public class SmallHeap { /** * &lt;description&gt;获取前N数据&lt;/description&gt; * * @param arr * @param n * @author: ouyp * @since: Seeyon V7.0 SP2 * @date: 2018年10月16日 下午4:52:27 */ public static int[] topN(int[] arr, int n) { /** * 构建堆积 */ int[] list = new int[n]; System.arraycopy(arr, 0, list, 0, n); for (int i = 0; i &lt; n; i++) { int t = i; while (t != 0 &amp;&amp; list[parent(t)] &gt; list[t]) { swap(list, t, t = parent(t)); } } /** * 小顶堆 */ for (int i = n, len = arr.length; i &lt; len; i++) { if (arr[i] &gt;= list[0]) { // 置换栈顶 list[0] = arr[i]; // 调整栈顶 int t = 0; while ((left(t) &lt; n &amp;&amp; list[t] &gt; list[left(t)]) || (right(t) &lt; n &amp;&amp; list[t] &gt; list[right(t)])) { if (right(t) &lt; n &amp;&amp; list[right(t)] &lt; list[left(t)]) { swap(list, t, t = right(t)); } else { swap(list, t, t = left(t)); } } } } return list; } /** * &lt;description&gt;对象交换&lt;/description&gt; * * @param list * @param i * @param j * @author: ouyp * @since: Seeyon V7.0 SP2 * @date: 2018年10月16日 下午4:56:33 */ private static void swap(int[] list, int i, int j) { int tmp = list[i]; list[i] = list[j]; list[j] = tmp; } /** * &lt;description&gt;父节点索引&lt;/description&gt; * * @param i * @return * @author: ouyp * @date: 2018年10月16日 下午3:34:22 */ private static int parent(int i) { return (i - 1) / 2; } /** * &lt;description&gt;左孩子索引&lt;/description&gt; * * @param i * @return * @author: ouyp * @date: 2018年10月16日 下午4:01:30 */ private static int left(int i) { return 2 * i + 1; } /** * &lt;description&gt;右孩子索引&lt;/description&gt; * * @param i * @return * @author: ouyp * @date: 2018年10月16日 下午4:02:04 */ private static int right(int i) { return 2 * i + 2; } public static void main(String[] args) { int[] arr = new int[]{56, 30, 71, 18, 29, 93, 44, 75, 20, 65, 68, 34}; System.out.println(\"原始数组: \"); System.out.println(Arrays.toString(arr)); System.out.println(\"调整后数组: \"); System.out.println(Arrays.toString(SmallHeap.topN(arr, 5))); }} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"算法","slug":"算法","permalink":"http://blog.iwxyi.com/tags/算法/"}]},{"title":"公众号token服务器配置","date":"2019-04-14T12:30:00.000Z","path":"2019/04/14/公众号token服务器配置/","text":"修改公众号的服务器配置 Token配置代码，文件放在对应的URL路径下 微信会发送GET请求来验证 12345678910111213141516171819202122232425262728&lt;?phpdefine(\"TOKEN\", \"mrxy\"); // 你自己的Token//验证消息$echoStr = $_GET[\"echostr\"];if(checkSignature()){ echo $echoStr; exit;}//检查签名function checkSignature(){ $signature = $_GET[\"signature\"]; $timestamp = $_GET[\"timestamp\"]; $nonce = $_GET[\"nonce\"]; $token = TOKEN; $tmpArr = array($token, $timestamp, $nonce); sort($tmpArr, SORT_STRING); $tmpStr = implode($tmpArr); $tmpStr = sha1($tmpStr); if($tmpStr == $signature){ return true; }else{ return false; }} 微信授权网页登录：https://www.cnblogs.com/whowhere/p/5787247.html 微信扫码登录：https://www.cnblogs.com/0201zcr/p/5133062.html document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"微信小程序","slug":"微信小程序","permalink":"http://blog.iwxyi.com/tags/微信小程序/"}]},{"title":"ASP.NET文件操作","date":"2019-01-24T13:09:00.000Z","path":"2019/01/24/ASP-NET文件操作/","text":"以文件为例,如果对文件夹操作,基本上将File换为Directory即可(例:FileInfo file = new FileInfo(Path);与DirectoryInfo directory = new DirectoryInfo (Path);) 1获取文件信息 在知道文件相对路径的情形,下面代码可以获取文件的详细信息 12345678910public static void fileinfo(string Path){ Path = Server.MapPath(Path);//获取文件的物理路径 FileInfo file = new FileInfo(Path);//实例该路径文件信息 var length=file.Length;//文件大小,字节 var name = file.Name;//文件名 var fullname = file.FullName;//文件路径 var extension = file.Extension;//文件后缀名 ......} 获取的信息还有创建时间,最后访问时间等等,可以自行研究 2新建文件 新建一个文件。（Create 后会一直占用，最好加上 Dispose） 123456789101112public static void NewFile(string filePath){ filePath=Server.MapPath(filePath);//获取想创建文件的物理路径 if (System.IO.File.Exists(newfilepath)) { //判断新建的文件是否已经存在 throw new Exception(\"文件已经存在\") } System.IO.File.Create(newfilepath);//创建 ......} 3复制文件,移动(剪切)文件,重命名文件 复制文件: 123456789101112public static void Copy(string Path,string targetPath){ Path = Server.MapPath(Path);//原文件的物理路径 targetPath = Server.MapPath(targetPath);//复制到的新位置物理路径 //判断到的新地址是否存在重命名文件 if (System.IO.File.Exists(targetPath)) { throw new Exception(\"存在同名文件\");//抛出异常 } System.IO.File.Copy(Path,targetPath);//复制到新位置,不允许覆盖现有文件 .......} 移动文件,重命名: 12345678910111213public static void MoveOrRename(string Path,string targetPath){ Path = Server.MapPath(Path);//原文件的物理路径 targetPath = Server.MapPath(targetPath);//移动到的新位置的物理路径(如果还是当前文件夹,则会重命名文件) //判断到的新地址是否存在重命名文件 if (System.IO.File.Exists(targetPath)) { //判断是新位置是否存在同名(判断重命名是狗和其他文件冲突) throw new Exception(\"已经存在同名文件\"); } System.IO.File.Move(Path,targetPath);//2个文件在不同目录则是移动,如果在相同目录下则是重命名 ......} 复制文件不会删除,移动或者重命名(方法相同,就是目标位置不同)会删除原文件. 4上传文件 12345678910111213141516171819[HttpPost]//通过Post请求接收前台传来的文件数据public ActionResult UploadFile(string dirPath){ var filepath = Server.MapPath(Path);//获取上传的文件存入目录的物理路径 var file = Request.Files[\"file\"];//获取文件内容 if (file == null || file.ContentLength == 0) { throw new Exception(\"文件不存在\");//简单判断下文件 } var newfilepath = Server.MapPath(dirPath + \"\\\\\" + file.FileName);//获取文件名的物理路径 //判断要上传的文件是否与目录中的文件重命名 if (System.IO.File.Exists(newfilepath)) { throw new Exception(\"文件不存在\");//简单判断下文件是否存在 } //文件存放到指定的文件中 ; file.SaveAs(newfilepath); ......} 会自动创建存有该类容和命名的文件,不用多此一举去创建一个新文件再放入内容. 5遍历当前目录和其子目录所有文件 12345678910111213141516171819202122232425262728293031private static string[] GetFiles(string dir, string regexPattern = null, bool recurse = true, bool throwEx = false){ //recurse:是否递归 //throwEx:是否报出异常 List&lt;string&gt; lst = new List&lt;string&gt;(); try { foreach (string item in Directory.GetFileSystemEntries(dir)) { try { bool isFile = (System.IO.File.GetAttributes(item) &amp; FileAttributes.Directory) != FileAttributes.Directory; if (isFile &amp;&amp; (regexPattern == null || Regex.IsMatch(Path.GetFileName(item), regexPattern, RegexOptions.IgnoreCase | RegexOptions.Multiline))) { lst.Add(item); } //递归 if (recurse &amp;&amp; !isFile) { lst.AddRange(GetFiles(item, regexPattern, true)); } } catch { if (throwEx) { throw; } } } } catch { if (throwEx) { throw; } } return lst.ToArray();} 这个不多说,网上找到的代码,亲测有效 System.IO.File.Create 不会自动释放，一定要Dispose这样会导致W3P进程一直占用这个文件 System.IO.File.Create(HttpContext.Current.Server.MapPath(strName)); 最好加上Dispose() System.IO.File.Create(HttpContext.Current.Server.MapPath(strName)).Dispose(); document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"ASP.NET","slug":"ASP-NET","permalink":"http://blog.iwxyi.com/tags/ASP-NET/"},{"name":"文件","slug":"文件","permalink":"http://blog.iwxyi.com/tags/文件/"}]},{"title":"ASP.NET-学习笔记","date":"2019-01-15T13:11:00.000Z","path":"2019/01/15/ASP-NET-学习笔记/","text":"ASP.NET 简介ASP.NET 是新一代的 ASP。它无法兼容经典 ASP，但 ASP.NET 可以引用 ASP。 ASP.NET 页面需要编译，因此比经典 ASP 更快。 ASP.NET 拥有更好的语言支持，大量用户控件，基于 XML 的组件，以及对用户认证的整合。 ASP.NET 页面的扩展名是 .aspx，通常由 VB (Visual Basic) 或 C# (C sharp) 编写。 ASP.NET 中的用户控件可以通过不同的语言进行编写，包括 C++ 和 Java。 当浏览器请求 ASP.NET 文件时，ASP.NET 引擎读取该文件，编译并执行文件中的脚本，然后以纯 HTML 向浏览器返回结果。 扩展名 ASP 文件的文件扩展名是 .asp ASP.NET 文件的文件扩展名是 .aspx ASP.NET 文件使用 C# 语法的文件扩展名是 .cshtml ASP.NET 文件使用 Razor VB 语法的文件扩展名是 .vbhtml WP 教程Web Pages 是三种 ASP.NET 编程模型中的一种，用于创建 ASP.NET 网站和 web 应用程序。 其他两种编程模型是 Web Forms 和 MVC (Model, View, Controller)。 Web Pages 是最简单的 ASP.NET 网页开发编程模型。它提供了一种简单的方法将 HTML、CSS、JavaScript 以及服务器代码结合起来。 WP Razor Razor 是一种向网页添加基于服务器的代码的标记语法 Razor 拥有传统 ASP.NET 标记的能力，但是更易学习，更易使用 Razor 是一种类似 ASP 和 PHP 的服务器端标记语法 Razor 支持 C# 和 Visual Basic 编程语言 1&lt;p&gt;The time is @DateTime.Now&lt;/p&gt; 包含常规的 HTML 标记，此外还包含：由 @ 标记的 Razor 代码。 C# 的主要 Razor 语法规则 Razor 代码块由 @{ … } 包围 行内表达式（变量和函数）以 @ 开始 代码语句以分号结束 变量通过 var 关键词进行声明 字符串用引用来包围 C# 代码对大小写敏感 C# 文件的扩展名是 .cshtml 实例 12345678910111213&lt;!-- 单行代码块 --&gt;@{ var myMessage = \"Hello World\"; }&lt;!-- 行内表达式或变量 --&gt;&lt;p&gt;The value of myMessage is: @myMessage&lt;/p&gt; &lt;!-- 多行代码块 --&gt;@{var greeting = \"Welcome to our site!\";var weekDay = DateTime.Now.DayOfWeek;var greetingMessage = greeting + \" Today is: \" + weekDay;}&lt;p&gt;The greeting is: @greetingMessage&lt;/p&gt; VB 的主要 Razor 语法规则 Razor 代码块由 @Code … End 包围 行内表达式（变量和函数）以 @ 开始 变量通过 Dim 关键词进行声明 字符串用引用来包围 C# 代码对大小写不敏感 C# 文件的扩展名是 .vbhtml 实例 1234567891011121314&lt;!-- 单行代码块 --&gt;@Code dim myMessage = \"Hello World\" End Code &lt;!-- 行内表达式或变量 --&gt;&lt;p&gt;The value of myMessage is: @myMessage&lt;/p&gt; &lt;!-- 多行代码块 --&gt;@Codedim greeting = \"Welcome to our site!\" dim weekDay = DateTime.Now.DayOfWeek dim greetingMessage = greeting &amp; \" Today is: \" &amp; weekDayEnd Code &lt;p&gt;The greeting is: @greetingMessage&lt;/p&gt; WP 布局###内容快 使用 @RenderPage() 方法从不同的文件导入内容。 内容块（来自另一个文件）能够被输入网页中的任意位置，并可包含文本、标记和代码，就像任何常规的网页那样。 12345678&lt;html&gt;&lt;body&gt; @RenderPage(\"header.cshtml\") &lt;h1&gt;Hello Web Pages&lt;/h1&gt; &lt;p&gt;This is a paragraph&lt;/p&gt; @RenderPage(\"footer.cshtml\")&lt;/body&gt;&lt;/html&gt; 布局页面创建一致外观的另一种方法是使用布局网页。布局网页包含网页的结构，而不是内容。当网页（内容页）链接到布局页时，它会根据布局页（模板）来显示。 布局页类似普通的网页，但是会在引用内容页的位置调用 @RenderBody() 方法。 每个内容页必须以 Layout 指令开头。 布局网页：Layout.cshtml 1234567&lt;html&gt;&lt;body&gt; &lt;p&gt;This is header text&lt;/p&gt; @RenderBody() &lt;p&gt;© 2012 W3School. All rights reserved.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 任意网页：（被包含在布局网页中） 123456789@{Layout=\"Layout.cshtml\";}&lt;h1&gt;Welcome to W3Schools&lt;/h1&gt;&lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit,sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laborisnisi ut aliquip ex ea commodo consequat.&lt;/p&gt; 防止代码泄露名称以下划线开头的文件无法通过 web 来浏览。 隐藏敏感信息（数据库密码、电邮密码等）的常用方法是把这些信息保存在名为 “_AppStart” 的独立文件中 _AppStart.cshtml1234567@{ WebMail.SmtpServer = \"mailserver.example.com\"; WebMail.EnableSsl = true; WebMail.UserName = \"username@example.com\"; WebMail.Password = \"your-password\"; WebMail.From = \"your-name-here@example.com\";} WP 文件夹ASP.NET 网页的典型文件夹结构： “Account” 文件夹包含登录和安全文件 “App_Data” 文件包含数据库和数据文件 “Images” 文件夹包含图片 “Scripts” 文件夹包含浏览器脚本 “Shared” 文件夹包含通用文件（比如布局和样式文件） 物理文件结构类似：C:\\Johnny\\Documents\\MyWebSites\\Demo\\Images URL 和路径URL 用于从 web 访问文件： http://www.w3school.com.cn/html5/html5_intro.asp URL 在服务器上对应的文件是： C:\\MyWebSites\\htm5\\html5_intro.asp 1234URL http://www.w3school.com.cn/html/html5_intro.asp服务器名 w3school虚拟路径 /html/html5_intro.asp物理路径 C:\\MyWebSites\\w3school\\/html/html5_intro.asp ~ 操作符如需在编程代码中规定虚拟根目录，请使用 ~ 操作符。 如果您使用 ~ 操作符，而不是路径，就能够在不改变任何代码的情况下，将网站移动到不同的文件夹或位置： 12var myImagesFolder = \"~/images\";var myStyleSheet = \"~/styles/StyleSheet.css\"; Server.MapPath 方法Server.MapPath 方法将虚拟路径 (/default.cshtml) 转换为服务器能够理解的物理路径 (C:\\Johnny\\MyWebSited\\Demo\\default.cshtml)。 当需要打开位于服务器上的数据文件时，您就会用到该方法（数据文件只能通过完整的物理路径来访问）： 12var pathName = \"~/dataFile.txt\";var fileName = Server.MapPath(pathName); Href 方法Href 方法把代码中的路径转换为浏览器能够理解的路径（浏览器无法理解 ~ 操作符）。 您使用 Href 方法来创建指向资源（比如图片和 CSS 文件）的路径。 您会经常在 HTML 、&lt;a&gt;、&lt;img&gt; 以及 &lt;link&gt; 元素中用到该方法： 123456@{var myStyleSheet = \"~/Shared/Site.css\";}&lt;!-- 创建指向 CSS 文件的链接 --&gt;&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"@Href(myStyleSheet)\" /&gt;&lt;!-- 同上 : --&gt; WP 全局Web 启动之前：_AppStart假如站点根目录中名为 _AppStart 的页面存在，ASP.NET 会在站点内的任何页面被请求之前首先运行这个页面。 通常 _AppStart 用于启动代码和全局值的初始化，比如计数器和全局名称。 注释 1：_AppStart 的文件扩展名应与网页相同，比如 _AppStart.cshtml。 注释 2：_AppStart 有下划线前缀。正因如此，用户才无法直接查看该文件 每张页面之前：_PageStart就像在站点启动前运行 _AppStart 那样，您能够在每个文件夹中的任意页面之前运行代码。 对于 web 中的每个文件夹，您能够添加名为 _PageStart 的文件。 通常 _PageStart 用于设置文件夹中所有页面的布局文件，或者在运行页面之前检查用户登录。 当请求到来时，ASP.NET 检查 _AppStart 是否存在。如果存在，并且这是对站点的第一次请求，则运行 _AppStart。 然后 ASP.NET 检查 _PageStart 是否存在。如果存在，则运行 _PageStart，在被请求的页面之前。 如果您在 _PageStart 内部引用了对 RunPage() 的调用，那么您可以规定在何处运行被请求的页面。否则，_PageStart 在被请求页面之前运行。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"ASP.NET","slug":"ASP-NET","permalink":"http://blog.iwxyi.com/tags/ASP-NET/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://blog.iwxyi.com/tags/学习笔记/"}]},{"title":"Markdown-讲解","date":"2018-12-07T13:05:00.000Z","path":"2018/12/07/正则表达式-讲解/","text":"Markdown 简介Markdown 是一种轻量级的「标记语言」，通常为程序员群体所用，适用于泡技术论坛、写博客日志、技术文稿、记录代码片段、起草邮件等场景。 可以通过简单、易读易写的文本格式生成结构化的 HTML 网页，以及 Word 和 pdf 文档。目前 知乎、简书、github、Stackoverflow、以及绝大多数博客论坛 均支持这种格式。 为什么要学 Markdown？因为简单；因为好用；因为这篇教程就是用 Markdown 写的。 让“码字的归码字，排版的归排版”，专注写作，效率快速提升； 除此之外基础的任务管理、项目管理、逻辑梳理、公式协作等等，都可以用基本的Markdown来完成…… 优点：简单符号排版，15 分钟上手。 纯键盘操作，写作时少调用鼠标，效率能提升很多。 使用 Markdown 的 h1、h2、h3 标题，列表、分列表，结构和逻辑都很清晰。排版成同样的效果，md 与 word 比起来简直毫不费力气。另外，还有插入图片、链接、粗体、斜体等功能。 纯文本编辑，轻量级。纯文本有很多好处，例如占用空间小、移植方便快捷、可以用 git 比较版本、编辑时不需要软件支持等。 目前支持将 md 转换为多种格式，包括 html、tex、pdf 等。 缺点： 语法不是很统一，不同的编辑器语法有区别 不能对文档进行精细调整，或者个性化调整。 据说过于程序员友好。 对话式红楼梦曹雪芹写的效果如下：贾芸听声音像是熟人，仔细一看，原来是紧邻倪二。这倪二是个泼皮，专放重利债，在赌博场吃饭，专爱喝酒打架。此时正从欠钱人家索债归来，已在醉乡，不料贾芸碰了他，就要动手。贾芸叫道：“老二！住手！是我冲撞了你。”倪二一听他的语音，将醉眼睁开一看，见是贾芸，忙松了手，趔趄著笑道：“原来是贾二爷。这会子那里去？”贾芸道：“告诉不得你，平白的又讨了个没趣儿！”倪二道：“不妨。有什么不平的事，告诉我，我替你出气。这三街六巷，凭他是谁，若得罪了我醉金刚倪二的街坊，管叫他人离家散！”贾芸道：“老二，你别生气，听我告诉你这缘故。”便把卜世仁一段事告诉了倪二。倪二听了，大怒道：“要不是二爷的亲戚，我就骂出来，真真把人气死！－－也罢，你也不必愁，我这里现有几两银子，你要用只管拿去。我们好街坊，这银子是不要利钱的。”一头说，一头从搭包内掏出一包银子来。 Markdown 的效果 用Markdown简单处理一下的话，这段的排版就变了： 贾芸听声音像是熟人，仔细一看，原来是紧邻倪二。这倪二是个泼皮，专放重利债，在赌博场吃饭，专爱喝酒打架。此时正从欠钱人家索债归来，已在醉乡，不料贾芸碰了他，就要动手。贾芸叫道： “老二！住手！是我冲撞了你。” 倪二一听他的语音，将醉眼睁开一看，见是贾芸，忙松了手，趔趄著笑道： “原来是贾二爷。这会子那里去？” 贾芸道： “告诉不得你，平白的又讨了个没趣儿！” 倪二道： “不妨。有什么不平的事，告诉我，我替你出气。这三街六巷，凭他是谁，若得罪了我醉金刚倪二的街坊，管叫他人离家散！” 贾芸道： “老二，你别生气，听我告诉你这缘故。” 便把卜世仁一段事告诉了倪二。倪二听了，大怒道： “要不是二爷的亲戚，我就骂出来，真真把人气死！－－也罢，你也不必愁，我这里现有几两银子，你要用只管拿去。我们好街坊，这银子是不要利钱的。” 一头说，一头从搭包内掏出一包银子来。 开始撰写 Markdown标题Markdown 支持两种标题的语法，类 Setext 和类 atx 形式。（部分编辑器不支持） 类 Setext 形式是用底线的形式，利用 = （最高阶标题）和 - （第二阶标题），例如： 12345This is an H1=============This is an H2------------- 类 Atx 形式则是在行首插入 1 到 6 个 # ，对应到标题 1 到 6 阶，例如： 12345# 这是 H1## 这是 H2###### 这是 H6 你可以选择性地「闭合」类 atx 样式的标题，这纯粹只是美观用的，若是觉得这样看起来比较舒适，你就可以在行尾加上 #，而行尾的 # 数量也不用和开头一样（行首的井字符数量决定标题的阶数）： 12345# 这是 H1 ### 这是 H2 ##### 这是 H3 ###### 区块引用BlockquotesMarkdown 标记区块引用是使用类似 email 中用 &gt; 的引用方式。如果你还熟悉在 email 信件中的引言部分，你就知道怎么在 Markdown 文件中建立一个区块引用，那会看起来像是你自己先断好行，然后在每行的最前面加上 &gt; ： 123456&gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,&gt; consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.&gt; Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.&gt; &gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse&gt; id sem consectetuer libero luctus adipiscing. Markdown 也允许你偷懒只在整个段落的第一行最前面加上 &gt; ： 123456&gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.&gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisseid sem consectetuer libero luctus adipiscing. 区块引用可以嵌套（例如：引用内的引用），只要根据层次加上不同数量的 &gt; ： 12345 This is the first level of quoting.&gt;&gt; &gt; This is nested blockquote.&gt;&gt; Back to the first level. 引用的区块内也可以使用其他的 Markdown 语法，包括标题、列表、代码区块等： 12345678&gt; ## 这是一个标题。&gt; &gt; 1. 这是第一行列表项。&gt; 2. 这是第二行列表项。&gt; &gt; 给出一些例子代码：&gt; &gt; return shell_exec(\"echo $input | $markdown_script\"); 任何像样的文本编辑器都能轻松地建立 email 型的引用。例如在 BBEdit 中，你可以选取文字后然后从选单中选择增加引用阶层。 列表Markdown 支持有序列表和无序列表。 无序列表使用星号、加号或是减号作为列表标记： 123* Red* Green* Blue 等同于： 123+ Red+ Green+ Blue 也等同于： 123- Red- Green- Blue 有序列表则使用数字接着一个英文句点（word里面也是这样）： 1231. Bird2. McHale3. Parish 列表项目标记通常是放在最左边，但是其实也可以缩进，最多 3 个空格，项目标记后面则一定要接着至少一个空格或制表符。 要让列表看起来更漂亮，你可以把内容用固定的缩进整理好： 12345* Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.* Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse id sem consectetuer libero luctus adipiscing. 但是如果你懒，那也行： 12345* Lorem ipsum dolor sit amet, consectetuer adipiscing elit.Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi,viverra nec, fringilla in, laoreet vitae, risus.* Donec sit amet nisl. Aliquam semper ipsum sit amet velit.Suspendisse id sem consectetuer libero luctus adipiscing. 列表项目可以包含多个段落，每个项目下的段落都必须缩进 4 个空格或是 1 个制表符： 1234567891. This is a list item with two paragraphs. Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus. Donec sit amet nisl. Aliquam semper ipsum sit amet velit.2. Suspendisse id sem consectetuer libero luctus adipiscing. 如果你每行都有缩进，看起来会看好很多，当然，再次地，如果你很懒惰，Markdown 也允许： 1234567* This is a list item with two paragraphs. This is the second paragraph in the list item. You'reonly required to indent the first line. Lorem ipsum dolorsit amet, consectetuer adipiscing elit.* Another item in the same list. 如果要在列表项目内放进引用，那 &gt; 就需要缩进： 1234* A list item with a blockquote: &gt; This is a blockquote &gt; inside a list item. 如果要放代码区块的话，该区块就需要缩进两次，也就是 8 个空格或是 2 个制表符：（有些编辑器不支持） 123* 一列表项包含一个列表区块： &lt;代码写在这&gt; 当然，项目列表很可能会不小心产生，像是下面这样的写法 11986. What a great season. 换句话说，也就是在行首出现数字-句点-空白，要避免这样的状况，你可以在句点前面加上反斜杠。 11986\\. What a great season. 待办事项用 - [ ] 来表示一个待办事项列表（注意有三个空格） 12- [ ] 未完成列表- [x] 已完成列表 代码区块和程序相关的写作或是标签语言原始码通常会有已经排版好的代码区块，通常这些区块我们并不希望它以一般段落文件的方式去排版，而是照原来的样子显示，Markdown 会用 &lt;pre&gt; 和 &lt;code&gt; 标签来把代码区块包起来。 要在 Markdown 中建立代码区块很简单，只要用一对12345~~~C++```C++ for (int i = 0; i &lt; 10; i++) printf(\"%d\\n\", i); ~ 上面的123456### 分隔线你可以在一行中用三个以上的短横杠来建立一个分隔线，行内不能有其他东西。 123456### 链接链接文字用 [方括号] 来标记，要建立一个行内的链接，只要在方块括号后面紧接着圆括号并插入网址链接即可，例如： This is an example inline link. This link has no title attribute. 12如果你是要链接到同样主机的资源，你可以使用相对路径： See my About page for details. 123456### 强调Markdown 使用星号（*）和底线（_）作为标记强调字词的符号 。一对是斜体，两对是粗体。 single asterisks single underscores double asterisks double underscores 123456789101112*single asterisks*_single underscores_**double asterisks**__double underscores__你可以随便用你喜欢的样式，唯一的限制是，你用什么符号开启标签，就要用什么符号结束。强调也可以直接插在文字中间： unfriggingbelievable 1234但是**如果你的 \\* 和 _ 两边都有空白的话，它们就只会被当成普通的符号。**如果要在文字前后直接插入普通的星号或底线，你可以用反斜线： *this text is surrounded by literal asterisks* 123456### 删除线使用两对波浪线 ~~ 来给文字加上~~删除线~~。注意波浪线和文字之间不能有空格。 删除线 123456### 代码如果要标记一小段行内代码，你可以用反引号把它包起来（`），例如： Use the printf() function. 12如果要在代码区段内插入反引号，你可以用多个反引号来开启和结束代码区段： There is a literal backtick (`) here. 12345678910### 图片很明显地，要在纯文字应用中设计一个「自然」的语法来插入图片是有一定难度的。Markdown 使用一种和链接很相似的语法来标记图片，同样也允许两种样式： 行内式和参考式。行内式的图片语法看起来像是： Alt text 1234567891011121314详细叙述如下：- 一个惊叹号 !- 接着一个方括号，里面放上图片的替代文字- 接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上 选择性的 'title' 文字。到目前为止， Markdown 还没有办法指定图片的宽高，如果你需要的话，你可以使用普通的 `&lt;img&gt;` 标签。### 反斜杠Markdown 可以利用反斜杠来插入一些在语法中有其它意义的符号，例如：如果你想要用星号加在文字旁边的方式来做出强调效果，你可以在星号的前面加上反斜杠： *literal asterisks* 12Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号： \\ 反斜线` 反引号 星号_ 底线{} 花括号[] 方括号() 括弧井字号 加号 减号. 英文句点! 惊叹号123456### 自动链接Markdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用方括号包起来， Markdown 就会自动把它转成链接。一般网址的链接文字就和链接地址一样，例如： http://example.com/ 12邮址的自动链接也很类似，只是 Markdown 会先做一个编码转换的过程，把文字字符转成 16 进位码的 HTML 实体，这样的格式可以糊弄一些不好的邮址收集机器人，例如： address@example.com 123456### 表格表格是Markdown语法中比较复杂的一个，其语法如下： 表头 条目一 条目二 项目 项目一 项目二 ``` 以上标记显示效果如下： 表头 条目一 条目二 项目 项目一 项目二 注：三个短斜杠左右的冒号用于控制对齐方式，只放置左边冒号表示文字居左，只放置右边冒号表示文字居右，如果两边都放置冒号表示文字居中。不加冒号默认左对齐。 文字上色使用Markdown的同学最郁闷的地方恐怕就是不能给文字添加颜色了。事实上，Markdown的最初目标就是为纯写作而生的。因此，它并没有考虑文字颜色这一点。所以，单纯使用Markdown设置文字颜色已经做不到了。但你可以这样做： 先用Markdown编辑完成 导出为html，在需要上色的部分手动添加标签&lt;font color='#ff0000'&gt; &lt;/font&gt;保存即可。 Latex数学公式1.行内公式：使用两个”$”符号引用公式: $公式$ 2.行间公式：使用两对“$$”符号引用公式： $$公式$$ 输例如$\\sqrt{x^{2}}$ 上标下标在$ $ 公式中，用 ^p 表示上标。若有多个，用 { } 括起来。 下标符号为 _，用法同上标。 Typora 的扩展语法中，可以用^上标^与~下标~来表示（需要先到设置中开启） 结语在文档中，内容远远比工具和格式重要。但适当的格式和工具也会增强文字的渲染力。 Markdown 是纯文本和富文本之间最恰当的选择。 博客来源：整理，网络，主要是 http://www.markdown.cn/ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"语法","slug":"语法","permalink":"http://blog.iwxyi.com/tags/语法/"},{"name":"讲解","slug":"讲解","permalink":"http://blog.iwxyi.com/tags/讲解/"}]},{"title":"栈与队列-讲解","date":"2018-12-07T12:50:00.000Z","path":"2018/12/07/栈与队列-讲解/","text":"介绍栈栈是一种特殊的线性表。其特殊性在于限定插入和删除数据元素的操作只能在线性表的一端进行。如下所示： 结论：先进后出 &amp;&amp; 后进先出（Last In First Out），简称为LIFO线性表。 例子：手机任务的返回栈、食堂餐盘从下到上叠起来，送给洗盘子的人，从上到下洗 队列队列(Queue)也是一种运算受限的线性表，它的运算限制与栈不同，是两头都有限制，插入只能在表的一端进行(只进不出)，而删除只能在表的另一端进行(只出不进)，允许删除的一端称为队尾(rear)，允许插入的一端称为队头 (Front),如图所示： 结论：队列的操作原则是先进先出的，所以队列又称作FIFO表(First In First Out) 例子：各种排队 纯 C 用法（函数）栈123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;stdio.h&gt;#define MAX_SIZE 1000int _data[MAX_SIZE], _size = 0;bool empty() { return _size != 0;}void push(int x) { if (_size &lt; MAX_SIZE-1) { _data[_size++] = x; }}void pop() { if (_size) { _data[--_size] = 0; }}int size() { return _size;}int front() { return _size ? _data[0] : 0;}int back() { return _size ? _data[_size-1] : 0;}int main(){ push(100); printf(\"%d\\n\", back()); push(20); printf(\"%d\\n\", back());} 数组转指针： _data\\[([^M].*)\\]替换*(_data + \\1) 纯C用法（结构体）栈12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;stdio.h&gt;struct Stack { int _data[1000]; int _size; Stack() { // 初始化 _size = 0; } Stack(Stack&amp; q) { // 拷贝（引用） _size = q.size(); for (int i = 0; i &lt; _size; i++) _data[i] = q.at(i); } bool empty() { // 是否为空 return !_size; } int size() { // 尺寸 return _size; } int at(int x) { // 数据 return (x&gt;=0 &amp;&amp; x &lt; _size) ? _data[x] : 0; } void push(int x) { // 放入一个 if (_size &lt; 1000) _data[_size++] = x; } void pop() { // 取出一个 if (_size) { for (int i = 0; i &lt; _size-1; i++) _data[i] = _data[i+1]; --_size; } } int front() { // 获取最新进入的 return _size?_data[0] : 0; } int back() { // 获取最后进入的 return _size?_data[_size-1] : 0; } void clear() { _size = 0; }};int main(){ Stack s; s.push(100); printf(\"%d\\n\", s.back()); s.push(20); printf(\"%d\\n\", s.back()); Stack s2(s); printf(\"%d\\n\", s.back()); s2.clear();} C++ 用法头文件12#include &lt;queue&gt;#include &lt;stack&gt; 定义方式12queue&lt;int&gt; q;statck&lt;int&gt; q; 常用操作栈12345s.empty() //如果栈为空返回true，否则返回false s.size() //返回栈中元素的个数 s.pop() //删除栈顶元素但不返回其值 s.top() //返回栈顶的元素，但不删除该元素 s.push(x) //在栈顶压入新元素 ，参数X为要压入的元素 队列123456q.empty() // 如果队列为空返回true，否则返回false q.size() // 返回队列中元素的个数 q.pop() //删除队列首元素但不返回其值 q.front() // 返回队首元素的值，但不删除该元素 q.push(x) //在队尾压入新元素 ，X为要压入的元素q.back() //返回队列尾元素的值，但不删除该元素 智能指针迭代器 iterator 123stack&lt;int&gt;::iterator i;for (i = s.begin(); i != s.end(); ++i) cout &lt;&lt; *i &lt;&lt; endl; 例子12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;vector&gt;using namespace std;int main(){ queue&lt;int&gt; q; stack&lt;char&gt; s; char a = 'a', b = 'b'; q.push(1); cout &lt;&lt; \"push 1\" &lt;&lt; endl; cout &lt;&lt; \"empty:\" &lt;&lt; q.empty() &lt;&lt; endl; cout &lt;&lt; \"push 2\" &lt;&lt; endl; q.push(2); cout &lt;&lt; \"front:\" &lt;&lt; q.front() &lt;&lt; endl; q.pop(); cout &lt;&lt; \"pop\" &lt;&lt; endl; cout &lt;&lt; \"front:\" &lt;&lt; q.front() &lt;&lt; endl; q.pop(); cout &lt;&lt; \"pop\" &lt;&lt; endl; cout &lt;&lt; \"empty:\" &lt;&lt; q.empty() &lt;&lt;endl; cout &lt;&lt; \"-----\" &lt;&lt; endl; s.push(a); cout &lt;&lt; \"push \" &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; \"size:\" &lt;&lt; s.size() &lt;&lt; endl; cout &lt;&lt; \"top:\" &lt;&lt; s.top() &lt;&lt; endl; s.push(b); cout &lt;&lt; \"push \" &lt;&lt; b &lt;&lt; endl; cout &lt;&lt; \"top:\" &lt;&lt; s.top() &lt;&lt; endl; s.pop(); cout &lt;&lt; \"pop\" &lt;&lt; endl; cout &lt;&lt; \"top:\" &lt;&lt; s.top() &lt;&lt; endl;} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"算法","slug":"算法","permalink":"http://blog.iwxyi.com/tags/算法/"},{"name":"讲解","slug":"讲解","permalink":"http://blog.iwxyi.com/tags/讲解/"}]},{"title":"正则表达式-讲解","date":"2018-12-06T12:56:00.000Z","path":"2018/12/06/正则表达式教程/","text":"介绍正则表达式(Regular Expression，简称 RegExp)是一种文本模式，包括普通字符（例如，a 到 z 之间的字母）和特殊字符（称为”元字符”）。它使用单个字符串来描述、匹配一系列匹配某个句法规则的字符串。 为什么使用正则表达式？典型的搜索和替换操作要求您提供与预期的搜索结果匹配的确切文本。虽然这种技术对于对静态文本执行简单搜索和替换任务可能已经足够了，但它缺乏灵活性，若采用这种方法搜索动态文本，即使不是不可能，至少也会变得很困难。 例1：文件匹配data(\\w)?\\.dat 匹配下列所有文件 12345data.datdata1.datdata2.datdatax.datdataN.dat 使用 * 字符代替 ? 字符扩大了找到的文件的数量。data.*\\.dat 匹配下列所有文件： 123456data.datdata1.datdata2.datdata12.datdatax.datdataXYZ.dat 例2：colou?r同时匹配 color与colour 例3：特定格式^[0-9]+abc$ ^ 为匹配输入字符串的开始位置 [0-9]+匹配多个数字， [0-9] 匹配单个数字，+ 匹配一个或者多个。 abc$匹配字母 abc 并以 abc 结尾，$ 为匹配输入字符串的结束位置。 我们在写用户注册表单时，只允许用户名包含字符、数字、下划线和连接字符(-)，并设置用户名的长度，我们就可以使用这一类正则表达式来设定。 ()() 标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用 \\( 和 \\)。 特殊字符所谓特殊字符，就是一些有特殊含义的字符。 许多元字符要求在试图匹配它们时特别对待。若要匹配这些特殊字符，必须首先使字符”转义”，即，将反斜杠字符\\ 放在它们前面。下表列出了正则表达式中的特殊字符： 特别字符 描述 $ 匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹配 ‘\\n’ 或 ‘\\r’。要匹配 $ 字符本身，请使用 \\$。 ( ) 标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用 ( 和 )。 * 匹配前面的子表达式零次或多次。要匹配 * 字符，请使用 *。 + 匹配前面的子表达式一次或多次。要匹配 + 字符，请使用 +。 . 匹配除换行符 \\n 之外的任何单字符。要匹配 . ，请使用 . 。 [ 标记一个中括号表达式的开始。要匹配 [，请使用 [。 ? 匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。要匹配 ? 字符，请使用 ?。 \\ 将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， ‘n’ 匹配字符 ‘n’。’\\n’ 匹配换行符。序列 ‘\\‘ 匹配 “\"，而 ‘(‘ 则匹配 “(“。 ^ 匹配输入字符串的开始位置，除非在方括号表达式中使用，此时它表示不接受该字符集合。要匹配 ^ 字符本身，请使用 ^。 { 标记限定符表达式的开始。要匹配 {，请使用 {。 | 指明两项之间的一个选择。要匹配 |，请使用 |。 限定符限定符用来指定正则表达式的一个给定组件必须要出现多少次才能满足匹配。有 * 或 + 或 ? 或 {n} 或 {n,} 或 {n,m} 共6种。 正则表达式的限定符有： 字符 描述 * 匹配前面的子表达式零次或多次。例如，zo* 能匹配 “z” 以及 “zoo”。* 等价于{0,}。 + 匹配前面的子表达式一次或多次。例如，’zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,}。 ? 匹配前面的子表达式零次或一次。例如，”do(es)?” 可以匹配 “do” 、 “does” 中的 “does” 、 “doxy” 中的 “do” 。? 等价于 {0,1}。 {n} n 是一个非负整数。匹配确定的 n 次。例如，’o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。 {n,} n 是一个非负整数。至少匹配n 次。例如，’o{2,}’ 不能匹配 “Bob” 中的 ‘o’，但能匹配 “foooood” 中的所有 o。’o{1,}’ 等价于 ‘o+’。’o{0,}’ 则等价于 ‘o*’。 {n,m} m 和 n 均为非负整数，其中n &lt;= m。最少匹配 n 次且最多匹配 m 次。例如，”o{1,3}” 将匹配 “fooooood” 中的前三个 o。’o{0,1}’ 等价于 ‘o?’。请注意在逗号和两个数之间不能有空格。 定位符定位符使您能够将正则表达式固定到行首或行尾。它们还使您能够创建这样的正则表达式，这些正则表达式出现在一个单词内、在一个单词的开头或者一个单词的结尾。 定位符用来描述字符串或单词的边界，^ 和 $ 分别指字符串的开始与结束，\\b 描述单词的前或后边界，\\B 表示非单词边界。 正则表达式的定位符有： 字符 描述 ^ 匹配输入字符串开始的位置。如果设置了 RegExp 对象的 Multiline 属性，^ 还会与 \\n 或 \\r 之后的位置匹配。 $ 匹配输入字符串结尾的位置。如果设置了 RegExp 对象的 Multiline 属性，$ 还会与 \\n 或 \\r 之前的位置匹配。 \\b 匹配一个单词边界，即字与空格间的位置。 \\B 非单词边界匹配。 注意：不能将限定符与定位符一起使用。 选择用圆括号将所有选择项括起来，相邻的选择项之间用|分隔。但用圆括号会有一个副作用，使相关的匹配会被缓存，此时可用?:放在第一个选项前来消除这种副作用。 其中 ?: 是非捕获元之一，还有两个非捕获元是 ?= 和 ?!，这两个还有更多的含义，前者为正向预查，在任何开始匹配圆括号内的正则表达式模式的位置来匹配搜索字符串，后者为负向预查，在任何开始不匹配该正则表达式模式的位置来匹配搜索字符串。 反向引用对一个正则表达式模式或部分模式两边添加圆括号将导致相关匹配存储到一个临时缓冲区中，所捕获的每个子匹配都按照在正则表达式模式中从左到右出现的顺序存储。缓冲区编号从 1 开始，最多可存储 99 个捕获的子表达式。每个缓冲区都可以使用 \\n 访问，其中 n 为一个标识特定缓冲区的一位或两位十进制数。 可以使用非捕获元字符 ?:、?= 或 ?! 来重写捕获，忽略对相关匹配的保存。 反向引用的最简单的、最有用的应用之一，是提供查找文本中两个相同的相邻单词的匹配项的能力。 例如：(asd)\\1能匹配asdasd 所有元字符 字符 描述 \\ 将下一个字符标记为一个特殊字符、或一个原义字符、或一个 向后引用、或一个八进制转义符。例如，’n’ 匹配字符 “n”。’\\n’ 匹配一个换行符。序列 ‘\\‘ 匹配 “\" 而 “(“ 则匹配 “(“。 ^ 匹配输入字符串的开始位置。如果设置了 RegExp 对象的 Multiline 属性，^ 也匹配 ‘\\n’ 或 ‘\\r’ 之后的位置。 $ 匹配输入字符串的结束位置。如果设置了RegExp 对象的 Multiline 属性，$ 也匹配 ‘\\n’ 或 ‘\\r’ 之前的位置。 * 匹配前面的子表达式零次或多次。例如，zo* 能匹配 “z” 以及 “zoo”。* 等价于{0,}。 + 匹配前面的子表达式一次或多次。例如，’zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,}。 ? 匹配前面的子表达式零次或一次。例如，”do(es)?” 可以匹配 “do” 或 “does” 。? 等价于 {0,1}。 {n} n 是一个非负整数。匹配确定的 n 次。例如，’o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。 {n,} n 是一个非负整数。至少匹配n 次。例如，’o{2,}’ 不能匹配 “Bob” 中的 ‘o’，但能匹配 “foooood” 中的所有 o。’o{1,}’ 等价于 ‘o+’。’o{0,}’ 则等价于 ‘o*’。 {n,m} m 和 n 均为非负整数，其中n &lt;= m。最少匹配 n 次且最多匹配 m 次。例如，”o{1,3}” 将匹配 “fooooood” 中的前三个 o。’o{0,1}’ 等价于 ‘o?’。请注意在逗号和两个数之间不能有空格。 ? 当该字符紧跟在任何一个其他限制符 (*, +, ?, {n}, {n,}, {n,m}) 后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串 “oooo”，’o+?’ 将匹配单个 “o”，而 ‘o+’ 将匹配所有 ‘o’。 . 匹配除换行符（\\n、\\r）之外的任何单个字符。要匹配包括 ‘\\n’ 在内的任何字符，请使用像”(.|\\n)“的模式。 (pattern) 匹配 pattern 并获取这一匹配。所获取的匹配可以从产生的 Matches 集合得到，在VBScript 中使用 SubMatches 集合，在JScript 中则使用 $0…$9 属性。要匹配圆括号字符，请使用 ‘(‘ 或 ‘)‘。 (?:pattern) 匹配 pattern 但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用 “或” 字符 (|) 来组合一个模式的各个部分是很有用。例如， ‘industr(?:y|ies) 就是一个比 ‘industry|industries’ 更简略的表达式。 (?=pattern) 正向肯定预查（look ahead positive assert），在任何匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，”Windows(?=95|98|NT|2000)”能匹配”Windows2000”中的”Windows”，但不能匹配”Windows3.1”中的”Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。 (?!pattern) 正向否定预查(negative assert)，在任何不匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如”Windows(?!95|98|NT|2000)”能匹配”Windows3.1”中的”Windows”，但不能匹配”Windows2000”中的”Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。 (?&lt;=pattern) 反向(look behind)肯定预查，与正向肯定预查类似，只是方向相反。例如，”`(?&lt;=95 (?&lt;!pattern) 反向否定预查，与正向否定预查类似，只是方向相反。例如”`(?&lt;!95 x|y 匹配 x 或 y。例如，’z|food’ 能匹配 “z” 或 “food”。’(z|f)ood’ 则匹配 “zood” 或 “food”。 [xyz] 字符集合。匹配所包含的任意一个字符。例如， ‘[abc]’ 可以匹配 “plain” 中的 ‘a’。 [^xyz] 负值字符集合。匹配未包含的任意字符。例如， '[^abc]' 可以匹配 “plain” 中的’p’、’l’、’i’、’n’。 [a-z] 字符范围。匹配指定范围内的任意字符。例如，’[a-z]’ 可以匹配 ‘a’ 到 ‘z’ 范围内的任意小写字母字符。 [^a-z] 负值字符范围。匹配任何不在指定范围内的任意字符。例如，’[^a-z]’ 可以匹配任何不在 ‘a’ 到 ‘z’ 范围内的任意字符。 \\b 匹配一个单词边界，也就是指单词和空格间的位置。例如， ‘er\\b’ 可以匹配”never” 中的 ‘er’，但不能匹配 “verb” 中的 ‘er’。 \\B 匹配非单词边界。’er\\B’ 能匹配 “verb” 中的 ‘er’，但不能匹配 “never” 中的 ‘er’。 \\cx 匹配由 x 指明的控制字符。例如， \\cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 ‘c’ 字符。 \\d 匹配一个数字字符。等价于 [0-9]。 \\D 匹配一个非数字字符。等价于 [^0-9]。 \\f 匹配一个换页符。等价于 \\x0c 和 \\cL。 \\n 匹配一个换行符。等价于 \\x0a 和 \\cJ。 \\r 匹配一个回车符。等价于 \\x0d 和 \\cM。 \\s 匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \\f\\n\\r\\t\\v]。 \\S 匹配任何非空白字符。等价于 [^ \\f\\n\\r\\t\\v]。 \\t 匹配一个制表符。等价于 \\x09 和 \\cI。 \\v 匹配一个垂直制表符。等价于 \\x0b 和 \\cK。 \\w 匹配字母、数字、下划线。等价于’[A-Za-z0-9_]’。 \\W 匹配非字母、数字、下划线。等价于 ‘[^A-Za-z0-9_]’。 \\xn 匹配 n，其中 n 为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，’\\x41’ 匹配 “A”。’\\x041’ 则等价于 ‘\\x04’ &amp; “1”。正则表达式中可以使用 ASCII 编码。 \\num 匹配 num，其中 num 是一个正整数。对所获取的匹配的引用。例如，’(.)\\1’ 匹配两个连续的相同字符。 \\n 标识一个八进制转义值或一个向后引用。如果 \\n 之前至少 n 个获取的子表达式，则 n 为向后引用。否则，如果 n 为八进制数字 (0-7)，则 n 为一个八进制转义值。 \\nm 标识一个八进制转义值或一个向后引用。如果 \\nm 之前至少有 nm 个获得子表达式，则 nm 为向后引用。如果 \\nm 之前至少有 n 个获取，则 n 为一个后跟文字 m 的向后引用。如果前面的条件都不满足，若 n 和 m 均为八进制数字 (0-7)，则 \\nm 将匹配八进制转义值 nm。 \\nml 如果 n 为八进制数字 (0-3)，且 m 和 l 均为八进制数字 (0-7)，则匹配八进制转义值 nml。 \\un 匹配 n，其中 n 是一个用四个十六进制数字表示的 Unicode 字符。例如， \\u00A9 匹配版权符号 (?)。 等价字符?, *, +, \\d, \\w 都是等价字符?等价于匹配长度{0,1}*等价于匹配长度{0,}+等价于匹配长度{1,}\\d等价于[0-9]\\w等价于[A-Za-z_0-9] 常用运算符与表达式^ 开始() 域段[] 包含,默认是一个字符长度[^] 不包含,默认是一个字符长度{n,m} 匹配长度. 任何单个字符(. 字符点)| 或\\ 转义$ 结尾[A-Z] 26个大写字母[a-z] 26个小写字母[0-9] 0至9数字[A-Za-z0-9] 26个大写字母、26个小写字母和0至9数字 贪婪模式*、+限定符都是贪婪的，因为它们会尽可能多的匹配文字，只有在它们的后面加上一个?就可以实现非贪婪或最小匹配。 字符簇略吧，目前作用不大 实例应用 验证用户名和密码：（”^[a-zA-Z]\\w{5,15}$“）正确格式：”[A-Z][a-z]_[0-9]“组成,并且第一个字必须为字母6~16位； 验证电话号码：（”^(\\\\d{3,4}-)\\\\d{7,8}$“）正确格式：xxx/xxxx-xxxxxxx/xxxxxxxx； 验证手机号码：”^1[3|4|5|7|8][0-9]\\\\d{8}$“； 验证身份证号（15位或18位数字）：”\\\\d{14}[[0-9],0-9xX]“； 验证Email地址：(“^\\\\w+([-+.]\\\\w+)*@\\\\w+([-.]\\\\w+)*\\.\\\\w+([-.]\\\\w+)*$“)； 只能输入由数字和26个英文字母组成的字符串：(“^[A-Za-z0-9]+$“) ; 整数或者小数：^[0-9]+([.]{0,1}[0-9]+){0,1}$ 只能输入数字：”^[0-9]*$“。 只能输入n位的数字：”^\\\\d{n}$“。 只能输入至少n位的数字：”^\\\\d{n,}$“。 只能输入m~n位的数字：”^\\\\d{m,n}$“。 只能输入零和非零开头的数字：”^(0|[1-9][0-9]*)$“。 只能输入有两位小数的正实数：”^[0-9]+(.[0-9]{2})?$“。 只能输入有1~3位小数的正实数：”^[0-9]+(\\.[0-9]{1,3})?$“。 只能输入非零的正整数：\"^\\+?[1-9][0-9]*$\"。 只能输入非零的负整数：\"^\\-[1-9][0-9]*$\"。 只能输入长度为3的字符：”^.{3}$“。 只能输入由26个英文字母组成的字符串：”^[A-Za-z]+$“。 只能输入由26个大写英文字母组成的字符串：”^[A-Z]+$“。 只能输入由26个小写英文字母组成的字符串：”^[a-z]+$“。 验证是否含有^%&amp;',;=?$\\\"等字符：\"[^%&amp;',;=?$\\x22]+\"。 只能输入汉字：”^[\\u4e00-\\u9fa5]{0,}$“。 验证URL：”^http://([\\\\w-]+\\.)+[\\\\w-]+(/[\\\\w-./?%&amp;=]*)?$“。 验证一年的12个月：”^(0?[1-9]|1[0-2])$“正确格式为：”01”～”09”和”10”～”12”。 验证一个月的31天：”^((0?[1-9])|((1|2)[0-9])|30|31)$“正确格式为；”01”～”09”、”10”～”29”和“30”~“31”。 获取日期正则表达式：\\d{4}[年|\\-|\\.]\\d{1-12}[月|\\-|\\.]\\d{1-31}日? 评注：可用来匹配大多数年月日信息。 匹配双字节字符(包括汉字在内)：[^\\x00-\\xff] 评注：可以用来计算字符串的长度（一个双字节字符长度计2，ASCII字符计1） 匹配空白行的正则表达式：\\n\\s*\\r 评注：可以用来删除空白行 匹配HTML标记的正则表达式：&lt;(\\S*?)[^&gt;]*&gt;.*?&lt;/&gt;|&lt;.*? /&gt; 评注：网上流传的版本太糟糕，上面这个也仅仅能匹配部分，对于复杂的嵌套标记依旧无能为力 匹配首尾空白字符的正则表达式：^\\s*|\\s*$ 评注：可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式 匹配网址URL的正则表达式：[a-zA-z]+://[^\\s]* 评注：网上流传的版本功能很有限，上面这个基本可以满足需求 匹配帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$ 评注：表单验证时很实用 匹配腾讯QQ号：[1-9][0-9]\\{4,\\} 评注：腾讯QQ号从10 000 开始 匹配中国邮政编码：[1-9]\\\\d{5}(?!\\d) 评注：中国邮政编码为6位数字 匹配ip地址：((2[0-4]\\\\d|25[0-5]|[01]?\\\\d\\\\d?)\\.){3}(2[0-4]\\\\d|25[0-5]|[01]?\\\\d\\\\d?)。 C++示例1234567891011121314151617181920212223242526#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;regex.h&gt; int main(int argc,char** argv){ int status ,i; int cflags = REG_EXTENDED; regmatch_t pmatch[1]; const size_t nmatch = 1; regex_t reg; const char * pattern = \"^\\\\w+([-+.]\\\\w+)*@\\\\w+([-.]\\\\w+)*.\\\\w+([-.]\\\\w+)*$\"; char * buf = \"chenjiayi@126.com\"; regcomp(&amp;reg,pattern,cflags);//编译正则模式 status = regexec(&amp;reg,buf,nmatch,0);//执行正则表达式和缓存的比较 if(status == REG_NOMATCH) printf(\"No match\\n\"); else if (0 == status) { printf(\"比较成功:\"); for(i = pmatch[0].rm_so;i&lt;pmatch[0].rm_eo;++i)putchar(buf[i]); printf(\"\\n\"); } regfree(&amp;reg); return 0;} 博客来源：https://blog.csdn.net/chenjiayi_yun/article/details/43375201 菜鸟教程：http://www.runoob.com/regexp/regexp-tutorial.html document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"讲解","slug":"讲解","permalink":"http://blog.iwxyi.com/tags/讲解/"},{"name":"RegExp","slug":"RegExp","permalink":"http://blog.iwxyi.com/tags/RegExp/"}]},{"title":"汇编MASM-学习笔记","date":"2018-11-19T12:18:00.000Z","path":"2018/11/19/汇编MASM-学习笔记/","text":"运行 DOSBox mount c: d:\\masm C: masm test.asm 回车3次 link test.obj 回车4次 debug test.exe -r 运行 -t 继续 -t 10 运行10条指令 -d 内存 -u 源码 -p 跳过（尤其是库函数） -q 退出 常用指令 assume 声明 mov 复制内存 mov ax, [bx] inc 加一 inc ax dec 减一 jmp 跳转 jmp loop1 cmp 比较大小 cmp ax, bx add 增加某数 add ax, 10 其他指令 ADC 带进位加法 LEA dx, [0000] 相当于MOV字符串 ? 比较大小 cmp cx, 0 比较结果执行下面的语句 ja &gt; above jb &lt; blow jbe &lt;= jae &gt;= jz == （相减为 zero） jnz != 库函数 INT 21 MOV AH 0A 时：接收一个用户输入到 ds[dx] MOV AH 4C 时：退出程序，返回操作系统 寄存器拆开AX = AH + AL只有 AX BX CX DX 这四个可以拆开用 常用代码块声明变量12assume cs:code, ds:data1mov ax, data1 变量加一123mov al, [bx] ; 数据段寄存器DS 到 寄存器inc al ; 增加 1mov [bx], al ; 寄存器 到 DS 循环1for (i = 0; i &lt; 10; i++); 123456mov cx, 0loop1: inc cx cmp cx, 10 jb loop1 while 循环12345i = 10;while (i &gt;= 0) { // P1 i--;} 12345678910mov ax, 10loop1: cmp ax, 0 jb next ;P1 dec ax jmp loop1next: 接收用户输入12345MOV AX, 076AMOV DS, AXMOV DX, 0000MOV AH, 0AINT 21 清屏12345678910111213141516171819 mov ax,cs mov ss,ax mov sp,0x7c00 ;set stack and sp mov ah,0x06 mov al,0 ; 准备清窗口 mov ch,0 ; 左上角的行号 mov cl,0 ; 左上角的列号 mov dh,25 ; 右下角的行号 mov dl,80 ; 右下角的行号 mov bh,0x07; 属性为蓝底白字 int 0x10 ; 执行清空操作@1: jmp @1 times 510-($-$$) db 0 db 0x55,0xaa 画白线123456789101112131415161718 mov al, 0x13 ; VGA320×200×8bit 显示模式 mov ah, 0x00 int 0x10 mov ax, 0x0a000 ; 往显存中放入点数据 mov ds, ax mov dl, 30 mov ax, 0 f: mov bx, ax mov [ds:bx], dl inc ax cmp ax, 50 ja io jmp f io: 画线函数123456789101112131415161718192021org 0x7c00 mov ax, 80 ; y mov bx, 50 ; x1 mov cx, 150 ; x2 call drawline ; 运行画线 ; y:ax, x1:bx, x2:cxdrawline: mov dx, 320 ; 屏幕宽是320 mul dx ; dx *= ax 16位中AX为被乘数，8位中AL为被乘数 sub cx, bx ; cx = x2-x1 线的宽度 add bx, ax ; 横偏移量+横纵偏移量 = 偏移位置 mov dl, 1 ; 色号loop0: mov [ds:bx], dl ; 填充颜色 inc bx ; 偏移位置+1 dec cx ; 循环次数-1 jnz loop0 ; 受到上面的DEC的ZF标志位RET 画竖线123456789101112131415;****************************************; y1-&gt;ax, y2-&gt;cx, x-&gt;bx;****************************************DrawVerticalLine: mov dx, 320 ; w = 320 mov bp, dx sub cx, ax ; y1 = y2-y1 循环次数 mul dx ; ax = w * y1 纵偏移量 add bx, ax ; 横纵偏移量 mov dl, 1x1: mov [ds:bx], dl add bx, bp dec cx jnz x1ret 设置颜色12345678910111213mov al, 1 ; 颜色号mov dx, 0x3c8out dx, almov al, 100 ; R / 4 = 25mov dx, 0x3c9out dx, almov al, 0 ; Gout dx, almov al, 0 ; Bout dx, al 数组123456789;rgb db 100, 0, 0, 0, 100, 0, 0, 0, 100rgb db 100, 0, 0, db 0, 100, 0, db 0, 0, 100mov ax, 0mov ds, axmov si, rgbmov [ds:si], ... ; 偏移地址，si为下标 进栈出栈保存变量123push axmov ax, 0pop ax 定时器每隔18分之一秒运行一次，多个任务的话会被覆盖掉 1mov word [ds:0x20],int_timer0 打印字符函数：在 ex:bx 的位置显示一个 ‘A’ 12345678910int_timer0: mov byte [es:bx],'A' mov byte [es:bx+1],0x0a inc bx ; 自增两次到下次打印的字符 inc bx mov al,0x20 mov dx,0x20 out dx,al ;EOI=0 中断 iret 获取按键输入123456789101112int_key: mov dx, 0x20 ; 下一个键值可以进来了（没有这一段就只能输入一次按键了） mov al, 0x61 out dx, al mov dx, 0x60 ; 读取一次按键 in al, dx cmp al, 0x9e jz func0func0: 显示一个数字12 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://blog.iwxyi.com/tags/学习笔记/"},{"name":"汇编","slug":"汇编","permalink":"http://blog.iwxyi.com/tags/汇编/"}]},{"title":"贪心算法-讲解","date":"2018-11-04T12:46:00.000Z","path":"2018/11/04/贪心算法/","text":"ACM 贪心算法贪心算法（又称贪婪算法）是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的是在某种意义上的局部最优解。 例题钱币找零问题假设1元、2元、5元、10元、20元、50元、100元的纸币分别有c0, c1, c2, c3, c4, c5, c6张。现在要用这些钱来支付K元，至少要用多少张纸币？ 代码12345678910111213141516171819202122232425#include &lt;stdio.h&gt;#include &lt;math.h&gt;#include &lt;algorithm&gt;using namespace std;const int N=7;int Count[N]={3,0,2,1,0,3,5};int Value[N]={1,2,5,10,20,50,100};int main(){ int money; scanf(\"%d\", &amp;money); int num = 0; for(int i=N-1;i&gt;=0;i--) { int c=min(money/Value[i],Count[i]); money=money-c*Value[i]; num+=c; } if(num!=-1) printf(\"%d\\n\", num); else printf(\"NO\\n\");} 可分割背包问题有一个背包，背包容量是M，有N个物品，要求尽可能让装入背包中的物品总价值最大，但不能超过总容量，物品可以只取一部分。 输入第一行输入一个正整数n（1&lt;=n&lt;=5）,表示有n组测试数据；随后有n测试数据，每组测试数据的第一行有两个正整数s，m（1&lt;=s&lt;=10）;s表示有s个物品。接下来的s行每行有两个正整数v，w，分别表示物品的单位价值和总质量。输出输出每组测试数据中背包内的物品的价值和，每次输出占一行。样例输入 1234513 155 102 83 9 样例输出 165 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;stdio.h&gt;#include &lt;algorithm&gt;using namespace std;#define MAXN 10000int main(int argc, char const *argv[]){ int T; scanf(\"%d\", &amp;T); while (T--) { int n, m; int v[MAXN], w[MAXN]; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 0; i &lt; n; i++) scanf(\"%d%d\", &amp;v[i], &amp;w[i]); for (int i = 0; i &lt; n - 1; i++) for (int j = 0; j &lt; n - i - 1; j++) if (v[j] &lt; v[j + 1]) { int temp = v[j]; v[j] = v[j + 1]; v[j + 1] = temp; temp = w[j]; w[j] = w[j + 1]; w[j + 1] = temp; } int ans = 0; for (int i = 0; i &lt; n; i++) { if (w[i] &gt;= m) { ans += m * v[i]; m = 0; break; } else { ans += w[i] * v[i]; m -= w[i]; } } printf(\"%d\\n\", ans); } return 0;} 排序冒泡排序12345678for (int i = 0; i &lt; len - 1; i++) for (int j = 0; j &lt; len - 1 - i; j++) if (arr[j] &gt; arr[j + 1]) { temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; } 选择排序12345678910for(i = 0; i &lt; n-1; i++){ min = i;//查找最小值 for(j = i+1; j&lt;n; j++) if(A[min] &gt; A[j]) min = j; if(min != i) swap(&amp;A[min], &amp;A[i]);} 其他排序已经帮你们百度好的链接 建议用C++的 algorithm 头文件中的 sort 函数，也是ACM中最常用的排序算法。 缺点贪心算法不是对所有问题都能得到整体最优解，关键是贪心策略的选择，选择的贪心策略必须具备无后效性，即某个状态以前的过程不会影响以后的状态，只与当前状态有关。 ⑴贪心策略：总价值最大反例： W=30物品：A B C重量：28 12 12价值：30 20 20 根据策略，首先选取物品A，接下来就无法再选取了，可是，选取B、C则更好。 ⑵贪心策略：重量最小它的反例与第一种策略的反例差不多。 ⑶贪心策略：单位量价值最大反例： W=30物品：A B C重量：28 20 10价值：28 20 10 根据策略，三种物品单位重量价值一样，程序无法依据现有策略作出判断，如果选择A，则答案错误。 【注意：如果物品可以分割为任意大小，那么策略3可得最优解】 (4)DP问题（动态规划）W=40物品：A B C重量：25 20 15价值：25 20 15 这需要DP。 题目今年暑假不AC（节目表）“今年暑假不AC？”“是的。”“那你干什么呢？”“看世界杯呀，笨蛋！”“@#$%^&amp;*%…” 确实如此，世界杯来了，球迷的节日也来了，估计很多ACMer也会抛开电脑，奔向电视了。作为球迷，一定想看尽量多的完整的比赛，当然，作为新时代的好青年，你一定还会看一些其它的节目，比如新闻联播（永远不要忘记关心国家大事）、非常6+7、超级女生，以及王小丫的《开心辞典》等等，假设你已经知道了所有你喜欢看的电视节目的转播时间表，你会合理安排吗？（目标是能看尽量多的完整节目） Input 输入数据包含多个测试实例，每个测试实例的第一行只有一个整数n(n&lt;=100)，表示你喜欢看的节目的总数，然后是n行数据，每行包括两个数据Ti_s,Ti_e (1&lt;=i&lt;=n)，分别表示第i个节目的开始和结束时间，为了简化问题，每个时间都用一个正整数表示。n=0表示输入结束，不做处理。 Output 对于每个测试实例，输出能完整看到的电视节目的个数，每个测试实例的输出占一行。 Sample Input 123456789101112131412 1 3 3 4 0 7 3 8 15 19 15 20 10 15 8 18 6 12 5 10 4 14 2 9 0 Sample Output 15 代码（HDU 2037）123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;stdio.h&gt;int main(int argc, const char *argv[]){ int i, n, j, tmp; while (scanf(\"%d\", &amp;n) != EOF &amp;&amp; n != 0) { int count = 1, a[100] = {0}, b[100] = {0}; for (i = 0; i &lt; n; i++) scanf(\"%d %d\", &amp;a[i], &amp;b[i]); for (i = 0; i &lt; (n - 1); i++) { for (j = 0; j &lt; (n - 1 - i); j++) { if (b[j] &gt; b[j + 1]) { tmp = a[j]; a[j] = a[j + 1]; a[j + 1] = tmp; tmp = b[j]; b[j] = b[j + 1]; b[j + 1] = tmp; } } } int time = 0; for (i = 1; i &lt; n; i++) { if (a[i] &gt;= b [time]) { time = i; count++; } } printf(\"%d\\n\", count); } return 0;} 阶乘之和描述给你一个非负数整数n，判断n是不是一些数（这些数不允许重复使用，且为正数）的阶乘之和，如9=1！+2!+3!，如果是，则输出Yes，否则输出No； 输入第一行有一个整数0&lt;m&lt;100,表示有m组测试数据；每组测试数据有一个正整数n&lt;1000000;输出如果符合条件，输出Yes，否则输出No;样例输入 122910 样例输出 12YesNo 喷水装置（一）描述现有一块草坪，长为20米，宽为2米，要在横中心线上放置半径为Ri的喷水装置，每个喷水装置的效果都会让以它为中心的半径为实数Ri(0&lt;Ri&lt;15)的圆被湿润，这有充足的喷水装置i（1&lt;i&lt;600)个，并且一定能把草坪全部湿润，你要做的是：选择尽量少的喷水装置，把整个草坪的全部湿润。 输入第一行m表示有m组测试数据每一组测试数据的第一行有一个整数数n，n表示共有n个喷水装置，随后的一行，有n个实数ri，ri表示该喷水装置能覆盖的圆的半径。 输出输出所用装置的个数 样例输入 12345252 3.2 4 4.5 6 101 2 3 1 2 1.2 3 1.1 1 2 样例输出 1225 &gt; 喷水装置（二）改成二维，输入装置个数n、草坪宽 w、高 h（实数），以及每个喷水装置的横坐标和半径。其余题意同上一题。 过河问题描述在漆黑的夜里，N位旅行者来到了一座狭窄而且没有护栏的桥边。如果不借助手电筒的话，大家是无论如何也不敢过桥去的。不幸的是，N个人一共只带了一只手电筒，而桥窄得只够让两个人同时过。如果各自单独过桥的话，N人所需要的时间已知；而如果两人同时过桥，所需要的时间就是走得比较慢的那个人单独行动时所需的时间。问题是，如何设计一个方案，让这N人尽快过桥。 输入第一行是一个整数T(1&lt;=T&lt;=20)表示测试数据的组数每组测试数据的第一行是一个整数N(1&lt;=N&lt;=1000)表示共有N个人要过河每组测试数据的第二行是N个整数Si,表示此人过河所需要花时间。(0&lt;Si&lt;=100)输出输出所有人都过河需要用的最少时间样例输入 123141 2 5 10 样例输出 117 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"算法","slug":"算法","permalink":"http://blog.iwxyi.com/tags/算法/"},{"name":"讲解","slug":"讲解","permalink":"http://blog.iwxyi.com/tags/讲解/"}]},{"title":"Bat常用脚本命令","date":"2018-09-01T12:40:00.000Z","path":"2018/09/01/Bat常用脚本命令/","text":"run.bat—打开百度 12path=%path%; C:\\Program Files (x86)\\Internet Explorer\\start iexplore http://www.baidu.com 将c盘下所有文件名输出到a.txt中，如果没有a文件，则在bat同一目录下创建一个 1dir c:\\*.* &gt;a.txt 执行另一个批处理文件 1call c:\\code\\run.bat echo回显 1234@echo off 表示在此语句后所有运行的命令都不显示命令行本身 cd code 进入code文件夹echo enter code directory 显示enter code directorycall run.bat 增加入参 123@echo off type %1 type %2 cmd为 run.bat a.txt b.txt控制台会显示出a和b的文件内容 for循环的使用 123bat脚本@echo offfor %%t in (*.bat *.txt) do type %%t 注意1，打印的是bat和txt文件的内容注意2，此bat放在需打印文件内容的文件一个目录层级下 12@echo offFOR /L %%i in (1,2,20) DO echo %%i if/else判断语句的使用 1234567bat脚本@echo offif {%1}=={%2} (echo eq l.) else (echo not eq l.) cmd输入run.bat 1 2结果为 not eq 1 在一个批处理文件内最多可以使用10个替换参数(%0到%9) 1234567@echo offif exist a.txt ( echo This is a.txt type a.txt)else ( echo a.txt missing.) 判断当前目录下是否有a.txt 12345@ECHO OFFIF EXIST D:\\*.XLS () else (GOTO fail)PAUSE :failECHO 没找到文件 删除文件 12@echo offdel a.txt 12&gt; 注意：指定路径会删除该路径下所有文件&gt; 移动、拷贝文件、文件夹 123456@echo offmove c:\\a.txt c:\\code\\a.txt copy c:\\code\\a.txt c:\\a.txt rd c:\\code\\abc\\abc REM 删除非空文件夹 GOTO语句 123456@ECHO OFFGOTO SECOND:FIRSTecho I AM FIRST:SECONDecho I AM SECOND choice/errorlevel的用法 12345678910111213141516@echo off choice /C 123 /M \"RUN1,RUN2,RUN3\"if errorlevel 3 goto RUN3if errorlevel 2 goto RUN2 if errorlevel 1 goto RUN1 :RUN1 c:\\code\\RUN1 goto RUN3 :RUN2c:\\code\\RUN2goto RUN3 :RUN3echo good bye set 123456789@echo offset a=aa1bb1aa2bb2echo %a%set b=12echo %b%set /a c=39/10 echo %c% 1234567@echo offset p=aaaif %p%==aaa ( echo %p% set p=bbb echo %p% ) 输出 aaa aaa 1234567@echo offset p=aaaif %p%==aaa ( echo %p% set /p p=bbb echo %p% ) 输出 aaa bbb 123echo %CD% #代表当前目录的字符串echo %DATE% #当前日期echo %TIME% #当前时间 从FTP下载文件 12345678910111213@echo open 10.86.56.6 &gt;ftp.txt rem ftp server ip@echo user mos&gt;&gt;ftp.txt rem 用户名@echo mos&gt;&gt;ftp.txt rem 密码@echo cd test&gt;&gt;ftp.txt rem 文件路径@echo get mw-license-switch-conffile.xml&gt;&gt;ftp.txt rem 文件名@echo bye&gt;&gt;ftp.txtftp -i -n -s:ftp.txt rem 文件存放在脚本所在路径下 切换盘符 123set current_dir=C:\\Program Files\\HaoZip pushd %current_dir% echo %cd% 博客来源：https://www.cnblogs.com/laislabonita/p/7145731.html document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Bat","slug":"Bat","permalink":"http://blog.iwxyi.com/tags/Bat/"}]},{"title":"IIS允许下载APK安装包","date":"2018-08-10T12:41:00.000Z","path":"2018/08/10/IIS允许下载APK安装包/","text":"IIS允许下载APK安装包（MIME类型配置）IIS7MIME配置过程： 打开IIS信息服务管理器，找到要添加配置的网站； 在该网站的功能视图中单击”MIME类型“按钮（如果在功能视图中没有MIME按钮，则需要通过服务器管理器中角色管理进行添加），打开MIME类型设置窗口； 在操作栏里点击”添加“按钮； 单机”确定“保存设置； 重启IIS，使设置生效。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"服务器","slug":"服务器","permalink":"http://blog.iwxyi.com/tags/服务器/"}]},{"title":"fread和fwrite转移文件数据","date":"2018-08-04T12:18:00.000Z","path":"2018/08/04/fread和fwrite转移文件数据/","text":"读取文件，再写入到另一个文件里面： 1、获取文件大小 12345FILE* fp_size = fopen(\"T:/img.jpg\", \"rb\");fseek(fp_size, 0, SEEK_END);int size = ftell(fp_size);fclose(fp_size);cout &lt;&lt; \"文件大小(指针偏移计算):\" &lt;&lt; size; // 字节大小 2、读取文件 1234FILE* fp_read = fopen(\"T:/img.jpg\", \"rb\");int* buffer = (int*)malloc(size+4); // 可以改成其他类型也没事，比如 char*fread(buffer, size, 1, fp_read);fclose(fp_read); 3、写入到另一个文件 123FILE* fp_write = fopen(\"T:/img1.png\", \"wb\");fwrite(buffer,size, 1, fp_write);fclose(fp_write); fread和write的size可以更大，不影响结果（表示上限） 实测一张jpg图片： size超过体积，保存的会是size的大小 1/10时：图片只有一半显示，体积也只有1/10 1/4时：上方5/6的部分清晰，剩下的模糊 1/2时：虽然体积只有一半，但是好像一样清晰…… document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"C","slug":"C","permalink":"http://blog.iwxyi.com/tags/C/"},{"name":"文件","slug":"文件","permalink":"http://blog.iwxyi.com/tags/文件/"}]},{"title":"SQL查询及删除重复记录","date":"2018-06-15T10:38:00.000Z","path":"2018/06/15/SQL查询及删除重复记录/","text":"1、查找表中多余的重复记录，重复记录是根据单个字段（peopleId）来判断 12select * from peoplewhere peopleId in (select peopleId from people group by peopleId having count(peopleId) &gt; 1) 2、删除表中多余的重复记录，重复记录是根据单个字段（peopleId）来判断，只留有rowid最小的记录 123delete from peoplewhere peopleId in (select peopleId from people group by peopleId having count(peopleId) &gt; 1)and rowid not in (select min(rowid) from people group by peopleId having count(peopleId )&gt;1) 3、查找表中多余的重复记录（多个字段） 12select * from vitae awhere (a.peopleId,a.seq) in (select peopleId,seq from vitae group by peopleId,seq having count(*) &gt; 1) 4、删除表中多余的重复记录（多个字段），只留有rowid最小的记录 123delete from vitae awhere (a.peopleId,a.seq) in (select peopleId,seq from vitae group by peopleId,seq having count(*) &gt; 1)and rowid not in (select min(rowid) from vitae group by peopleId,seq having count(*)&gt;1) 5、查找表中多余的重复记录（多个字段），不包含rowid最小的记录 123select * from vitae awhere (a.peopleId,a.seq) in (select peopleId,seq from vitae group by peopleId,seq having count(*) &gt; 1)and rowid not in (select min(rowid) from vitae group by peopleId,seq having count(*)&gt;1) document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"SQL","slug":"SQL","permalink":"http://blog.iwxyi.com/tags/SQL/"}]},{"title":"嵌套循环优化","date":"2018-05-20T11:50:00.000Z","path":"2018/05/20/嵌套循环优化/","text":"题目请对以下的代码进行优化： 1234for (int i = 0; i &lt; 1000; i++) for (int j = 0; j &lt; 100; j++) for (int k = 0; k &lt; 10; k++) testFunction (i, j, k); 分析从给出的代码可知，不论如何优化，testFunction执行的次数都是相同的，该部分不存在优化的可能。那么，代码的优化只能从循环变量i、j、k的实例化、初始化、比较、自增等方面的耗时上进行分析。 首先，我们先分析原题代码循环变量在实例化、初始化、比较、自增等方面的耗时情况： 变量 实例化(次数) 初始化(次数) 比较(次数) 自增(次数) i 1 1 1000 1000 j 1000 1000 1000 * 100 1000 * 100 k 1000 * 100 1000 * 100 1000 * 100 * 10 1000 * 100 * 10 该代码的性能优化就是尽可能减少循环变量i、j、k的实例化、初始化、比较、自增的次数，同时，不能引进其它可能的运算耗时。 方案1234for (int i = 0; i &lt; 10; i++) for (int j = 0; j &lt; 100; j++) for (int k = 0; k &lt; 1000; k++) testFunction (k, j, i); 该方案主要是将循环次数最少的放到外面，循环次数最多的放里面，这样可以最大程度的（注：3个不同次数的循环变量共有6种排列组合情况，此种组合为最优）减少相关循环变量的实例化次数、初始化次数、比较次数、自增次数，方案耗时情况如下： 变量 实例化(次数) 初始化(次数) 比较(次数) 自增(次数) i 1 1 10 10 j 10 10 10 * 100 10 * 100 k 10 * 100 10 * 100 10 * 100 * 1000 10 * 100 * 1000 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"C","slug":"C","permalink":"http://blog.iwxyi.com/tags/C/"},{"name":"优化","slug":"优化","permalink":"http://blog.iwxyi.com/tags/优化/"}]},{"title":"Windows卡顿优化","date":"2018-03-04T11:52:00.000Z","path":"2018/03/04/Windows卡顿优化/","text":"Windows 卡顿优化关闭家庭组因为这功能会导致硬盘和CPU处于高负荷状态 关闭方案：控制面板–管理工具–服务– HomeGroup Listener 和 HomeGroup Provider 禁用。 关闭性能特效（配置较低的机器可以关闭）系统属性-高级-性能-设置-关闭淡出淡入效果。 关闭磁盘碎片整理计划磁盘碎片整理可以提高磁盘性能，但不需要整理计划，可以关闭整理计划。选中磁盘C-属性–工具–对驱动器进行优化和碎片整理–优化–更改设置–取消选择按计划执行。关闭IPv6协议 Win10默认开启的IPv6协议，对于日常使用的我们来讲，使用率几乎为0，而它却大大的占用着系统资源。打开控制面板，进入网络和 Internet，找到网络和共享中心窗口，从左侧的栏目中点击更改适配器设置进入网络连接。打开以太网属性窗口。在列表中找到Internet协议版本6(TCP/IPv6)，点击取消勾选，确定=】即可。 卸载预装应用（强力）使用Cortana搜索，输入PowerShell，右键PowerShell，以管理员身份运行。在PowerShell中输入：Get-AppXPackage | Remove-AppxPackage遇到错误时请无视，继续执行该命令最终结果是，所有预装软件中只剩Edge浏览器，连APP商店都没了使用win更新系统后，预装软件均可找回 关闭服务win+r输入services.msc 以下是可以更改为手动启动的服务（按名称排序）： 1、Application Experience（启动时为程序处理应用程序兼容性缓存请求） 2、Computer Browser（维护网络上计算机的更新列表，不需要联网的话可以改为手动） 3、Diagnostic Policy Service（诊断策略服务）Diagnositic 开头的都禁用 4、Distributed Link Tracking Client（维护计算机内的NTFS文件之间的链接） 5、IP Helper（使用IPv6转换技术） 6、Offline Files（脱机文件服务） 7、Program Compatibility Assistant Service（为应用程序兼容性助手提供支持） 8、Portable Device Enumerator Service（强制可移动大容量存储设备的组策略） 9、Print Spooler（没有打印机的话可以关闭它） 10、Remote Registry（远程注册表设置，这项服务应该保持禁用状态） 11、Secondary Logon（在不同凭据下启用启动过程，改为手动即可，禁用会导致魔兽世界等游戏无法登录） 12、Security Center（监视并报告计算机上的安全健康设置） 13、Server （支持计算机通过网络进行共享，若处于单机状态的话，可以改为手动） 14、TCP/IP NetBIOS Helper （提供NetBIOS名称解析支持，若你的计算机没有连接到工作组网络的话，可以改为手动） 15、Windows Error Reporting Service （报告错误并提供现有解决方案） 16、Windows Image Acquisition （WIA） （为扫描仪和照相机提供图像采集服务） 17、Windows Search （提供内容索引，如果你不怎么使用Windows自带搜索的话，可以改手动） 18、Windows Time （维护时间和日期同步） 19、Windows Update 系统更新（禁用） 20、Superfetch 超级与读取（禁用） document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Windows","slug":"Windows","permalink":"http://blog.iwxyi.com/tags/Windows/"}]},{"title":"Emment语法","date":"2018-03-03T11:57:00.000Z","path":"2018/03/03/Emment语法/","text":"Emment语法1.1 生成html初始文档123!+tab或者html:5 生成html5文档的初始结构html:xt 生成html4过渡型html:4s 生成html4严格型） 生成的文档如下： 12345678910&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 1.2 生成带有id,class的HTML标签1. 1#aaa 生成一个ID为aaa的div 生成结构如下： 1&lt;div id=\"aaa\"&gt;&lt;/div&gt; 2. 1ul#ccc.ddd 生成一个ID为ccc,class为ddd的ul 生成结构如下： 1&lt;ul id=\"ccc\" class=\"ddd\"&gt;&lt;/ul&gt; 1.3 生成后代 “&gt;”1div.aaa&gt;ul&gt;li 生成一个无序列表，而且被class为aaa的div包裹 生成结构如下： 12345&lt;div class=\"aaa\"&gt; &lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 1.4 生成兄弟1div+p+dp 123&lt;div&gt;&lt;/div&gt;&lt;p&gt;&lt;/p&gt;&lt;dp&gt;&lt;/dp&gt; 1.5 生成上级元素 “^”上级 （Climb-up）元素是什么意思呢？前面咱们说过了生成下级元素的符号“&gt;”，当使用 div&gt;ul&gt;li 的指令之后，再继续写下去，那么后续内容都是在 li 下级的。如果我想编写一个跟 ul 平级的 span 标签，那么我需要先用 “^” 提升一下层次。例如： 1div&gt;ul&gt;li^span 123456&lt;div&gt; &lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt; &lt;span&gt;&lt;/span&gt;&lt;/div&gt; 如果我想生成一个与div平级的span，那么就再上升一个层级，多用一个^ 1div&gt;ul&gt;li^^span 123456&lt;div&gt; &lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;span&gt;&lt;/span&gt; 1.6重复生成多份*1ul&gt;li*5 1234567&lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt;&lt;/ul&gt; 1.7生成分组()1div&gt;(header&gt;ul&gt;li*2&gt;a)+footer&gt;p 12345678910&lt;div&gt;&lt;/div&gt; &lt;header&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=\"\"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"\"&gt;&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/header&gt; &lt;footer&gt; &lt;p&gt;&lt;/p&gt; &lt;/footer&gt; 分组还可以结合上面的*符号生成重复结构 1(div&gt;dl&gt;(dt&gt;dd)*3)+footer&gt;p 12345678910111213141516&lt;div&gt; &lt;dl&gt; &lt;dt&gt; &lt;dd&gt;&lt;/dd&gt; &lt;/dt&gt; &lt;dt&gt; &lt;dd&gt;&lt;/dd&gt; &lt;/dt&gt; &lt;dt&gt; &lt;dd&gt;&lt;/dd&gt; &lt;/dt&gt; &lt;/dl&gt;&lt;/div&gt;&lt;footer&gt; &lt;p&gt;&lt;/p&gt;&lt;/footer&gt; 1.8生成自定义属性[attr]a 标签中往往需要附带 href 属性和 title 属性，如果我们想生成一个 href 为 “http://google.com” ，title 为“我爱水煮鱼”的 a 标签，可以这样写： 1a[href=\"www.google.com\" title=\"我爱水煮鱼\"] 1&lt;a href=\"www.google.com\" title=\"我爱水煮鱼\"&gt;&lt;/a&gt; 1.9生成内容编号$1ul&gt;li.item$*5 1234567&lt;ul&gt; &lt;li class=\"item1\"&gt;&lt;/li&gt; &lt;li class=\"item2\"&gt;&lt;/li&gt; &lt;li class=\"item3\"&gt;&lt;/li&gt; &lt;li class=\"item4\"&gt;&lt;/li&gt; &lt;li class=\"item5\"&gt;&lt;/li&gt;&lt;/ul&gt; 1ul&gt;li.item$$$*5 1234567&lt;ul&gt; &lt;li class=\"item001\"&gt;&lt;/li&gt; &lt;li class=\"item002\"&gt;&lt;/li&gt; &lt;li class=\"item003\"&gt;&lt;/li&gt; &lt;li class=\"item004\"&gt;&lt;/li&gt; &lt;li class=\"item005\"&gt;&lt;/li&gt;&lt;/ul&gt; 只能这样单调的生成序号？对于强大的 Emmet 来说，肯定不会会了，我们也可以在 $ 后面增加 @- 来实现倒序排列： 1ul&gt;li.item$@-*5 1234567&lt;ul&gt; &lt;li class=\"item5\"&gt;&lt;/li&gt; &lt;li class=\"item4\"&gt;&lt;/li&gt; &lt;li class=\"item3\"&gt;&lt;/li&gt; &lt;li class=\"item2\"&gt;&lt;/li&gt; &lt;li class=\"item1\"&gt;&lt;/li&gt;&lt;/ul&gt; 我们也可以使用@N指定开始的序号 1ul&gt;li.item$@3*5 1234567&lt;ul&gt; &lt;li class=\"item3\"&gt;&lt;/li&gt; &lt;li class=\"item4\"&gt;&lt;/li&gt; &lt;li class=\"item5\"&gt;&lt;/li&gt; &lt;li class=\"item6\"&gt;&lt;/li&gt; &lt;li class=\"item7\"&gt;&lt;/li&gt;&lt;/ul&gt; 配合上面倒序输出，可以这样写: 1ul&gt;li.item$@-3*5 1234567&lt;ul&gt; &lt;li class=\"item7\"&gt;&lt;/li&gt; &lt;li class=\"item6\"&gt;&lt;/li&gt; &lt;li class=\"item5\"&gt;&lt;/li&gt; &lt;li class=\"item4\"&gt;&lt;/li&gt; &lt;li class=\"item3\"&gt;&lt;/li&gt;&lt;/ul&gt; 2.0生成文本内容{}1a[href=\"www.google.com\"]{click me} 或者 1a[href=\"www.google.com\"]&gt;{click me} 1&lt;a href=\"www.google.com\"&gt;click me&lt;/a&gt; 注意不能有空格 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"HTML","slug":"HTML","permalink":"http://blog.iwxyi.com/tags/HTML/"},{"name":"语法","slug":"语法","permalink":"http://blog.iwxyi.com/tags/语法/"}]},{"title":"安卓Rec模式清除锁屏密码","date":"2018-01-29T12:44:00.000Z","path":"2018/01/29/安卓Rec模式清除锁屏密码/","text":"安卓REC清除锁屏密码打开TWRP的adb shell 12345rm /data/system/locksettings.dbrm /data/system/locksettings.db-shmrm /data/system/locksettings.db-walrm /data/system/gatekeeper.password.keyrm /data/system/gatekeeper.pattern.key 实测可以用文件管理删除前两项即可（不同类型密码的文件不同） document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"搞机","slug":"搞机","permalink":"http://blog.iwxyi.com/tags/搞机/"}]},{"title":"这样学Java不枯燥-学习笔记","date":"2017-10-12T12:10:00.000Z","path":"2017/10/12/这样学Java不枯燥-学习笔记/","text":"12345678910import com.rupeng.game.GameCore;public class Main implements Runnable{ public static void main(String[] args) { GameCore.start(new Main()); } public void run() { // 游戏运行的函数 GameCore.alert(\"Hello World\"); }} 123456GameCore.pause(int x) // 暂停x毫秒GameCore.setGameTitle(char * name); // 设置名字GameCore.setGameSize(int width, int height); // 设置宽高GameCore.alert(Object msg); // 弹出提示框（整数、字符串都行）Dimension d = GameCore.getGameSize(); // d.width 、 d.height （imprt java.awt.Demension;） 123GameCore.loadBgView(String imgName); // 不重叠不拉伸显示图片。图片放到 src/Images 下面（注意大小写），可拖拽或者 ctrl+V粘贴playSound(String soundName, boolean repeat); // 播放音乐（仅支持mp3），音乐放到 src/Sounds 下面closeSound(String soundName); // 关闭音乐播放（包括重复播放的） 12long a = 99999L // 常数数字默认为整型，long赋值需要转换到intfloat f = 3.14 // 这样写是错的，需要加个F或f 123String s = GameCore.input(Object value, Object msg); // 输入框（默认信息， 提示信息）boolean b = GameCore.confirm(Object msg); // 确认框（提示信息）int i = Integer.parseInt(s); // 输入的内容到整数 123456789void createText(int txtNum, String text) // 创建只读文本void setTextPosition(int txtNum, int x, int y) // 修改文本位置void setText(int txtNum, String text) // 设置文本内容void setTextColor(int txtNum, Color color) // 设置文本颜色，color.RED、color.green、new color(int R, int G, int B)void setTextFontSize(int txtNum, int size) // 设置文本大小Point getTextPosition(final int num) // 获取文本位置（import java.awt.Point;）Dimension getTextSize(final int textNum)void hdieText(fina int labelNum) // 隐藏文字void showText(final int labelNum) // 显示文字 12345678void createImage(int num, String imgName) // 创建图片控件，图片放到 src/Images 里面（注意大小写）void createImage(int num) // 创建一个什么都不显示的图片void setImageSource(int num, String imgName) // 修改显示的图片源void setImagePosition(int num, int x, int y) // 修改坐标Point getImagePosition(final int num) // 获得坐标Dimension getImagePosition(final int num) // 获得大小void hideImage(int num) // 隐藏图片void showImage(int num) // 显示图片 12345678910精灵文件位置：src/Sprites/精灵名字[]/精灵动作[]/i.png图片 按顺序放好（多选文件夹粘贴）（分层：工作空间—右上角倒三角—包表示法）void createSprite(int num, String spriteName); // 创建精灵void palySpriteAnimate(int spriteNum, String animateName, boolean repeat); // 播放精灵的动作void setSpritePosition(int spriteNum, int x, int y); // 设置精灵的位置Point getSpritePosition(int spriteNum); //获得精灵的位置Dimension getSpriteSize(int spriteNum); // 获取精灵尺寸void hideSprite(int spriteNum); // 隐藏精灵void showSprite(int spriteNum); // 显示精灵void setSpriteFlipX(int spriteNum, boolean flipX); // 是否进行X方向翻转（左右对称,fip为true时翻转，false时还原）void setSpriteFlipY(int spriteNum, boolean flipY); // 是否设置Y方向翻转（上下对称） 123Java程序打包：拷贝bin和两个jar到单独的文件夹，拷贝jre，去掉src.zip、lib\\ext\\jfxrt.jar、bin\\server、bin\\jfxwebkit.dll，减小尺寸；创建一个.bat文件，内容：start jre\\bin\\javaw.exe -cp .\\bin\\ -Djava.ext.dirs=. Main1Main1 代表入口类，如果有包名则要写全名（xxx.Main1） 123String转int：Integer.parseInt(\"123\")String相等：s1.equal(s2); （必须用这种方式写）s1==s2 不使用原因： \"abc\"+\"123\" != \"abc123\" （初学者常犯错误） 12if (i = 10) // Java中这么写是错误的，C语言可以if (b = true) // 这样是正确的 1switch (表达式) // 表达式可以为byte/short/int/char，JDK5后可以是枚举，JDK7后可以是String类型 12345678910GameCore.getPressedKeyCode(); // 获得用户当前按键（只适合“连续动作”，一次性触发最好用“事件驱动”）与KeyEvent中的值作比较：（import java.awt.event.KeyEvent;）用法：if ( key == KeyEvent.VK_UP )数字键：VK_0、VK_1……字母键：VK_A、VK_B……功能键：VK_F1、VK_F2……回车：VK_ENTER空格：VK_SPACEESC：VK_ESCAPE方向键：VK_LEFT、VK_UP、VK_RIGHT、VK_DOWN 12int[10] a = new int[10]; 等价于 int a[10]; 但是前者有初始化int、double等默认为0，String、Integer等默认为null 1编译器认为，if(无else的)、for等操作可能不执行，所以里面的变量初始化会被忽略，若没有初始化则编译器报错 123import java.util.Random;double d = Math.random(); // 返回 [ 0, 1.0 ) 之间的 doubleint num = (int) (Math.random() * 3); // 0-2的整数 1GameCore.rand(int low, int high); // low &lt;= x &lt; high 12345678System.currentTimeMillis() // 返回当前的毫秒事件Date d = new Date(2009-1900,3-1,9); // 需-1900.1.0，为：2009.3.9System.out.println(d1);int year = d.getYear()+1900; getMonth()+1; getDate(); // 年月日getHours(); getMinutes(); getSeconds(); // 时分秒getDat(); //星期几，周日=0，周一=1long time = d.getTime(); // 获取时间的毫秒（相对时间）Date d = new Date(time); // 毫秒转换成时间 1int[][] a = { { 1 }, { 2, 3, 4, 5 }, { 6, 7 } }; // 每一行的列数可以不一样，a[i].length也不一样。 课程视频：如鹏网《这样学Java不枯燥》 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://blog.iwxyi.com/tags/学习笔记/"},{"name":"Java","slug":"Java","permalink":"http://blog.iwxyi.com/tags/Java/"},{"name":"游戏开发","slug":"游戏开发","permalink":"http://blog.iwxyi.com/tags/游戏开发/"}]},{"title":"0x3F3F3F3F","date":"2017-09-01T11:40:00.000Z","path":"2017/09/01/0x3F3F3F3F/","text":"0x3f3f3f3f的十进制是1061109567，是10^9级别的（和0x7fffffff一个数量级），而一般场合下的数据都是小于10^9的，所以它可以作为无穷大使用而不致出现数据大于无穷大的情形。 另一方面，由于一般的数据都不会大于10^9，所以当我们把无穷大加上一个数据时，它并不会溢出（这就满足了“无穷大加一个有穷的数依然是无穷大”），事实上0x3f3f3f3f+0x3f3f3f3f=2122219134，这非常大但却没有超过32-bit int的表示范围，所以0x3f3f3f3f还满足了我们“无穷大加无穷大还是无穷大”的需求。 最后，0x3f3f3f3f还能给我们带来一个意想不到的额外好处：如果我们想要将某个数组清零，我们通常会使用memset(a,0,sizeof(a))，方便又高效，但是当我们想将某个数组全部赋值为无穷大时，就不能使用memset函数而得自己写循环了，因为memset是按字节操作的，它能够对数组清零是因为0的每个字节都是0（一般我们只有赋值为-1和0的时候才使用它）。现在好了，如果我们将无穷大设为0x3f3f3f3f，那么奇迹就发生了，0x3f3f3f3f的每个字节都是0x3f！所以要把一段内存全部置为无穷大，我们只需要memset(a,0x3f,sizeof(a))。 所以在通常的场合下，0x3f3f3f3f真的是一个非常棒的选择！ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"C","slug":"C","permalink":"http://blog.iwxyi.com/tags/C/"}]},{"title":"Java大数相加示例","date":"2017-03-05T12:02:00.000Z","path":"2017/03/05/Java大数相加/","text":"题目：两个整数和能否整除 86 123456789101112131415161718192021import java.util.Scanner;public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); while(sc.hasNext()) { int a = sc.nextInt(); int b = sc.nextInt(); if ((a + b) % 86 == 0) { System.out.println(\"yes\"); } else { System.out.println(\"no\"); } } }} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Java","slug":"Java","permalink":"http://blog.iwxyi.com/tags/Java/"}]},{"title":"正则二三事","date":"2017-01-02T11:40:00.000Z","path":"2017/01/02/正则二三事/","text":"一、校验数字的表达式 1、 数字：^[0-9]*$ 2、 n位的数字：^\\d{n}$ 3、 至少n位的数字：^\\d{n,}$ 4、 m-n位的数字：^\\d{m,n}$ 5、 零和非零开头的数字：^(0|[1-9][0-9]*)$ 6、 非零开头的最多带两位小数的数字：^([1-9][0-9]*)+(.[0-9]{1,2})?$ 7、 带1-2位小数的正数或负数：^(-)?\\d+(.\\d{1,2})?$ 8、 正数、负数、和小数：^(-|+)?\\d+(.\\d+)?$ 9、 有两位小数的正实数：^[0-9]+(.[0-9]{2})?$ 10、 有1~3位小数的正实数：^[0-9]+(.[0-9]{1,3})?$ 11、 非零的正整数：^[1-9]\\d$ 或 ^([1-9][0-9]){1,3}$ 或 ^+?[1-9][0-9]*$ 12、 非零的负整数：^-[1-9][]0-9\"$ 或 ^-[1-9]\\d$ 13、 非负整数：^\\d+$ 或 ^[1-9]\\d*|0$ 14、 非正整数：^-[1-9]\\d*|0$ 或 ^((-\\d+)|(0+))$ 15、 非负浮点数：^\\d+(.\\d+)?$ 或 ^[1-9]\\d.\\d|0.\\d[1-9]\\d|0?.0+|0$ 16、 非正浮点数：^((-\\d+(.\\d+)?)|(0+(.0+)?))$ 或 ^(-([1-9]\\d.\\d|0.\\d[1-9]\\d))|0?.0+|0$ 17、 正浮点数：^[1-9]\\d.\\d|0.\\d[1-9]\\d$ 或 ^(([0-9]+.[0-9][1-9][0-9])|([0-9][1-9][0-9].[0-9]+)|([0-9][1-9][0-9]))$ 18、 负浮点数：^-([1-9]\\d.\\d|0.\\d[1-9]\\d)$ 或 ^(-(([0-9]+.[0-9][1-9][0-9])|([0-9][1-9][0-9].[0-9]+)|([0-9][1-9][0-9])))$ 19、 浮点数：^(-?\\d+)(.\\d+)?$ 或 ^-?([1-9]\\d.\\d|0.\\d[1-9]\\d|0?.0+|0)$ 二、校验字符的表达式 1、 汉字：^[\\u4e00-\\u9fa5]{0,}$ 2、 英文和数字：^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]{4,40}$ 3、 长度为3-20的所有字符：^.{3,20}$ 4、 由26个英文字母组成的字符串：^[A-Za-z]+$ 5、 由26个大写英文字母组成的字符串：^[A-Z]+$ 6、 由26个小写英文字母组成的字符串：^[a-z]+$ 7、 由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$ 8、 由数字、26个英文字母或者下划线组成的字符串：^\\w+$ 或 ^\\w{3,20}$ 9、 中文、英文、数字包括下划线：^[\\u4E00-\\u9FA5A-Za-z0-9_]+$ 10、 中文、英文、数字但不包括下划线等符号：^[\\u4E00-\\u9FA5A-Za-z0-9]+$ 或 ^[\\u4E00-\\u9FA5A-Za-z0-9]{2,20}$ 11、 可以输入含有^%&amp;',;=?$\\\"等字符：[^%&amp;',;=?$\\x22]+ 12、 禁止输入含有~的字符：[^~\\x22]+ 三、特殊需求表达式 1、 Email地址：^\\w+([-+.]\\w+)@\\w+([-.]\\w+).\\w+([-.]\\w+)*$ 2、 域名：[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(/.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+/.? 3、 InternetURL：[a-zA-z]+://[^\\s] 或 ^http://([\\w-]+\\.)+[\\w-]+(/[\\w-./?%&amp;=])?$ 4、 手机号码：^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\\d{8}$ 5、 电话号码(“XXX-XXXXXXX”、”XXXX-XXXXXXXX”、”XXX-XXXXXXX”、”XXX-XXXXXXXX”、”XXXXXXX”和”XXXXXXXX)：^((\\d{3,4}-)|\\d{3.4}-)?\\d{7,8}$ 6、 国内电话号码(0511-4405222、021-87888822)：\\d{3}-\\d{8}|\\d{4}-\\d{7} 7、 身份证号(15位、18位数字)：^\\d{15}|\\d{18}$ 8、 短身份证号码(数字、字母x结尾)：^([0-9]){7,18}(x|X)?$ 或 ^\\d{8,18}|[0-9x]{8,18}|[0-9X]{8,18}?$ 9、 帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$ 10、 密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：^[a-zA-Z]\\w{5,17}$ 11、 强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：^(?=.\\d)(?=.[a-z])(?=.*[A-Z]).{8,10}$ 12、 日期格式：^\\d{4}-\\d{1,2}-\\d{1,2} 13、 一年的12个月(01～09和1～12)：^(0?[1-9]|1[0-2])$ 14 一个月的31天(01～09和1～31)：^((0?[1-9])|((1|2)[0-9])|30|31)$ 15、 钱的输入格式： 1.有四种钱的表示形式我们可以接受:”10000.00” 和 “10,000.00”, 和没有 “分” 的 “10000” 和 “10,000”：^[1-9][0-9]*$ 2.这表示任意一个不以0开头的数字,但是,这也意味着一个字符”0”不通过,所以我们采用下面的形式：^(0|[1-9][0-9]*)$ 3.一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：^(0|-?[1-9][0-9]*)$ 4.这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉,因为钱总不能是负的吧.下面我们要加的是说明可能的小数部分：^[0-9]+(.[0-9]+)?$ 5.必须说明的是,小数点后面至少应该有1位数,所以”10.”是不通过的,但是 “10” 和 “10.2” 是通过的：^[0-9]+(.[0-9]{2})?$ 6.这样我们规定小数点后面必须有两位,如果你认为太苛刻了,可以这样：^[0-9]+(.[0-9]{1,2})?$ 7.这样就允许用户只写一位小数.下面我们该考虑数字中的逗号了,我们可以这样：^[0-9]{1,3}(,[0-9]{3})*(.[0-9]{1,2})?$ 1到3个数字,后面跟着任意个 逗号+3个数字,逗号成为可选,而不是必须：^([0-9]+|[0-9]{1,3}(,[0-9]{3})*)(.[0-9]{1,2})?$ 16、 备注：这就是最终结果了,别忘了”+”可以用”*”替代如果你觉得空字符串也可以接受的话(奇怪,为什么?)最后,别忘了在用函数时去掉去掉那个反斜杠,一般的错误都在这里 17、 xml文件：^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\.[x|X][m|M][l|L]$ 18、 中文字符的正则表达式：[\\u4e00-\\u9fa5] 19、 双字节字符：[^\\x00-\\xff] (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1)) 20、 空白行的正则表达式：\\n\\s*\\r (可以用来删除空白行) 21、 HTML标记的正则表达式：&lt;(\\S?)[^&gt;]&gt;.?&lt;/\\1&gt;|&lt;.? /&gt; (网上流传的版本太糟糕，上面这个也仅仅能部分，对于复杂的嵌套标记依旧无能为力) 22、 首尾空白字符的正则表达式：^\\s|\\s$或(^\\s)|(\\s$) (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式) 23、 腾讯QQ号：[1-9][0-9]{4,} (腾讯QQ号从10000开始) 24、 中国邮政编码：[1-9]\\d{5}(?!\\d) (中国邮政编码为6位数字) 25、 IP地址：\\d+.\\d+.\\d+.\\d+ (提取IP地址时有用) 26、 IP地址：((?:(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)) document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"RegExp","slug":"RegExp","permalink":"http://blog.iwxyi.com/tags/RegExp/"}]},{"title":"CGI-C语言也能干大事","date":"2016-07-12T11:42:00.000Z","path":"2016/07/12/CGI-C语言也能干大事/","text":"CGI &amp; DGI123char * qs = getenv(\"QUERY_STRING\");//获取环境变量char username[256];sscanf(qs, \"username=%s\", username);//获取地址栏后面的东西 断点调试：include \\&lt;windows.h&gt;，然后 MessageBoxA(0,\"ok\",\"ok\",0); 让程序启动后暂停，等待着按按钮；浏览器访问CGI，窗口弹出后，在VS中“调试”→“附加到进程”，设置断点，然后在关闭消息对话框。 123printf(\"Location:http://www.baidu.com\\r\\n\");//重定向，302 Found。注意\\r\\nprintf(\"Location:1.html\\r\\n\");//重定向至cgi程序同目录的1.html文件printf(\"Content-Type:text/html;charset=gbk\\r\\n\\r\\n\");//改成 text/plain，为普通文本，显示HTML标签。 注意\\r\\n\\r\\n（两个），表示报文头结束了（各个报文头顺序可调换）源代码中，\\n能换行，但是浏览器上要用&lt;br&gt;才换行，所以用： \\n&lt;br&gt; 12itoa(i, str, x); //int i 转换成 char str[]、x进制的文本int i = atoi(str); //字符串转换成int 1fprintf(cgiOut, \"&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;大家好，Querystring=%s，你的浏览器UserAgent是：%s，你的IP地址是：%s，当前cgi地址：%s&lt;/body&gt;&lt;/html&gt;\", cgiQueryString, cgiUserAgent, cgiRemoteAddr, cgiScriptName);//可以用printf 12cgiFormString(\"name\", name, sizeof name); // 获取用户名：name=xxxif (cgiFormString(\"password\", pwd, sizeof pwd) != cgiFormSuccess);//返回值表示有没有这个值 123456789101112131415161718 &lt;!--点击登陆转到网址：../11.cgi?name=admin&amp;pwd=123， 或者绝对网址：\"http://www.baidu.com\"。 method=\"get\"（默认）或者\"post\"，post时地址栏看不到表单 --&gt;&lt;form action=\"11.cgi\"&gt; 用户名：&lt;input type=\"text\" name=\"name\" value=\"admin\" /&gt; 密 码：&lt;input type=\"password\" name=\"pwd\" value=\"123\" /&gt; &lt;input type=\"submit\" value=\"登陆\" /&gt;&lt;/form&gt; &lt;!--form中的：input、textarea、select 中的名字和值都会提交给服务器 没有name值的表单将不会提交，包括submit。--&gt;&lt;select name=\"se\"&gt;&lt;option value=\"nan\"&gt;男&lt;/option&gt;&lt;option... /option&gt;&lt;/select&gt; &lt;!--提交的值为value属性，如：se=\"nan\"--&gt; &lt;input type=\"checkbox\" name=\"ch\" id=\"chk\" / &gt;&lt;lable for=\"chk\"&gt;我已阅读XXX&lt;/lable&gt; &lt;!--如果勾上了，会有 \"ch=on\" 提交给服务器。 radio 的 name 属性相同的为一组，提交选中的 value--&gt; &lt;input type=\"hidden\" ... /&gt; &lt;!--隐藏的字段，不会显示，但是也会提交--&gt; 1、select、input、textarea必须要在form中。2、当点击input type=\"submit\"的按钮的时候，会把它所在的form中的所有“有name属性的”input/select/textarea的值（value）提交给服务器。3、表单提交的值 input type=\"text\"的值就是用户输入的值； 对于input type=\"checkbox\"的值就是“选中是on，没选中则没有”； 对于inpu type=\"radio“的则是被选中的name、value提交给服务器； 对于input type=\"submit\"的则是被点击的name、value被提交给服务器； 对textarea就是输入的文本； 对于select就是选择项对应的option的value。 123456TMPL_varlist *varlist1 = 0;//空的参数列表 C99cgiHeaderContentType(\"text/html;charset=gbk\");varlist1 = TMPL_add_var(varlist1, \"test1\", \"特斯特1\", \"pwd\", \"小密码\", \"name\", \"小鹏\", 0); // 3对，最后一个必须为0表示可变char *age = \"38\";varlist1 = TMPL_add_var(varlist1, \"age\", age, 0);//执行完了varlist1四对参数TMPL_write(\"P1.htm\", 0, 0, varlist1, cgiOut, cgiOut); 变量使用：&lt;TMPL_VAR name=\"test1\" /&gt;&lt;br /&gt; 123456789TMPL_varlist * varlist1 = 0;TMPL_loop * loopUsers = 0;varlist1 = TMPL_add_var(varlist1, \"Title\", \"测试Loop\", 0);loopUsers = TMPL_add_varlist(loopUsers, TMPL_add_var(0, \"Name\", \"如鹏网\", \"Age\", \"8\", \"Title\", \"t1\", 0));//t1，同一行有的用同一行loopUsers = TMPL_add_varlist(loopUsers, TMPL_add_var(0, \"Name\", \"淘宝\", \"Age\", \"15\", \"Title\", \"t2\", 0));//t2loopUsers = TMPL_add_varlist(loopUsers, TMPL_add_var(0, \"Name\", \"京东\", \"Age\", \"10\", 0));//测试Loop，同一行没有的到上层去找varlist1 = TMPL_add_loop(varlist1, \"users\", loopUsers);//大List里面的小List（name=“users”的Loop）cgiHeaderContentType(\"text/html;charset=gbk\");TMPL_write(\"Users.htm\", 0, 0, varlist1, cgiOut, cgiOut); 12345&lt;table&gt;&lt;tbody&gt;&lt;TMPL_LOOP name=\"users\"&gt; &lt;tr&gt;&lt;td&gt;&lt;TMPL_VAR name=\"Name\" /&gt;&lt;/td&gt; &lt;td&gt;&lt;TMPL_VAR name=\"Age\" /&gt;&lt;/td&gt; &lt;td&gt;&lt;TMPL_VAR name=\"Title\" /&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/TMPL_LOOP&gt;&lt;/tbody&gt; &lt;/table&gt; MySQL 数据库1select * from Students // 表里面的数据 1insert into Students(ID, Name, Gender) value(3, 'asd', 1) // 插入数据，属性值对应（允许为空或者自动递增可不用写） 123update Persons set Name='hehehe',Age=Age+1 // 全部更新表中某几列的数据update Persons set Age=Age+1 where Name='Tom' // 名字为 Tom 的人年龄+1条件用法：where (Age&gt;20 and Age&lt;30) or(Age=80) // or、and、not、&lt;、&gt;、&gt;=、&lt;=、!=（或&lt;&gt;） 12delete from Person where ... // 删除表中的数据，没有where为删除所有drop table Persons // 删除表 1234select Age+1, Name from Persons where...// 显示表中的某几列（Age的列结果为Age+1）select Name 姓名, Age as 年龄 from Persons; // 为列取别名，可以不写asselect 1+1 // 检索不与表关联的数据，结果为2select now() // 返回时间 12345SQL聚合函数：MAX（最大值）、MIN（最小值）、AVG （平均值）、SUM （和）、COUNT（数量）select min(Age), max(Age) from Persons // 最低、最高年龄select count(*) from Persons where Age&gt;25 // 年龄大于25的人数select sum(Age), avg(Age) from Persons // 总年龄和平均年龄select count(Hobbies) from Persons // Hobbies 不为空的数量 12select * from Persons (where……) order by Age ASC, Salary DESC // 按照年龄升序(ASC,不写时默认)、薪水降序(DESC) 排列order 必须放在 where 后面 123单字符通配符：_多字符通配符：% （可以为0个）select * from Persons where Name like 'T%' // 名字为 T 开头的所有 1234nul 代表“不知道”，而不是“没有”。null+1 结果是 nullselect ...... name=null 或者 name != null 或者 nul=null 都没有任何返回结果select name+\"a\" from Personsselect * from Persons where name is (not) null // 判断是不是null 1limit 首行行号（行号从 0 开始）, 最大数目 // limit 必须放在所有语句的最后 12group by Age // 按照年龄分组，相同的为一组（重复的堆到一起）select age, count(*) from Persons group by age // 显示所有年龄段，并且显示数量 12345查询每张订单的订单号、价格、对应的客户姓名以及客户年龄SELECT o.Number 订单编号,o.Price 价格,c.Name 客户姓名,c.Age FROM T_Orders o // 表别名为 oLEFT JOIN T_Customers c ON o.CustomerId=c.Id // 别名为 c，当两个相等的时候，进行连接LEFT JOIN T_OrderTypes t ON o.TypeId=t.Id // 可以 join 多张表WHERE o.Price&gt;=150 // 可添加 where 条件 12设计表——外键——添加，然后删除时会提示无法删除（可设置）删除时、更新时：一般默认RESTRICT（一起删除）；SET NULL（删除后连接的项目设置为NULL）；NO ACTION/RESTRICT（拒绝删除） C + MySQL使用方法：需要修改三个目录，以及复制dll 1、在项目属性中【VC++目录】→“包含目录”，选择mysql的include文件夹；“库目录”选择mysql的lib文件夹；【链接器】→【输入】的“附加依赖项”增加“libmysql.lib”。 2、C代码里include头文件mysql.h，并且在之前要include头文件winsock.h。 3、MYSQL *pConn = mysql_init(0); 4、编译运行，会报错找不到“libmysql.dll”，把mysql的libmysql.dll复制到exe的目录下。 123456789101112131415161718192021222324#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;winsock.h&gt;#include &lt;mysql.h&gt;int main(){ MYSQL *mysql = mysql_init(0); if(!mysql_real_connect(mysql,\"localhost\",\"root\",\"root\",\"study3\",0,0,0)){ printf(\"连接数据库出错：%s\",mysql_error(mysql)); // mysql的上一次错误信息 goto exit;//goto一般不推荐使用，但是在错误处理的时候，很好用 } printf(\"连接数据库成功！\\n\"); if(mysql_query(mysql,\"set names gbk\")){ // 这样才能用中文。失败时 为 真 printf(\"设定连接编码失败%s\",mysql_error(mysql)); goto exit; } exit: mysql_close(mysql);//程序最后必须关闭连接，否则会有mysql服务器连接过多卡死的可能性 printf(\"exit\"); getchar(); return 0;} execute封装12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;winsock.h&gt;#include &lt;mysql.h&gt;void executeNonQuery(char * sql); // 没有返回值的MYSQL_RES * executeQuery(char * sql); // 有返回值的int main(){ executeNonQuery(\"insert into Persons(name, gender) value('aaa', 1)\"); MYSQL_RES * res = executeQuery(\"select * from Persons\"); MYSQL_ROW row; while (row = mysql_fetch_row(res)) { char * un = row[0]; char * pwd = row[1]; printf(\"username = %s, password = %s\\n\", un, pwd); } system(\"pause\"); return 0;}void executeNonQuery(char * sql){ MYSQL * pConn = mysql_init(0); if (!mysql_real_connect(pConn, \"localhost\", \"root\", \"root\", \"test\", 0, 0, 0)) { printf(\"连接失败：%s\\n\", mysql_error(pConn)); goto endd; } if (mysql_query(pConn, \"set names gbk\")) { printf(\"设置gbk失败：%s\\n\", mysql_error(pConn)); goto endd; } if (mysql_query(pConn, sql)) { printf(\"查询失败：%s\\n\", mysql_error(pConn)); goto endd; }endd: mysql_close(pConn);}MYSQL_RES * executeQuery(char * sql){ MYSQL * pConn = mysql_init(0); if (!mysql_real_connect(pConn, \"localhost\", \"root\", \"root\", \"test\", 0, 0, 0)) { printf(\"连接失败：%s\\n\", mysql_error(pConn)); return \"\"; } if (mysql_query(pConn, \"set names gbk\")) { printf(\"设置gbk失败：%s\\n\", mysql_error(pConn)); return \"\"; } if (mysql_query(pConn, sql)) { printf(\"查询失败：%s\\n\", mysql_error(pConn)); return \"\"; } MYSQL_RES * result = mysql_store_result(pConn); mysql_close(pConn); return result;} 表单数据12345char sql[1024]={0}; // 把用户输入的字符串动态拼接生成sql语句char userName, hexUserName[1024]={0}; // 把可能含有特殊符号的字符串进行16进制转换mysql_hex_string(hexUserName, userName, strlen(userName)); // 转换成安全的16进制sprintf(sql, \"Insert into T_Users(UserName,Password) values(0x%s,'%s')\", hexUserName,password);// 可以直接识别命令里面0x开头的16进制数据，并自动转换成原来的字符串(数字 0，不是 英文o) 123int age;cgiFormInteger(\"age\", &amp;age, 100); // 获取整型表单。注意，是地址！最后一个是失败后的age默认值// 例如，当 \"age=aaa\" 时，取不到整型的值，所以 age = 100 1234567int len; // 用来决定需要申请的长度char *txt;TMPL_varlist *varlist = 0;cgiFormStringSpaceNeeded(\"txt1\",&amp;len); // 用于获取可能会非常长的值的长度txt = (char *)malloc(len+1); // 动态申请内存cgiFormString(\"txt1\",txt,len);free(txt); // 最后别忘了 free 12if(cgiFormCheckboxSingle(\"agree\")!=cgiFormSuccess) // 多选框是否选中&lt;select&gt;&lt;option&gt;xxx&lt;/option&gt;&lt;/select&gt; 和 \"radio\" 都用 cgiFormString 来获取是否输入 文件操作HTML文件123&lt;form method=\"post\" enctype=\"multipart/form-data\"&gt; // 必须这样写 &lt;input type=\"file\" name=\"f1\"&gt;&lt;/form&gt; 文件参数 cgiFormFileName：上传的文件名 cgiFormFileSize：文件大小（单位为B） cgiFormFileRead：读取上传文件 cgiFormFileClose：关闭上传的文件 判断有没有上传文件1if(cgiFormFileName(\"file1\",uploadfilename,sizeof(uploadfilename))!=cgiFormSuccess) 获取扩展名1234_splitpath(uploadfilename,NULL,NULL,NULL,fileExt); // &lt;stdlib.h&gt;中 参数：全路径指针，盘符（带冒号），路径（纯目录无盘符，如 /aaa/），文件名（不包含后缀名），后缀名（带点） 文件格式：d:/aaa/bbb.jpgif(stricmp(fileExt,\".jpg\")!=0&amp;&amp;stricmp(fileExt,\".png\"))…… // stricmp 为不区分大小写的比较 获取文件大小12cgiFormFileSize(\"file1\",&amp;filesize);if(filesize&gt;1024*1024)…… // 1024 * 1024 = 1 M 总的操作12345678910111213cgiFilePtr file1; // 声明类似文件指针的变量，网络文件指针//读取本地文件，用于写入，本地文件指针FILE *fileLocal = fopen(uploadfilename,\"wb\"); // C语言读取文件，wb是二进制模式，默认是用文本char buffer[1024]; // 每次最多1024kbint lenRead; // 实际读的字节数cgiFormFileOpen(\"file1\",&amp;file1);while(cgiFormFileRead(file1,buffer,sizeof(buffer),&amp;lenRead)==cgiFormSuccess){ fwrite(buffer,lenRead,1,fileLocal); // buffer[] 的前 lenRead 字节写入到 fileLocal 中}fclose(fileLocal);cgiFormFileClose(file1);printFileUploadMsg(\"上传成功\"); 如鹏网《C语言也能干大事》学习笔记 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://blog.iwxyi.com/tags/学习笔记/"},{"name":"C","slug":"C","permalink":"http://blog.iwxyi.com/tags/C/"},{"name":"CGI","slug":"CGI","permalink":"http://blog.iwxyi.com/tags/CGI/"},{"name":"Web","slug":"Web","permalink":"http://blog.iwxyi.com/tags/Web/"}]}]