[{"title":"工厂模式","date":"2019-10-12T12:18:00.000Z","path":"2019/10/12/工厂模式/","text":"在平时编程中，构建对象最常用的方式是 new 一个对象。乍一看这种做法没什么不好，而实际上这也属于一种硬编码。每 new 一个对象，相当于调用者多知道了一个类，增加了类与类之间的联系，不利于程序的松耦合。其实构建过程可以被封装起来，工厂模式便是用于封装对象的设计模式。 简单工厂模式举个例子，直接 new 对象的方式相当于当我们需要一个苹果时，我们需要知道苹果的构造方法，需要一个梨子时，需要知道梨子的构造方法。更好的实现方式是有一个水果工厂，我们告诉工厂需要什么种类的水果，水果工厂将我们需要的水果制造出来给我们就可以了。这样我们就无需知道苹果、梨子是怎么种出来的，只用和水果工厂打交道即可。 水果工厂： 123456789public class FruitFactory { public Fruit create(String type){ switch (type){ case \"苹果\": return new Apple(); case \"梨子\": return new Pear(); default: throw new IllegalArgumentException(\"暂时没有这种水果\"); } }} 调用： 123456789public class User { private void eat(){ FruitFactory fruitFactory = new FruitFactory(); Fruit apple = fruitFactory.create(\"苹果\"); Fruit pear = fruitFactory.create(\"梨子\"); apple.eat(); pear.eat(); }} 事实上，将构建过程封装的好处不仅可以降低耦合，如果某个产品构造方法相当复杂，使用工厂模式可以大大减少代码重复。 简单工厂模式就是让一个工厂类承担构建所有对象的职责。调用者需要什么产品，让工厂生产出来即可。它的弊端也显而易见： 一是如果需要生产的产品过多，此模式会导致工厂类过于庞大，承担过多的职责，变成超级类。当苹果生产过程需要修改时，要来修改此工厂。梨子生产过程需要修改时，也要来修改此工厂。也就是说这个类不止一个引起修改的原因。违背了单一职责原则。 二是当要生产新的产品时，必须在工厂类中添加新的分支。而开闭原则告诉我们：类应该对修改封闭。我们希望在添加新功能时，只需增加新的类，而不是修改既有的类，所以这就违背了开闭原则。 工厂方法模式为了解决简单工厂模式的这两个弊端，工厂方法模式应运而生，它规定每个产品都有一个专属工厂。比如苹果有专属的苹果工厂，梨子有专属的梨子工厂，Java 代码如下： 苹果工厂： 12345public class AppleFactory { public Fruit create(){ return new Apple(); }} 梨子工厂： 12345public class PearFactory { public Fruit create(){ return new Pear(); }} 调用者： 12345678910public class User { private void eat(){ AppleFactory appleFactory = new AppleFactory(); Fruit apple = appleFactory.create(); PearFactory pearFactory = new PearFactory(); Fruit pear = pearFactory.create(); apple.eat(); pear.eat(); }} 调用者虽然不需要和 Apple 、Pear 类打交道了，但却需要和 AppleFactory、PearFactory 类打交道。有几种水果就需要知道几个工厂类，耦合度完全没有下降啊，甚至还增加了代码量！ 仔细想一想，工厂模式的第二个优点在工厂方法模式中还是存在的。当构建过程相当复杂时，工厂将构建过程封装起来，调用者可以很方便的直接使用，同样以苹果生产为例： 12345678public class AppleFactory { public Fruit create(){ AppleSeed appleSeed = new AppleSeed(); Sunlight sunlight = new Sunlight(); Water water = new Water(); return new Apple(appleSeed, sunlight, water); }} 调用者无需知道苹果的生产细节，当生产过程需要修改时也无需更改调用端。同时，工厂方法模式解决了简单工厂模式的两个弊端。 当生产的产品种类越来越多时，工厂类不会变成超级类。工厂类会越来越多，保持灵活。不会越来越大、变得臃肿。如果苹果的生产过程需要修改时，只需修改苹果工厂。梨子的生产过程需要修改时，只需修改梨子工厂。符合单一职责原则。 当需要生产新的产品时，无需更改既有的工厂，只需要添加新的工厂即可。保持了面向对象的可扩展性，符合开闭原则。 抽象工厂模式工厂方法模式可以进一步优化，提取出工厂接口： 123public interface IFactory { Fruit create();} 然后苹果工厂和梨子工厂都实现此接口： 123456public class AppleFactory implements IFactory { @Override public Fruit create(){ return new Apple(); }} 123456public class PearFactory implements IFactory { @Override public Fruit create(){ return new Pear(); }} 此时，调用者可以将 AppleFactory 和 PearFactory 统一作为 IFactory 对象使用： 12345678910public class User { private void eat(){ IFactory appleFactory = new AppleFactory(); Fruit apple = appleFactory.create(); IFactory pearFactory = new PearFactory(); Fruit pear = pearFactory.create(); apple.eat(); pear.eat(); }} 可以看到，我们在创建时指定了具体的工厂类后，在使用时就无需再关心是哪个工厂类，只需要将此工厂当作抽象的 IFactory 接口使用即可。这种经过抽象的工厂方法模式被称作抽象工厂模式。 由于客户端只和 IFactory 打交道了，调用的是接口中的方法，使用时根本不需要知道是在哪个具体工厂中实现的这些方法，这就使得替换工厂变得非常容易。 例如： 1234567public class User { private void eat(){ IFactory factory = new AppleFactory(); Fruit fruit = factory.create(); fruit.eat(); }} 如果需要替换为吃梨子，只需要更改一行代码即可： 1234567public class User { private void eat(){ IFactory factory = new PearFactory(); Fruit fruit = factory.create(); fruit.eat(); }} IFactory 中只有一个抽象方法时，或许还看不出抽象工厂模式的威力。实际上抽象工厂模式主要用于替换一系列方法。例如将程序中的 SQL Server 数据库整个替换为 Access 数据库，使用抽象方法模式的话，只需在 IFactory 接口中定义好增删改查四个方法，让 SQLFactory 和 AccessFactory 实现此接口，调用时直接使用 IFactory 中的抽象方法即可，调用者无需知道使用的什么数据库，我们就可以非常方便的整个替换程序的数据库，并且让客户端毫不知情。 抽象工厂模式很好的发挥了开闭原则、依赖倒置原则，但缺点是抽象工厂模式太重了，如果 IFactory 接口需要新增功能，则会影响到所有的具体工厂类。使用抽象工厂模式，替换具体工厂时只需更改一行代码，但要新增抽象方法则需要修改所有的具体工厂类。所以抽象工厂模式适用于增加同类工厂这样的横向扩展需求，不适合新增功能这样的纵向扩展。 参考：https://zhuanlan.zhihu.com/p/85624457 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://blog.iwxyi.com/tags/设计模式/"}]},{"title":"单例模式","date":"2019-10-12T12:17:00.000Z","path":"2019/10/12/单例模式/","text":"单例模式非常常见，某个对象全局只需要一个实例时，就可以使用单例模式。它的优点也显而易见： 它能够避免对象重复创建，节约空间并提升效率 避免由于操作不同实例导致的逻辑错误 单例模式有两种实现方式：饿汉式和懒汉式。 饿汉式饿汉式：变量在声明时便初始化。 1234567891011public class Singleton { private static Singleton instance = new Singleton(); private Singleton() { } public static Singleton getInstance() { return instance; }} 可以看到，我们将构造方法定义为 private，这就保证了其他类无法实例化此类，必须通过 getInstance 方法才能获取到唯一的 instance 实例，非常直观。但饿汉式有一个弊端，那就是即使这个单例不需要使用，它也会在类加载之后立即创建出来，占用一块内存，并增加类初始化时间。就好比一个电工在修理灯泡时，先把所有工具拿出来，不管是不是所有的工具都用得上。就像一个饥不择食的饿汉，所以称之为饿汉式。 懒汉式懒汉式：先声明一个空变量，需要用时才初始化。 1234567891011121314public class Singleton { private static Singleton instance = null; private Singleton() { } public static Singleton getInstance(){ if (instance == null) { instance = new Singleton(); } return instance; }} 我们先声明了一个初始值为 null 的 instance 变量，当需要使用时判断此变量是否已被初始化，没有初始化的话才 new 一个实例出来。就好比电工在修理灯泡时，开始比较偷懒，什么工具都不拿，当发现需要使用螺丝刀时，才把螺丝刀拿出来。当需要用钳子时，再把钳子拿出来。就像一个不到万不得已不会行动的懒汉，所以称之为懒汉式。 懒汉式解决了饿汉式的弊端，好处是按需加载，避免了内存浪费，减少了类初始化时间。 双检锁方式：线程安全上述代码的懒汉式单例乍一看没什么问题，但其实它不是线程安全的。如果有多个线程同一时间调用 getInstance 方法，instance 变量可能会被实例化多次。为了保证线程安全，我们需要给判空过程加上锁： 12345678910111213141516public class Singleton { private static Singleton instance = null; private Singleton() { } public static Singleton getInstance() { synchronized (Singleton.class) { if (instance == null) { instance = new Singleton(); } } return instance; }} 这样就能保证多个线程调用 getInstance 时，一次最多只有一个线程能够执行判空并 new 出实例的操作，所以 instance 只会实例化一次。 双检锁提高性能但这样的写法仍然有问题，当多个线程调用 getInstance 时，每次都需要执行 synchronized 同步化方法，这样会严重影响程序的执行效率。所以更好的做法是在同步化之前，再加上一层检查： 123456789101112131415161718public class Singleton { private static Singleton instance = null; private Singleton() { } public static Singleton getInstance() { if (instance == null) { synchronized (Singleton.class) { if (instance == null) { instance = new Singleton(); } } } return instance; }} 这样增加一种检查方式后，如果 instance 已经被实例化，则不会执行同步化操作，大大提升了程序效率。上面这种写法也就是我们平时较常用的双检锁方式实现的线程安全的单例模式。 静态内部类方式除了双检锁方式外，还有一种比较常见的静态内部类方式保证懒汉式单例的线程安全： 12345678910111213public class Singleton { private static class SingletonHolder { public static Singleton instance = new Singleton(); } private Singleton() { } public static Singleton getInstance() { return SingletonHolder.instance; }} 虽然我们经常使用这种静态内部类的懒加载方式，但其中的原理不一定每个人都清楚。接下来我们便来分析其原理，搞清楚两个问题： 静态内部类方式是怎么实现懒加载的 静态内部类方式是怎么保证线程安全的 Java 类的加载过程包括：加载、验证、准备、解析、初始化。初始化阶段即执行类的 clinit 方法（clinit = class + initialize），包括为类的静态变量赋初始值和执行静态代码块中的内容。但不会立即加载内部类，内部类会在使用时才加载。所以当此 Singleton 类加载时，SingletonHolder 并不会被立即加载，所以不会像饿汉式那样占用内存。 另外，Java 虚拟机规定，当访问一个类的静态字段时，如果该类尚未初始化，则立即初始化此类。当调用Singleton 的 getInstance 方法时，由于其使用了 SingletonHolder 的静态变量 instance，所以这时才会去初始化 SingletonHolder，在 SingletonHolder 中 new 出 Singleton 对象。这就实现了懒加载。 第二个问题的答案是 Java 虚拟机的设计是非常稳定的，早已经考虑到了多线程并发执行的情况。虚拟机在加载类的 clinit 方法时，会保证 clinit 在多线程中被正确的加锁、同步。即使有多个线程同时去初始化一个类，一次也只有一个线程可以执行 clinit 方法，其他线程都需要阻塞等待，从而保证了线程安全。 懒汉式的缺点就是将程序加载时间从启动时延后到了运行时，虽然启动时间缩短了，但我们浏览页面时就会看到数据的 loading 过程。 一般的建议是：对于构建不复杂，加载完成后会立即使用的单例对象，推荐使用饿汉式。对于构建过程耗时较长，并不是所有使用此类都会用到的单例对象，推荐使用懒汉式。 参考：https://zhuanlan.zhihu.com/p/85624457 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"多线程","slug":"多线程","permalink":"http://blog.iwxyi.com/tags/多线程/"},{"name":"设计模式","slug":"设计模式","permalink":"http://blog.iwxyi.com/tags/设计模式/"}]},{"title":"好玩的Linux命令行","date":"2019-10-05T05:54:00.000Z","path":"2019/10/05/好玩的Linux命令行/","text":"呼出命令 moo cowsay 你要说的话xcowsay 你要说的话 sl 蒸汽机 oneko 小猫 cmatrix 数据流雨 aafire 代码火 xeyes 两只眼睛 pv 模拟人工打字echo \"要说的话\" | pv -qL 10 toilet Hello! 字母组成文字图toilet -f mono12 -F metal Hello! 另一个风格 bb 外太空音乐 ASCIIquarium 水族箱 asciiview 图片路径 字符图（需要PNG图标） you-get \"网址\" 下载网址中的视频 安装【前言】作为一名程序员，在别人的眼里往往是充满科技感、神秘感的，而在我们自己的眼里却往往是觉得无聊、枯燥的。其实，在程序的世界里同样会充满着各种的彩蛋，这些彩蛋往往都是一些大神留下来的，我们未曾发现，只是我们缺少发现程序之美而已。 今天小编就来唠叨几个程序中，有趣酷炫的命令，来体验一波程序彩蛋之美。 Tips：施展功力的时候，最好有妹子在身边，装足一波逼的同时，说不定还能脱单哟~ 好，废话不多说，直接上命令： 一、moo彩蛋：你今天咩咩了没有？（滑稽眼） ~$ apt-get moo 效果： img 二、Cowsay彩蛋： 一看名字就知道是牛要说话了，哈哈，没错，就是设定一头牛跟你对话，有意识不？ 这个指令有两种牛，一个是普通的Cowsay牛，另一个是加强、纯种的XCowsay奶牛，下面就来看看： ~$ apt-get install cowsay # 安装【普通牛】程序 ~$ apt-get install xcowsay # 安装【加强牛】程序 ~$ cowsay 旁边坐的是你女朋友吧！ # 执行 ~$ xcowsay 旁边坐的是你女朋友吧！ # 执行 img img 三、sl （Steam Locomotive）彩蛋：在电脑屏幕上隆隆的驶过一辆蒸汽机火车（有趣吧！全屏效果更好哦~）。 ~$ apt-get install sl # 安装命令 ~$ sl # 执行命令 效果： img 四、oneko彩蛋：撸猫指令，”oneko”会生成一个图像猫，与你愉快的玩耍。 ~$ apt-get install oneko # 安装程序 ~$ oneko # 执行 效果： img 五、cmatrix彩蛋：有没有想过，你的电脑上也能像黑客片中的一样，让电脑上的数据飞起来，看看那引人瞩目、令人叹为观止的数据流，黑客中最神秘、不可思议的一个场景在自己电脑上是如何实现的。 ~$ apt-get install cmatrix # 安装程序 ~$ cmatrix # 执行 效果（全屏感觉更好）： img 六、xeyes彩蛋：生成一双会注视你工作的眼镜。想想在工作中，这是一种什么感觉。。。。。 ~$ apt-get install xeyes # 安装程序 ~$ xeyes # 执行 效果： img 七、ASCIIquarium彩蛋：把你的linux终端变成一个海洋世界，各种生物在不断呈现，有鱼、有水、有草…，真是Amazing~~ 1234567sudo apt-get install libcurses-perlcd /tmpwget http://search.cpan.org/CPAN/authors/id/K/KB/KBAUCOM/Term-Animation-2.4.tar.gztar -zxvf Term-Animation-2.4.tar.gzcd Term-Animation-2.4/perl Makefile.PL &amp;&amp; make &amp;&amp; make testsudo make install 效果： img 八、aview命令彩蛋：想象一下将一张图片以ASCII码格式在终端上显示出来是什么效果？实现后真实酷爆了。。。 安装aalib-1.4 123456wget https://sourceforge.net/projects/aa-project/files/latest/download?source=files # 可能需要手动改下载的文件名tar xvzf aalib-1.4rc5.tar.gzcd aalib-1.4.0./configuremakesudo make install 二、安装aview 12345wget http://prdownloads.sourceforge.net/aa-project/aview-1.3.0rc1.tar.gzcd aview-1.3.0./configuremakesudo make install 三、安装ImageMagick 1sudo apt-get install ImageMagick 可能要用： 1sudo apt-get install imagemagick 如果还是不行，用手动安装： 12345678wget https://www.imagemagick.org/download/ImageMagick.tar.gztar -xzvf ImageMagick.tar.gzcd ImageMagick-7.0.8-67/./configure # 会滚动一段时间make &amp;&amp; make install # 需要好久sudo ldconfig /usr/local/libconvert -version # 检查是否成功convert input.tif output.pdf # 执行成功当前目录下会生成output.pdf 如果convert -version出现convert command notfound，需要配置环境变量vim /etc/profile 添加如下： 123&gt; export ImageMagick_HOME=/usr/local/ImageMagick&gt; export PATH=$PATH:$ImageMagick_HOME/bin&gt; 四、测试是否成功 1asciiview songshu.jpg 效果： img 九、pv彩蛋：模仿人工打字。将预先设定好的文字内容按约定的时间逐个输出，类似有人在敲键盘。 ~$ apt-get install pv # 安装程序 ~$ echo “Tecmint[dot]com is a community of Linux Nerds and Geeks” | pv -qL 10 # 输出设定好的内容 效果： img 参考：https://www.jianshu.com/p/08e9094f61ce Linux最强大的一个特征就是它有大量的各种小命令工具，这也可以称做是它最有趣的一个地方了。你要知道，Linux命令终端并不是总来干一些严肃的事情的，这里列举一些很有趣的命令。（它们的有趣并不是因为无用，而是真的有趣。） 一、cmatrix （代码雨） 安装cmatrix：#sudo apt-get install cmatrix执行效果：# cmatix二、oneko （小猫）安装oneko: #sudo apt-get install oneko执行效果: ~# oneko三、aafire （代码火）安装：#sudo apt-get install libaa-bin执行效果：#aafire四、ASCIIquarium （水族馆）安装：# cd /tmp # wget http://www.robobunny.com/projects/asciiquarium/asciiquarium.tar.gz ~# tar -zxvf asciiquarium.tar.gz ~# cd asciiquarium_1.1/ ~# cp asciiquarium /usr/local/bin ~# chmod 0755 /usr/local/bin/asciiquarium执行效果：# asciiquarium五、toilet （不是厕所！！！它能用字母拼写出更大字母的工具，具体拼出什么字由命令后面的参数决定，不仅如此，它还能打印出各种风格的效果，比如彩色，金属光泽等。）安装： # sudo apt-get install toilet执行效果：# toilet Hello! # toilet -f mono12 -F metal Hello! 等等六、sl (蒸汽机。ls是linux命令最常用的一个命令，用来列表文件目录等。因为用的频繁，难免有着急打错的时候，一旦你敲成了 ‘sl’，会出现什么结果？）安装：#sudo apt-get install sl执行效果：#sl七、cowsay 和 xcowsay (牛牛说话啦！）安装：#sudo apt-get install cowsay #sudo apt-get install xcowsay执行效果：# cowsay 你好 # xcowsay 你好八、xeyes (大眼睛)安装：#sudo apt-get install xeyes执行效果：#xeyes九、moo (今天你咩咩了没？)无需安装执行效果：# apt-get moo十、bb (外太空音乐……)安装：~# sudo apt-get install bb执行效果： ~# bb document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Linux","slug":"Linux","permalink":"http://blog.iwxyi.com/tags/Linux/"}]},{"title":"Deepin个人配置","date":"2019-09-23T06:00:00.000Z","path":"2019/09/23/Deepin个人配置/","text":"安装Sublime Text https://www.sublimetext.com/docs/3/linux_repositories.html 12345wget -qO - https://download.sublimetext.com/sublimehq-pub.gpg | sudo apt-key add -sudo apt-get install apt-transport-httpsecho \"deb https://download.sublimetext.com/ apt/stable/\" | sudo tee /etc/apt/sources.list.d/sublime-text.listsudo apt-get updatesudo apt-get install sublime-text 修改仓库/商店软件源https://bbs.deepin.org/forum.php?mod=viewthread&amp;tid=179163 无法添加软件源 sudo dedit /etc/lsb-release，保存为下面的内容 123456789#DISTRIB_ID=Deepin#DISTRIB_RELEASE=\"15.10.1\"#DISTRIB_DESCRIPTION=\"Deepin 15.10.1 \"#DISTRIB_CODENAME=stableDISTRIB_ID=UbuntuDISTRIB_RELEASE=16.04DISTRIB_CODENAME=trustyDISTRIB_DESCRIPTION=\"Ubuntu 16.04.3 LTS\" 安装rEFInd引导https://www.ithome.com/0/425/537.htm 引导启动项顺序 https://blog.csdn.net/owen_suen/article/details/79050549 /etc/grub.d文件夹下的30_os-prober文件改名为08_os-prober sudo update-grub 修改Chrome滚动速度https://www.helplib.com/ubuntu/article_164190 SSR下载https://github.com/qingshuisiyuan/electron-ssr-backup/releases 安装Qt可能需要自己手动设置编译器上的C++路径，否则无法编译（5.13.1） 安装依赖库https://blog.csdn.net/qq_42378797/article/details/91038804 或者输入下面一句话也可以安装所有的库： 1sudo apt-get install build-essential libgl1-mesa-dev 打包程序https://blog.csdn.net/qing666888/article/details/78577633 支持中文https://my.oschina.net/lieefu/blog/505363?fromerr=NNm21wBS 安装Android Studio安装 Java：sudo apt install default-jdk 安装 SDK：wget http://dl.google.com/android/android-sdk_r22.0.5-linux.tgz 安装 AS：sudo apt install android-studio 安装 Gradle：AS安装https://shimo.im/docs/C7Om170UHl0Ih8yD/read 安装 Virtual Box：sudo apt-get install virtualbox 安装 Genymotion：https://www.jianshu.com/p/53bd3408439c 手动下载后安装方法： 123&gt; chmod 755 genymotion.bin # 需要权限&gt; ./genymotion -d /home/mrxy001/Programs&gt; Android Studio 连接不上 Genymotion 设备：Genymotion &gt; Settings &gt; adb &gt; custom &gt; /home/mrxy001/Android/Sdk/ 挂载FTP1curlftpfs -o codepage=utf8 ftp://username:password@iwxyi.com /home/mrxy001/ftp 开机自动挂载： 1echo \"curlftpfs -o codepage=utf8 ftp://username:password@iwxyi.com /home/mrxy001/ftp\" &gt;&gt; /etc/fstab 安装Fira Code字体https://blog.csdn.net/m0_37952030/article/details/99958890 翻墙https://github.com/qingshuisiyuan/electron-ssr-backup 安装PHPStudyhttps://blog.csdn.net/qq_40842615/article/details/81075231 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Linux","slug":"Linux","permalink":"http://blog.iwxyi.com/tags/Linux/"}]},{"title":"GCC和G++的区别","date":"2019-09-18T00:23:00.000Z","path":"2019/09/18/GCC和G-的区别/","text":"gcc和g++都是GNU(组织)的一个编译器。 误区一:gcc只能编译c代码,g++只能编译c++代码两者都可以，但是请注意：1.后缀为.c的，gcc把它当作是C程序，而g++当作是c++程序；后缀为.cpp的，两者都会认为是c++程序，注意，虽然c++是c的超集，但是两者对语法的要求是有区别的。C++的语法规则更加严谨一些。2.编译阶段，g++会调用gcc，对于c++代码，两者是等价的，但是因为gcc命令不能自动和C＋＋程序使用的库联接，所以通常用g++来完成链接，为了统一起见，干脆编译/链接统统用g++了，这就给人一种错觉，好像cpp程序只能用g++似的。 误区二:gcc不会定义__cplusplus宏，而g++会实际上，这个宏只是标志着编译器将会把代码按C还是C++语法来解释，如上所述，如果后缀为.c，并且采用gcc编译器，则该宏就是未定义的，否则，就是已定义。 误区三:编译只能用gcc，链接只能用g++严格来说，这句话不算错误，但是它混淆了概念，应该这样说：编译可以用gcc/g++，而链接可以用g++或者gcc -lstdc++。因为gcc命令不能自动和C＋＋程序使用的库联接，所以通常使用g++来完成联接。但在编译阶段，g++会自动调用gcc，二者等价。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"C++","slug":"C","permalink":"http://blog.iwxyi.com/tags/C/"},{"name":"编译原理","slug":"编译原理","permalink":"http://blog.iwxyi.com/tags/编译原理/"}]},{"title":"C++可变长参数","date":"2019-08-11T00:13:00.000Z","path":"2019/08/11/C-可变长参数/","text":"type function(type arg1, ...) { } 12345678910111213141516171819202122232425262728293031323334353637#include &lt;iostream&gt;#include &lt;cstdarg&gt;using namespace std;int vsum(int count, ...) { // 定义一个变长参数类型的指针变量：ap （Argument Pointer） va_list ap; // 初始化指针变量ap. // 第二个参数count是用来确定ap的起始位置的，count是vsum的第一个参数， // 注意： 如果vsum在count参数后，还有一个命名的参数叫abc, 那么就要va_start(ap, abc)来初始化ap了 // 后边的变长参数是根据count的地址来计算出来 va_start(ap, count); int val(0); int sum(0); // 遍历变长参数内容，通过ap。 for (int i=0; i&lt;count; ++i) { // va_arg的第一个参数是va_list定义的变长参数指针ap， // 第二个参数指明了当前位置变长参数的类型。va_arg会自动改变ap的指针位置。 // 下次再调用va_arg它就自动取下一个参数了，这里ap就像个迭代器 val = va_arg(ap, int); sum += val; } // 清理工作 va_end(ap); return sum;}int main(){ cout &lt;&lt; vsum(4, 1,2,3,4) &lt;&lt; endl;} 示例：递归求和 123456789101112131415161718#include &lt;iostream&gt;using namespace std;template &lt;typename T&gt;T vsum(const T &amp;t) { return t; }template &lt;typename T, typename ... Args&gt;T vsum(const T &amp;t, const Args&amp;... args) { T sum(0); sum += t; sum += vsum(args...); return sum;}int main(){ cout &lt;&lt; vsum(1,2,3,4) &lt;&lt; endl;} 参考：https://blog.csdn.net/elloop/article/details/50092631 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"C++","slug":"C","permalink":"http://blog.iwxyi.com/tags/C/"}]},{"title":"小顶堆TopN","date":"2019-07-07T12:48:00.000Z","path":"2019/07/07/小顶堆TopN/","text":"应用场景：10亿个数中取前1000大的数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105import java.util.Arrays;public class SmallHeap { /** * &lt;description&gt;获取前N数据&lt;/description&gt; * * @param arr * @param n * @author: ouyp * @since: Seeyon V7.0 SP2 * @date: 2018年10月16日 下午4:52:27 */ public static int[] topN(int[] arr, int n) { /** * 构建堆积 */ int[] list = new int[n]; System.arraycopy(arr, 0, list, 0, n); for (int i = 0; i &lt; n; i++) { int t = i; while (t != 0 &amp;&amp; list[parent(t)] &gt; list[t]) { swap(list, t, t = parent(t)); } } /** * 小顶堆 */ for (int i = n, len = arr.length; i &lt; len; i++) { if (arr[i] &gt;= list[0]) { // 置换栈顶 list[0] = arr[i]; // 调整栈顶 int t = 0; while ((left(t) &lt; n &amp;&amp; list[t] &gt; list[left(t)]) || (right(t) &lt; n &amp;&amp; list[t] &gt; list[right(t)])) { if (right(t) &lt; n &amp;&amp; list[right(t)] &lt; list[left(t)]) { swap(list, t, t = right(t)); } else { swap(list, t, t = left(t)); } } } } return list; } /** * &lt;description&gt;对象交换&lt;/description&gt; * * @param list * @param i * @param j * @author: ouyp * @since: Seeyon V7.0 SP2 * @date: 2018年10月16日 下午4:56:33 */ private static void swap(int[] list, int i, int j) { int tmp = list[i]; list[i] = list[j]; list[j] = tmp; } /** * &lt;description&gt;父节点索引&lt;/description&gt; * * @param i * @return * @author: ouyp * @date: 2018年10月16日 下午3:34:22 */ private static int parent(int i) { return (i - 1) / 2; } /** * &lt;description&gt;左孩子索引&lt;/description&gt; * * @param i * @return * @author: ouyp * @date: 2018年10月16日 下午4:01:30 */ private static int left(int i) { return 2 * i + 1; } /** * &lt;description&gt;右孩子索引&lt;/description&gt; * * @param i * @return * @author: ouyp * @date: 2018年10月16日 下午4:02:04 */ private static int right(int i) { return 2 * i + 2; } public static void main(String[] args) { int[] arr = new int[]{56, 30, 71, 18, 29, 93, 44, 75, 20, 65, 68, 34}; System.out.println(\"原始数组: \"); System.out.println(Arrays.toString(arr)); System.out.println(\"调整后数组: \"); System.out.println(Arrays.toString(SmallHeap.topN(arr, 5))); }} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"算法","slug":"算法","permalink":"http://blog.iwxyi.com/tags/算法/"}]},{"title":"C++调用Python","date":"2019-05-27T05:35:00.000Z","path":"2019/05/27/C-调用Python/","text":"Python代码 1234567891011import fastTextimport jieba# 判断小说类型的调用语句def judge(novel): print(novel, \" : \", classifier.predict(\" \".join(jieba.cut(novel)))) return str(classifier.predict(\" \".join(jieba.cut(novel)))[0][0])# classifier = fastText.train_supervised(\"data/novel_names.txt\", lr=0.1, wordNgrams=1, loss=\"hs\", epoch=20)# model = classifier.save_model(\"data/novel_names.model\")classifier = fastText.load_model(\"data/novel_names.model\") C++代码（Qt为例） 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;QCoreApplication&gt;#include &lt;iostream&gt;#include &lt;Python.h&gt;#include &lt;QDebug&gt;using namespace std;int main(int argc, char *argv[]){ QCoreApplication a(argc, argv); Py_Initialize(); if (!Py_IsInitialized()) { return -1; } PyObject* pModule = PyImport_ImportModule(\"wtnn\"); // 模块名（不带后缀的文件名） if (!pModule) { printf(\"Can't open python file!\\n\"); return -1; } PyObject* pFun = PyObject_GetAttrString(pModule, \"judge\"); // 函数名 if (!pFun) { printf(\"Get function failed\"); return -1; } PyObject* args = Py_BuildValue(\"(s)\", \"测试\"); // 构建参数，为元组形式 PyObject* result = PyObject_CallObject(pFun, args); if (result) { char* str = nullptr; PyArg_Parse(result, \"s\", &amp;str); qDebug() &lt;&lt; str; // 可以直接printf，但是中文乱码，得用qDebug } Py_Finalize(); return a.exec();} pro文件 12INCLUDEPATH += -I C:\\Users\\HP\\AppData\\Local\\Programs\\Python\\Python36\\includeLIBS += -LC:\\Users\\HP\\AppData\\Local\\Programs\\Python\\Python36\\libs -lpython36 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"C++","slug":"C","permalink":"http://blog.iwxyi.com/tags/C/"},{"name":"Python","slug":"Python","permalink":"http://blog.iwxyi.com/tags/Python/"}]},{"title":"FastText心得","date":"2019-05-20T05:36:00.000Z","path":"2019/05/20/FastText心得/","text":"安装方法一：手动安装 下载https://github.com/xiamx/fastText/releases的source code(zip)，解压后打开，输入： 1pip setup.py install 如果缺少什么库（比如pybind11），则用 pip 安装 方法二：PIP 12pip search fasttextpip install fasttext document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Python","slug":"Python","permalink":"http://blog.iwxyi.com/tags/Python/"},{"name":"NLP","slug":"NLP","permalink":"http://blog.iwxyi.com/tags/NLP/"}]},{"title":"Windows下建立Linux子系统","date":"2019-05-19T06:02:00.000Z","path":"2019/05/19/Windows下建立Linux子系统/","text":"在windows开窗口：先打开 xming，再输入： 1DISPLAY=:0 firefox 远程桌面控制：1sudo service xrdp start https://www.cnblogs.com/lihjacky/p/9106202.html 然后通过远程桌面链接到：127.0.0.1:3390 VNC连接：12zshvncserver 打开 VNC Viewer，访问：127.0.0.1:端口号，端口号为 Ubuntu 中的最后一个数字（从1开始，可能递增） http://www.cnblogs.com/kerrycode/p/6055126.html document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Linux","slug":"Linux","permalink":"http://blog.iwxyi.com/tags/Linux/"}]},{"title":"Git用法","date":"2019-05-16T06:01:00.000Z","path":"2019/05/16/Git用法/","text":"Git 用法下载Gitgit-x.x.x-64-bit.exe 下载地址：https://git-scm.com/downloads 一路默认安装 linux下安装：sudo apt-get install git 启动在项目目录中打开 Git Bash 用命令行进行管理 身份 git config --global user.email \"you@example.com\" git config --global user.name \"Your Name\" 上传Git git init git add . （空格和 . ）将文件夹全部内容添加到 git（新文件+修改，不包括删除）git add -A 包括上传删除的文件 git commit -m “提交信息” git remote add origin GitHub项目https地址 连接仓库如果报错（一般是由于在其他设备使用），先使用 git remote rm origin 来清空，再重试 git push -u origin master 上传项目。会弹出窗口输入GitHub账号密码。如果要上传到已存在的仓库，要先使用git pull origin master来同步到本地 更新Git从上面第2点开始，最后一步可以直接 git push SSH连接1ssh-keygen -t rsa -b 4096 -C \"your_email@example.com\" 三下回车，出现图案结果。 复制文件C:/Users/Administrator/.ssh/id_rsa.pub内容，把key添加到：github &gt; settings &gt; SSH and GPG keys &gt; New SSH key &gt; 粘贴保存。 linux在：/home/用户名/.ssh/id_rsa.pub，可用命令行打开 代码回滚 git log # 得到你需要回退一次提交的commit id git reset --hard &lt;commit_id&gt; ``git push origin HEAD –force` # 强制提交一次，之前错误的提交就从远程仓库删除 其他操作多人协作http://www.imooc.com/article/279280 记住密码git config credential.helper store 12345$ git config credential.helper store$ git push https://github.com/owner/repo.git# 然后输入用户名和密码Username for 'https://github.com': &lt;USERNAME&gt;Password for 'https://USERNAME@github.com': &lt;PASSWORD&gt; 更改 commit 信息1git commit --amend -m \"新提交信息\" 漏提交12git add 遗漏文件git commit --amend --no-edit // 表示提交消息不会更改，仅为一次提交 重新提交1git reset // 回退到上一个commit版本 回滚1234567git reset HEAD 文件名 // 取消暂存区的修改git reset --hard 提交ID // 全部回退到指定版本git reset --hard HEAD~1 // 回退一个版本git reset --soft HEAD~1 // 版本库回退一个版本，该版本之后的所有变更进入暂存区 撤销revert 和 reset 的区别：revert 也会作为一次操作进入版本库，reset 直接删除指定 commit 1git revert // 使用新的 commit 来回滚到之前的 commit 删除Repository点开项目–Settings–Delete this repository，会要求输入项目名字来确认删除 强推出了问题，不管三七二十一，强行push 1git push origin master -f 强制下载123git fetch --all git reset --hard origin/mastergit pull Git目录下新增文件在项目根目录直接添加新文件夹好像不会上传 需要手动添加到Git的上传列表里 123git add 文件夹名git commit -m \"\"git push 删除某个文件1git rm -r --cached xxx 再commit和push 其中目录需要强制-r 问题remote origin already exists12$ git remote add origin 项目地址fatal: remote origin already exists. 解决方法： 1git remote rm origin 再重新git remote add origin 项目地址 其实不用管它也没事的…… 多设备提交冲突123456789$ git push -u origin masterTo https://github.com/MRXY001/yunj.git ! [rejected] master -&gt; master (fetch first)error: failed to push some refs to 'https://github.com/MRXY001/yunj.git'hint: Updates were rejected because the remote contains work that you dohint: not have locally. This is usually caused by another repository pushinghint: to the same ref. You may want to first integrate the remote changeshint: (e.g., 'git pull ...') before pushing again.hint: See the 'Note about fast-forwards' in 'git push --help' for details. 让你fetch first就是先git pull 一下 12git fetchgit merge 等同于 1git pull 还是不行的解决办法： 远程分支上存在本地分支中不存在的提交，往往是多人协作开发过程中遇到的问题，可以先fetch再merge，也就是pull，把远程分支上的提交合并到本地分支之后再push。 如果你确定远程分支上那些提交都不需要了，那么直接git push origin master -f，强行让本地分支覆盖远程分支。。。（不建议，会覆盖掉以前的所有 commits） SSH问题12345678910$ git push -u origin masterThe authenticity of host 'github.com (13.229.188.59)' can't be established.RSA key fingerprint is SHA256:nThbg6kXUpJWGl7E1IGOCspRomTxdCARLviKw6E5SY8.Are you sure you want to continue connecting (yes/no)? yesWarning: Permanently added 'github.com,13.229.188.59' (RSA) to the list of known hosts.git@github.com: Permission denied (publickey).fatal: Could not read from remote repository.Please make sure you have the correct access rightsand the repository exists. 解决办法： 需要重新创建SSH 1ssh-keygen -t rsa -C \"wxy19980615@gmail.com\" 把 /c/Users/Administrator/.ssh/id_rsa.pub 文件的内容放到 GitHub/Settings/SSH keys 里面然后再重新执行 git push -u origin master failed to push some refs to ‘origin’意思是本地和远程的文件应该合并后才能上传本地的新文件 12git pull origin mastergit push -u origin master 不匹配12error: src refspec master does not match any.error: failed to push some refs to git commit -m \"xxx\" 重新上传一遍 拒绝合并不相关的历史1fatal: refusing to merge unrelated histories 出现这个问题的最主要原因还是在于本地仓库和远程仓库实际上是独立的两个仓库。假如我之前是直接clone的方式在本地建立起远程github仓库的克隆本地仓库就不会有这问题了。 可以在pull命令后紧接着使用--allow-unrelated-history选项来解决问题（该选项可以合并两个独立启动仓库的历史） 1git pull origin master --allow-unrelated-histories （合并的文件很可能会有问题，需要手动调整） 直接push的话会继续报错：Updates were rejected because the tip of your current branch is behind its remote counterpart. Integrate the remote changes 然后add和commit，最后重新push一遍 Changes not staged for commit:123456789101112131415git commit -m \"更新文件结构\"On branch masterYour branch is up to date with 'origin/master'.Changes not staged for commit: modified: ../README.md deleted: ../picture/result.png deleted: ../qidian_collections.py deleted: ../train.pyUntracked files: ../name_collections.py ../name_train.pyno changes added to commit 解决方法：使用git add -A 进行添加 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"工具","slug":"工具","permalink":"http://blog.iwxyi.com/tags/工具/"}]},{"title":"Python网络爬虫","date":"2019-05-02T05:41:00.000Z","path":"2019/05/02/Python网络爬虫/","text":"一个提取起点小说名称的例子 12345678910111213141516171819202122232425262728# coding: utf-8import urllib.requestimport re# 获取网页源码def get_html(url): page = urllib.request.urlopen(url) _html = page.read() return str(_html, encoding='utf-8')# 保存到文本文件def save_text_file(file_name, contents): with open(file_name, 'w', encoding='utf-8') as f: f.write(contents)# 正则表达式提取数据def get_novel_names(source): return re.findall('&lt;h4&gt;&lt;a href=\"//book.qidian.com/info/\\\\d+\" target=\"_blank\" data-eid=\"qd_C40\" data-bid=\"\\\\d+\"&gt;(.+?)&lt;/a&gt;&lt;/h4&gt;', source)novels = [] # 所有的书名列表for page in range(1, 3): # 遍历2页 html = get_html(\"https://www.qidian.com/rank/fin?chn=21&amp;page=\"+str(page)) novels += get_novel_names(html)save_text_file(\"玄幻.txt\", \"\\n\".join(novels)) 这是最简单的例子，但是连续爬https会遇到报错：http.client.RemoteDisconnected: Remote end closed connection without response。需要加上headers: 123456# 获取网页源码def get_html(url): headers = {'User-Agent': 'User-Agent:Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_3) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/56.0.2924.87 Safari/537.36'} req = urllib.request.Request(url=url, headers=headers) html = urllib.request.urlopen(req) return html.read().decode('utf-8', 'ignore') document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Python","slug":"Python","permalink":"http://blog.iwxyi.com/tags/Python/"}]},{"title":"Jiaba分词","date":"2019-05-02T05:37:00.000Z","path":"2019/05/02/Jiaba分词/","text":"Jieba“结巴”中文分词：做最好的 Python 中文分词组件github : https://github.com/fxsjy/jieba 特点 支持三种分词模式 精确模式，试图将句子最精确地切开，适合文本分析； 全模式，把句子中所有的可以成词的词语都扫描出来, 速度非常快，但是不能解决歧义； 搜索引擎模式，在精确模式的基础上，对长词再次切分，提高召回率，适合用于搜索引擎分词。 支持繁体分词 支持自定义词典 MIT 授权协议 安装代码对 Python 2/3 均兼容 全自动安装：easy_install jieba 或者 pip install jieba / pip3 install jieba 半自动安装：先下载 http://pypi.python.org/pypi/jieba/ ，解压后运行 python setup.py install 手动安装：将 jieba 目录放置于当前目录或者 site-packages 目录 通过 import jieba 来引用 算法 基于前缀词典实现高效的词图扫描，生成句子中汉字所有可能成词情况所构成的有向无环图 (DAG) 采用了动态规划查找最大概率路径, 找出基于词频的最大切分组合 对于未登录词，采用了基于汉字成词能力的 HMM 模型，使用了 Viterbi 算法 主要功能1、分词 jieba.cut 方法接受三个输入参数: 需要分词的字符串；cut_all 参数用来控制是否采用全模式；HMM 参数用来控制是否使用 HMM 模型 jieba.cut_for_search 方法接受两个参数：需要分词的字符串；是否使用 HMM 模型。该方法适合用于搜索引擎构建倒排索引的分词，粒度比较细 待分词的字符串可以是 unicode 或 UTF-8 字符串、GBK 字符串。注意：不建议直接输入 GBK 字符串，可能无法预料地错误解码成 UTF-8 jieba.cut 以及 jieba.cut_for_search 返回的结构都是一个可迭代的 generator，可以使用 for 循环来获得分词后得到的每一个词语(unicode)，或者用 jieba.lcut 以及 jieba.lcut_for_search 直接返回 list jieba.Tokenizer(dictionary=DEFAULT_DICT) 新建自定义分词器，可用于同时使用不同词典。jieba.dt 为默认分词器，所有全局分词相关函数都是该分词器的映射。 代码示例 1234567891011121314# encoding=utf-8import jiebaseg_list = jieba.cut(\"我来到北京清华大学\", cut_all=True)print(\"Full Mode: \" + \"/ \".join(seg_list)) # 全模式seg_list = jieba.cut(\"我来到北京清华大学\", cut_all=False)print(\"Default Mode: \" + \"/ \".join(seg_list)) # 精确模式seg_list = jieba.cut(\"他来到了网易杭研大厦\") # 默认是精确模式print(\", \".join(seg_list))seg_list = jieba.cut_for_search(\"小明硕士毕业于中国科学院计算所，后在日本京都大学深造\") # 搜索引擎模式print(\", \".join(seg_list)) 输出 1234567【全模式】: 我/ 来到/ 北京/ 清华/ 清华大学/ 华大/ 大学【精确模式】: 我/ 来到/ 北京/ 清华大学【新词识别】：他, 来到, 了, 网易, 杭研, 大厦 (此处，“杭研”并没有在词典中，但是也被Viterbi算法识别出来了)【搜索引擎模式】： 小明, 硕士, 毕业, 于, 中国, 科学, 学院, 科学院, 中国科学院, 计算, 计算所, 后, 在, 日本, 京都, 大学, 日本京都大学, 深造 2、添加自定义词典载入词典 开发者可以指定自己自定义的词典，以便包含 jieba 词库里没有的词。虽然 jieba 有新词识别能力，但是自行添加新词可以保证更高的正确率 用法： jieba.load_userdict(file_name) file_name 为文件类对象或自定义词典的路径词典格式和 dict.txt 一样，一个词占一行；每一行分三部分：词语、词频（可省略）、词性（可省略），用空格隔开，顺序不可颠倒。file_name 若为路径或二进制方式打开的文件，则文件必须为 UTF-8 编码。 词频省略时使用自动计算的能保证分出该词的词频。 例如： 1234创新办 3 i云计算 5凱特琳 nz台中 更改分词器（默认为 jieba.dt）的 tmp_dir 和 cache_file 属性，可分别指定缓存文件所在的文件夹及其文件名，用于受限的文件系统。 范例： 自定义词典：https://github.com/fxsjy/jieba/blob/master/test/userdict.txt 用法示例：https://github.com/fxsjy/jieba/blob/master/test/test_userdict.py 之前： 李小福 / 是 / 创新 / 办 / 主任 / 也 / 是 / 云 / 计算 / 方面 / 的 / 专家 / 加载自定义词库后： 李小福 / 是 / 创新办 / 主任 / 也 / 是 / 云计算 / 方面 / 的 / 专家 / 123456789101112131415161718192021222324# encoding=utf-8from __future__ import print_function, unicode_literalsimport sysimport jiebaimport jieba.posseg as psegsys.path.append(\"../\") # 添加当前文件所在目录jieba.load_userdict(\"userdict.txt\") # 和PY文件是同一个目录jieba.add_word('石墨烯')jieba.add_word('凱特琳')jieba.del_word('自定义词')test_sent = ( \"李小福是创新办主任也是云计算方面的专家; 什么是八一双鹿\\n\" \"例如我输入一个带“韩玉赏鉴”的标题，在自定义词库中也增加了此词为N类\\n\" \"「台中」正確應該不會被切開。mac上可分出「石墨烯」；此時又可以分出來凱特琳了。\")words = jieba.cut(test_sent) # 数组，仅分出结果print('/'.join(words))result = pseg.cut(test_sent) # 包括每一个分割词的信息for w in result: print(w.word, \"/\", w.flag, \", \", end=' ') 调整词典 使用 add_word(word, freq=None, tag=None) 和 del_word(word) 可在程序中动态修改词典。 使用 suggest_freq(segment, tune=True) 可调节单个词语的词频，使其能（或不能）被分出来。 注意：自动计算的词频在使用 HMM 新词发现功能时可能无效。 12345678910111213&gt;&gt;&gt; print('/'.join(jieba.cut('如果放到post中将出错。', HMM=False)))如果/放到/post/中将/出错/。&gt;&gt;&gt; jieba.suggest_freq(('中', '将'), True) # 调节为分开 494&gt;&gt;&gt; print('/'.join(jieba.cut('如果放到post中将出错。', HMM=False)))如果/放到/post/中/将/出错/。&gt;&gt;&gt; print('/'.join(jieba.cut('「台中」正确应该不会被切开', HMM=False)))「/台/中/」/正确/应该/不会/被/切开&gt;&gt;&gt; jieba.suggest_freq('台中', True) # 调节为不分开69&gt;&gt;&gt; print('/'.join(jieba.cut('「台中」正确应该不会被切开', HMM=False)))「/台中/」/正确/应该/不会/被/切开 “通过用户自定义词典来增强歧义纠错能力” — https://github.com/fxsjy/jieba/issues/14 参考：https://blog.csdn.net/qq_34337272/article/details/79554772 更多功能与各语言版本请见此博客 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Python","slug":"Python","permalink":"http://blog.iwxyi.com/tags/Python/"},{"name":"NLP","slug":"NLP","permalink":"http://blog.iwxyi.com/tags/NLP/"}]},{"title":"使用Telegram收发微信","date":"2019-04-30T05:58:00.000Z","path":"2019/04/30/使用Telegram收发微信/","text":"介绍发代号 EH Forwarder Bot（简称 EFB）是一个可扩展的聊天平台隧道框架，基于 Python 3。目前已内置了 Telegram 主端 (Master Channel) 和微信从端 (Slave Channel)，用来在 Telegram 收发微信消息。其他从端开发已在计划之中。同时 EFB 也配备了详尽的文档，欢迎有兴趣的朋友们开发自己的主端或从端，来支持更多的平台。EFB 在 GitHub 中开放了源代码，并且在 Read The Docs 平台上发布的开发文档（英文，en-US）。 本文主要介绍了如何在一个虚拟服务器 (VPS) 中安装并配置 EFB、Telegram 主端和微信从端，以及如何使用 Telegram 主端来收发微信消息。 搭建环境服务器系统：CentOS 安装Python3.6123yum install -y https://centos7.iuscommunity.org/ius-release.rpmyum install -y python36u python36u-libs python36u-devel python36u-pip python36u-setuptoolswhich -a python3.6 运行完成后再shell中键入python3.6看能否进入python，如果能则进入下一步，如果显示路径错误则编辑~/bashrc文件vi ~/.bashrc在其中键入python3.6='/usr/bin/python3.6'退出vi编辑器并在shell下键入source ~/.bashrc保存更改 安装非Python依赖项123sudo rpm --import http://li.nux.ro/download/nux/RPM-GPG-KEY-nux.rosudo rpm -Uvh http://li.nux.ro/download/nux/dextop/el7/x86_64/nux-dextop-release-0-5.el7.nux.noarch.rpmyum install -y libwebp-devel file-devel ffmpeg 下载源码并安装1234wget https://codeload.github.com/blueset/ehForwarderBot/tar.gz/v1.6.6tar -xvf v1.6.6cd ehForwarderBot-1.6.6pip3.6 install -r requirements.txt 配置 EFB 接下来就是进行各种必要的配置和初始化的步骤了。 4.1 创建 Telegram BotTelegram Bot 是 EFB（Telegram 主端）的出口，也是呈献给用户的渠道。我们在这里使用了 Telegram 官方的 Bot API，以最大化利用 Telegram Bot 所提供的各种便利功能。 要创建一个新的 Bot，要先向 @BotFather 发起会话。发送指令 /newbot 以启动向导。期间，你需要指定这个 Bot 的名称与用户名（用户名必须以 bot 结尾）。完毕之后 @BotFather 会提供给你一个密钥（Token），妥善保存这个密钥。请注意，为保护您的隐私及信息安全，请不要向任何人提供你的 Bot 用户名及密钥，这可能导致聊天信息泄露等各种风险。 接下来还要对刚刚启用的 Bot 进行进一步的配置：允许 Bot 读取非指令信息、允许将 Bot 添加进群组、以及提供指令列表。 发送 /setprivacy 到 @BotFather，选择刚刚创建好的 Bot 用户名，然后选择 “Disable”. 发送 /setjoingroups 到 @BotFather，选择刚刚创建好的 Bot 用户名，然后选择 “Enable”. 发送 /setcommands 到 @BotFather，选择刚刚创建好的 Bot 用户名，然后发送如下内容： 1234link - 将会话绑定到 Telegram 群组chat - 生成会话头recog - 回复语音消息以进行识别extra - 获取更多功能 然后还需要获取你自己的 Telegram ID，ID 应显示为一串数字。获取你自己的 ID 有很多方式，你可以选择任意一种。下面介绍两种可能的方式。 Plus Messenger如果你使用了 Plus Messenger 作为你的 Telegram 客户端，你可以直接打开你自己的资料页，在「自己」下面会显示你的 ID。 通过 Bot 查询 很多现存的 Bot 也提供了 ID 查询服务，直接向其发送特定的指令即可获得自己的数字 ID。在这里介绍一些接触过的。 123456@get_id_bot 发送 /start@mokubot 发送 /whoami@GroupButler_Bot 发送 /id@jackbot 发送 /me@userinfobot 发送任意文字@orzdigbot 发送 /user 4.2 配置 EFB 和 Telegram 主端这差不多就是安装过程的最后一步了。首先创建存储用文件夹并赋予其权限。回到 VPS 上 ehForwarderBot 目录。（不出意外的话你应该还在这个目录） 12mkdir storagechmod 777 storage 然后复制并编辑配置文件。 123cp config.sample.py config.pyeditor config.py# 其中 editor 是你所喜欢的文本编辑器，比如 vim 则 vim config.py 在配置文件中，token 后引号里面的内容替换为你之前获得的 Bot 密钥，admins 后方括号里面填入你自己的 Telegram ID。后面的 6 行是用来配置语音转文字功能的，不是必要功能，目前可以删除各行。如果有兴趣启用该功能的，请到各平台申请 API keys。详情请参见文档 的「ETM」章节。 参考：https://www.ishare.work/在centos-7下安装并使用-efb：在-telegram-收发微信消息/ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"服务器","slug":"服务器","permalink":"http://blog.iwxyi.com/tags/服务器/"}]},{"title":"CSS样式表大全","date":"2019-04-24T05:02:00.000Z","path":"2019/04/24/CSS样式表大全/","text":"一、CSS文字属性： color : #999999; /文字颜色/ font-family : 宋体,sans-serif; /文字字体/ font-size : 9pt; /文字大小/ font-style:itelic; /文字斜体/ font-variant:small-caps; /小字体/ letter-spacing : 1pt; /字间距离/ line-height : 200%; /设置行高/ font-weight:bold; /文字粗体/ vertical-align:sub; /下标字/ vertical-align:super; /上标字/ text-decoration:line-through; /加删除线/ text-decoration: overline; /加顶线/ text-decoration:underline; /加下划线/ text-decoration:none; /删除链接下划线/ text-transform : capitalize; /首字大写/ text-transform : uppercase; /英文大写/ text-transform : lowercase; /英文小写/ text-align:right; /文字右对齐/ text-align:left; /文字左对齐/ text-align:center; /文字居中对齐/ text-align:justify; /文字分散对齐/ vertical-align属性 vertical-align:top; /垂直向上对齐/ vertical-align:bottom; /垂直向下对齐/ vertical-align:middle; /垂直居中对齐/ vertical-align:text-top; /文字垂直向上对齐/ vertical-align:text-bottom; /文字垂直向下对齐/ 二、CSS边框空白 padding-top:10px; /上边框留空白/ padding-right:10px; /右边框留空白/ padding-bottom:10px; /下边框留空白/ padding-left:10px; /*左边框留空白 三、CSS符号属性 list-style-type:none; /不编号/ list-style-type:decimal; /阿拉伯数字/ list-style-type:lower-roman; /小写罗马数字/ list-style-type:upper-roman; /大写罗马数字/ list-style-type:lower-alpha; /小写英文字母/ list-style-type:upper-alpha; /大写英文字母/ list-style-type:disc; /实心圆形符号/ list-style-type:circle; /空心圆形符号/ list-style-type:square; /实心方形符号/ list-style-image:url(/dot.gif); /图片式符号/ list-style-position: outside; /凸排/ list-style-position:inside; /缩进/ 四、CSS背景样式 background-color:#F5E2EC; /背景颜色/ background:transparent; /透视背景/ background-image : url(/image/bg.gif); /背景图片/ background-attachment : fixed; /浮水印固定背景/ background-repeat : repeat; /重复排列-网页默认/ background-repeat : no-repeat; /不重复排列/ background-repeat : repeat-x; /在x轴重复排列/ background-repeat : repeat-y; /在y轴重复排列/ 指定背景位置 background-position : 90% 90%; /背景图片x与y轴的位置/ background-position : top; /向上对齐/ background-position : buttom; /向下对齐/ background-position : left; /向左对齐/ background-position : right; /向右对齐/ background-position : center; /居中对齐/ 五、CSS连接属性 a /所有超链接/ a:link /超链接文字格式/ a:visited /浏览过的链接文字格式/ a:active /按下链接的格式/ a:hover /鼠标转到链接/ 鼠标光标样式： 链接手指 CURSOR: hand 十字体 cursor:crosshair 箭头朝下 cursor:s-resize 十字箭头 cursor:move 箭头朝右 cursor:move 加一问号 cursor:help 箭头朝左 cursor:w-resize 箭头朝上 cursor:n-resize 箭头朝右上 cursor:ne-resize 箭头朝左上 cursor:nw-resize 文字I型 cursor:text 箭头斜右下 cursor:se-resize 箭头斜左下 cursor:sw-resize 漏斗 cursor:wait 光标图案(IE6) p {cursor:url(“光标文件名.cur”),text;} 六、CSS框线一览表 border-top : 1px solid #6699cc; /上框线/ border-bottom : 1px solid #6699cc; /下框线/ border-left : 1px solid #6699cc; /左框线/ border-right : 1px solid #6699cc; /右框线/ 以上是建议书写方式,但也可以使用常规的方式 如下: border-top-color : #369 /设置上框线top颜色/ border-top-width :1px /设置上框线top宽度/ border-top-style : solid/设置上框线top样式/ 其他框线样式 solid /实线框/ dotted /虚线框/ double /双线框/ groove /立体内凸框/ ridge /立体浮雕框/ inset /凹框/ outset /凸框/ 七、CSS表单运用 文字方块 按钮 复选框 选择钮 多行文字方块 下拉式菜单 选项1选项2 八、CSS边界样式 margin-top:10px; /上边界/ margin-right:10px; /右边界值/ margin-bottom:10px; /下边界值/ margin-left:10px; /左边界值/ 九、CSS滤镜属性Filter：在样式中加上滤镜特效。由于此属性内容比较多，我们将到下一章单独对滤镜介绍。 Alpha：设置透明度Alpha(Opacity=?, FinishOpacity=?, Style=?, StartX=?, StartY=?, FinishX=?, FinishY=?)Opacity：透明度级别，范围是0-100，0代表完全透明，100代表完全不透明。FinishOpacity：设置渐变的透明效果时，用来指定结束时的透明度，范围也是0 到 100。Style：设置渐变透明的样式，值为0代表统一形状、1代表线形、2代表放射状、3代表长方形。StartX和StartY：代表渐变透明效果的开始X和Y坐标。 FinishX和FinishY：代表渐变透明效果结束X和Y 的坐标。 BlendTrans：图像之间的淡入和淡出的效果BlendTrans(Duration=?) Duration：淡入或淡出的时间。注意：这个滤镜必须配合JS建立图片序列，才能做出图片间效果。 Blru：建立模糊效果Blur(Add=?, Direction=?, Strength=?) Add：是否单方向模糊，此参数是一个布尔值，true（非0）或false（0）。 Direction：设置模糊的方向，其中0度代表垂直向上，然后每45度为一个单位。 Strength：代表模糊的象素值。 Chroma：把指定的颜色设置为透明Chroma(Color=?) Color：是指要设置为透明的颜色。 DropShadow：建立阴影效果DropShadow(Color=?, OffX=?, OffY=?, Positive=?) Color：指定阴影的颜色。OffX：指定阴影相对于元素在水平方向偏移量，整数。 OffY：指定阴影相对于元素在垂直方向偏移量，整数。 Positive：是一个布尔值，值为true（非0）时，表示为建立外阴影；为false(0)，表示为建立内阴影。 FlipH：将元素水平反转 FlipV：将元素垂直反转8.Glow：建立外发光效效果Glow(Color=?, Strength=?)Color：是指定发光的颜色。Strength：光的强度，可以是1到255之间的任何整数，数字越大，发光的范围就越大。 Gray：去掉图像的色彩，显示为黑白图象 Invert：反转图象的颜色，产生类似底片的效果 Light：放置光源的效果，可以用来模拟光源在物体上的投影效果 注意：此效果需要用JS设置光的位置和强度。 Mask：建立透明遮罩Mask(Color=?) Color：设置底色，让对象遮住底色的部分透明。 RevealTrans：建立切换效果RevealTrans(Duration=?, Transition=?)Duration：是切换时间，以秒为单位。Transtition：是切换方式，可设置为从0到23。注意：如果做页面间的切换效果，可以在&lt;head&gt;区加上一行代码：&lt;Meta http-equiv=Page-enter content=revealTrans(Transition=?,Duration=?) &gt;。如果用在页面里的元素必须配合JS使用。 Shadow：建立另一种阴影效果 Shadow(Color=?, Direction=?) Color：是指阴影的颜色。Direction：是设置投影的方向，0度代表垂直向上，然后每45度为一个单位。 Wave：波纹效果Wave(Add=?, Freq=?, LightStrength=?, Phase=?, Strength=?) Add：表示是否显示原对象，0表示不显示，非0表示要显示原对象。 Freq：设置波动的个数。LightStrength：设置波浪效果的光照强度，从0到100。0表示最弱，100表示最强。 Phase：波浪的起始相角。从0到100的百分数值。（例如：25相当于90度，而50相当于180度。） Strength：设置波浪摇摆的幅度。 Xray：显现图片的轮廓，X光片效果注意：在使用CSS滤镜时，必须使用在有区域的元素，比如表格，图片等。而文本，段落这样没有区域的元素不能使用CSS滤镜，对这样的元素我们可以设置元素的Height和Width样式或坐标来实现。 样式大全字体属性：(font) 大小 {font-size: x-large;}(特大) xx-small;(极小) 一般中文用不到，只要用数值就可以，单位：PX、PD 样式 {font-style: oblique;}(偏斜体) italic;(斜体) normal;(正常) 行高 {line-height: normal;}(正常) 单位：PX、PD、EM 粗细 {font-weight: bold;}(粗体) lighter;(细体) normal;(正常) 变体 {font-variant: small-caps;}(小型大写字母) normal;(正常) 大小写 {text-transform: capitalize;}(首字母大写) uppercase;(大写) lowercase;(小写) none;(无) 修饰 {text-decoration: underline;}(下划线) overline;(上划线) line-through;(删除线) blink;(闪烁) 常用字体： (font-family)“Courier New”, Courier, monospace, “Times New Roman”, Times, serif, Arial, Helvetica, sans-serif, Verdana 背景属性： (background) 色彩 {background-color: #FFFFFF;} 图片 {background-image: url();} 重复 {background-repeat: no-repeat;} 滚动 {background-attachment: fixed;}(固定) scroll;(滚动) 位置 {background-position: left;}(水平) top(垂直); 简写方法 {background:#000 url(..) repeat fixed left top;} /简写·这个在阅读代码中经常出现，要认真的研究/ 区块属性： (Block) /这个属性第一次认识，要多多研究/ 字间距 {letter-spacing: normal;} 数值 /这个属性似乎有用，多实践下/ 对齐 {text-align: justify;}(两端对齐) left;(左对齐) right;(右对齐) center;(居中) 缩进 {text-indent: 数值px;} 垂直对齐 {vertical-align: baseline;}(基线) sub;(下标) super;(下标) top; text-top; middle; bottom; text-bottom; 词间距word-spacing: normal; 数值 空格white-space: pre;(保留) nowrap;(不换行) 显示 {display:block;}(块) inline;(内嵌) list-item;(列表项) run-in;(追加部分) compact;(紧凑) marker;(标记) table; inline-table; table-raw-group; table-header-group; table-footer-group; table-raw; table-column-group; table-column; table-cell; table-caption;(表格标题) /display 属性的了解很模糊/ 方框属性： (Box) width: height: float: clear:both; margin: padding: 顺序：上右下左 边框属性： (Border) border-style: dotted;(点线) dashed;(虚线) solid; double;(双线) groove;(槽线) ridge;(脊状) inset;(凹陷) outset; border-width:; 边框宽度 border-color:#; 简写方法border：width style color; /简写/ 列表属性： (List-style) 类型list-style-type: disc;(圆点) circle;(圆圈) square;(方块) decimal;(数字) lower-roman;(小罗码数字) upper-roman; lower-alpha; upper-alpha; 位置list-style-position: outside;(外) inside; 图像list-style-image: url(..); 定位属性： (Position) Position: absolute; relative; static; visibility: inherit; visible; hidden; overflow: visible; hidden; scroll; auto; clip: rect(12px,auto,12px,auto) (裁切) css属性代码大全字体样式(Font Style)序号 中文说明 标记语法 字体样式 {font:font-style font-variant font-weight font-size font-family} 字体类型 {font-family:”字体1”,”字体2”,”字体3”,…} 字体大小 {font-size:数值|inherit| medium| large| larger| x-large| xx-large| small| smaller| x-small| xx-small} 字体风格 {font-style:inherit|italic|normal|oblique} 字体粗细 {font-weight:100-900|bold|bolder|lighter|normal;} 字体颜色 {color:数值;} 阴影颜色 {text-shadow:16位色值} 字体行高 {line-height:数值|inherit|normal;} 字 间 距 {letter-spacing:数值|inherit|normal} 单词间距 {word-spacing:数值|inherit|normal} 字体变形 {font-variant:inherit|normal|small-cps } 英文转换 {text-transform:inherit|none|capitalize|uppercase|lowercase} 字体变形 {font-size-adjust:inherit|none} 字体 {font-stretch:condensed|expanded|extra-condensed|extra-expanded|inherit|narrower|normal| semi-condensed|semi-expanded|ultra-condensed|ultra-expanded|wider} 文本样式(Text Style)序号 中文说明 标记语法 行 间 距 {line-height:数值|inherit|normal;} 文本修饰 {text-decoration:inherit|none|underline|overline|line-through|blink} 段首空格 {text-indent:数值|inherit} 水平对齐 {text-align:left|right|center|justify} 垂直对齐 {vertical-align:inherit|top|bottom|text-top|text-bottom|baseline|middle|sub|super} 书写方式 {writing-mode:lr-tb|tb-rl} 背景样式序号 中文说明 标记语法 背景颜色 {background-color:数值} 背景图片 {background-image: url(URL)|none} 背景重复 {background-repeat:inherit|no-repeat|repeat|repeat-x|repeat-y} 背景固定 {background-attachment:fixed|scroll} 背景定位 {background-position:数值|top|bottom|left|right|center} 背影样式 {background:背景颜色|背景图象|背景重复|背景附件|背景位置} 框架样式(Box Style)序号 中文说明 标记语法 边界留白 {margin:margin-top margin-right margin-bottom margin-left} 补 白 {padding:padding-top padding-right padding-bottom padding-left} 边框宽度 {border-width:border-top-width border-right-width border-bottom-width border-left-width} 宽度值： thin|medium|thick|数值 边框颜色 {border-color:数值 数值 数值 数值} 数值：分别代表top、right、bottom、left颜色值 边框风格 {border-style:none|hidden|inherit|dashed|solid|double|inset|outset|ridge|groove} 边 框 {border:border-width border-style color}上 边 框 {border-top:border-top-width border-style color}右 边 框 {border-right:border-right-width border-style color}下 边 框 {border-bottom:border-bottom-width border-style color}左 边 框 {border-left:border-left-width border-style color} 宽 度 {width:长度|百分比| auto} 高 度 {height:数值|auto} 漂 浮 {float:left|right|none} 清 除 {clear:none|left|right|both} 分类列表序号 中文说明 标记语法 控制显示 {display:none|block|inline|list-item} 控制空白 {white-space:normal|pre|nowarp} 符号列表 {list-style-type:disc|circle|square|decimal|lower-roman|upper-roman|lower-alpha|upper-alpha|none} 图形列表 {list-style-image:URL} 位置列表 {list-style-position:inside|outside} 目录列表 {list-style:目录样式类型|目录样式位置|url} 鼠标形状 {cursor:hand|crosshair|text|wait|move|help|e-resize|nw-resize|w-resize|s-resize|se-resize|sw-resize} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"整理","slug":"整理","permalink":"http://blog.iwxyi.com/tags/整理/"},{"name":"CSS","slug":"CSS","permalink":"http://blog.iwxyi.com/tags/CSS/"}]},{"title":"HTML表单即将提交事件","date":"2019-04-20T05:06:00.000Z","path":"2019/04/20/HTML表单即将提交事件/","text":"123456789101112131415&lt;form action=\"insert.php\" onsubmit=\"return onSubmit()\"&gt; &lt;input type=\"text\" name=\"title\" id=\"title\" /&gt;&lt;/form&gt;&lt;script type=\"text/javascript\"&gt; function onSubmit() { if ( $(\"#title\").val(); == \"\" ) { alert(\"请输入标题\"); return false; } return true; }&lt;/script&gt; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"HTML","slug":"HTML","permalink":"http://blog.iwxyi.com/tags/HTML/"},{"name":"JS","slug":"JS","permalink":"http://blog.iwxyi.com/tags/JS/"}]},{"title":"CSS圆角头像","date":"2019-04-20T04:58:00.000Z","path":"2019/04/20/CSS圆角头像/","text":"CSS: 123456789.round_icon{ width: 34px; height: 34px; display: flex; border-radius: 50%; align-items: center; justify-content: center; overflow: hidden;} HTML: 1&lt;img src=\"images/what_ever.jpg\" class=\"round_icon\" /&gt; 参考：https://blog.csdn.net/s1674521/article/details/79731141 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"CSS","slug":"CSS","permalink":"http://blog.iwxyi.com/tags/CSS/"}]},{"title":"C++ new和malloc的10点区别","date":"2019-04-18T00:27:00.000Z","path":"2019/04/18/C-new和malloc的区别/","text":"## 1. 申请的内存所在位置 new操作符从自由存储区（free store）上为对象动态分配内存空间，而malloc函数从堆上动态分配内存。自由存储区是C++基于new操作符的一个抽象概念，凡是通过new操作符进行内存申请，该内存即为自由存储区。而堆是操作系统中的术语，是操作系统所维护的一块特殊内存，用于程序的内存动态分配，C语言使用malloc从堆上分配内存，使用free释放已分配的对应内存。 那么自由存储区是否能够是堆（问题等价于new是否能在堆上动态分配内存），这取决于operator new 的实现细节。自由存储区不仅可以是堆，还可以是静态存储区，这都看operator new在哪里为对象分配内存。 特别的，new甚至可以不为对象分配内存！定位new的功能可以办到这一点： 1new (place_address) type place_address为一个指针，代表一块内存的地址。当使用上面这种仅以一个地址调用new操作符时，new操作符调用特殊的operator new，也就是下面这个版本： 1void * operator new (size_t,void *) //不允许重定义这个版本的operator new 这个operator new不分配任何的内存，它只是简单地返回指针实参，然后右new表达式负责在place_address指定的地址进行对象的初始化工作。 2.返回类型安全性new操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故new是符合类型安全性的操作符。而malloc内存分配成功则是返回void * ，需要通过强制类型转换将void*指针转换成我们需要的类型。类型安全很大程度上可以等价于内存安全，类型安全的代码不会试图方法自己没被授权的内存区域。关于C++的类型安全性可说的又有很多了。 3.内存分配失败时的返回值new内存分配失败时，会抛出bac_alloc异常，它不会返回NULL；malloc分配内存失败时返回NULL。在使用C语言时，我们习惯在malloc分配内存后判断分配是否成功： 123456789int *a = (int *)malloc ( sizeof (int ));if(NULL == a){ ...}else { ...} 从C语言走入C++阵营的新手可能会把这个习惯带入C++： 123456789int * a = new int();if(NULL == a){ ...}else{ ...} 实际上这样做一点意义也没有，因为new根本不会返回NULL，而且程序能够执行到if语句已经说明内存分配成功了，如果失败早就抛异常了。正确的做法应该是使用异常机制： 12345678try{ int *a = new int();}catch (bad_alloc){ ...} 如果你想顺便了解下异常基础，可以看http://www.cnblogs.com/QG-whz/p/5136883.htmlC++ 异常机制分析。 4.是否需要指定内存大小使用new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算，而malloc则需要显式地指出所需内存的尺寸。 123class A{...}A * ptr = new A;A * ptr = (A *)malloc(sizeof(A)); //需要显式指定所需内存大小sizeof(A); 当然了，我这里使用malloc来为我们自定义类型分配内存是不怎么合适的，请看下一条。 5.是否调用构造函数/析构函数使用new操作符来分配对象内存时会经历三个步骤： 第一步：调用operator new 函数（对于数组是operator new[]）分配一块足够大的，原始的，未命名的内存空间以便存储特定类型的对象。 第二步：编译器运行相应的构造函数以构造对象，并为其传入初值。 第三部：对象构造完成后，返回一个指向该对象的指针。 使用delete操作符来释放对象内存时会经历两个步骤： 第一步：调用对象的析构函数。 第二步：编译器调用operator delete(或operator delete[])函数释放内存空间。 总之来说，new/delete会调用对象的构造函数/析构函数以完成对象的构造/析构。而malloc则不会。如果你不嫌啰嗦可以看下我的例子： 12345678910111213class A{public: A() :a(1), b(1.11){}private: int a; double b;};int main(){ A * ptr = (A*)malloc(sizeof(A)); return 0;} 在return处设置断点，观看ptr所指内存的内容： img 可以看出A的默认构造函数并没有被调用，因为数据成员a,b的值并没有得到初始化，这也是上面我为什么说使用malloc/free来处理C++的自定义类型不合适，其实不止自定义类型，标准库中凡是需要构造/析构的类型通通不合适。 而使用new来分配对象时： 1234int main(){ A * ptr = new A;} 查看程序生成的汇编代码可以发现，A的默认构造函数被调用了： img 6.对数组的处理C++提供了new[]与delete[]来专门处理数组类型: 1A * ptr = new A[10];//分配10个A对象 使用new[]分配的内存必须使用delete[]进行释放： 1delete [] ptr; new对数组的支持体现在它会分别调用构造函数函数初始化每一个数组元素，释放对象时为每个对象调用析构函数。注意delete[]要与new[]配套使用，不然会找出数组对象部分释放的现象，造成内存泄漏。 至于malloc，它并知道你在这块内存上要放的数组还是啥别的东西，反正它就给你一块原始的内存，在给你个内存的地址就完事。所以如果要动态分配一个数组的内存，还需要我们手动自定数组的大小： 1int * ptr = (int *) malloc( sizeof(int)* 10 );//分配一个10个int元素的数组 7.new与malloc是否可以相互调用operator new /operator delete的实现可以基于malloc，而malloc的实现不可以去调用new。下面是编写operator new /operator delete 的一种简单方式，其他版本也与之类似： 1234567891011void * operator new (sieze_t size){ if(void * mem = malloc(size) return mem; else throw bad_alloc();}void operator delete(void *mem) noexcept{ free(mem);} 8.是否可以被重载opeartor new /operator delete可以被重载。标准库是定义了operator new函数和operator delete函数的8个重载版本： 12345678910//这些版本可能抛出异常void * operator new(size_t);void * operator new[](size_t);void * operator delete (void * )noexcept;void * operator delete[](void *0）noexcept;//这些版本承诺不抛出异常void * operator new(size_t ,nothrow_t&amp;) noexcept;void * operator new[](size_t, nothrow_t&amp; );void * operator delete (void *,nothrow_t&amp; )noexcept;void * operator delete[](void *0,nothrow_t&amp; ）noexcept; 我们可以自定义上面函数版本中的任意一个，前提是自定义版本必须位于全局作用域或者类作用域中。太细节的东西不在这里讲述，总之，我们知道我们有足够的自由去重载operator new /operator delete ,以决定我们的new与delete如何为对象分配内存，如何回收对象。 而malloc/free并不允许重载。 9. 能够直观地重新分配内存使用malloc分配的内存后，如果在使用过程中发现内存不足，可以使用realloc函数进行内存重新分配实现内存的扩充。realloc先判断当前的指针所指内存是否有足够的连续空间，如果有，原地扩大可分配的内存地址，并且返回原来的地址指针；如果空间不够，先按照新指定的大小分配空间，将原有数据从头到尾拷贝到新分配的内存区域，而后释放原来的内存区域。 new没有这样直观的配套设施来扩充内存。 10. 客户处理内存分配不足在operator new抛出异常以反映一个未获得满足的需求之前，它会先调用一个用户指定的错误处理函数，这就是new-handler。new_handler是一个指针类型： 1234namespace std{ typedef void (*new_handler)();} 指向了一个没有参数没有返回值的函数,即为错误处理函数。为了指定错误处理函数，客户需要调用set_new_handler，这是一个声明于的一个标准库函数: 1234namespace std{ new_handler set_new_handler(new_handler p ) throw();} set_new_handler的参数为new_handler指针，指向了operator new 无法分配足够内存时该调用的函数。其返回值也是个指针，指向set_new_handler被调用前正在执行（但马上就要发生替换）的那个new_handler函数。 对于malloc，客户并不能够去编程决定内存不足以分配时要干什么事，只能看着malloc返回NULL。 总结将上面所述的10点差别整理成表格： 特征 new/delete malloc/free 分配内存的位置 自由存储区 堆 内存分配成功的返回值 完整类型指针 void* 内存分配失败的返回值 默认抛出异常 返回NULL 分配内存的大小 由编译器根据类型计算得出 必须显式指定字节数 处理数组 有处理数组的new版本new[] 需要用户计算数组的大小后进行内存分配 已分配内存的扩充 无法直观地处理 使用realloc简单完成 是否相互调用 可以，看具体的operator new/delete实现 不可调用new 分配内存时内存不足 客户能够指定处理函数或重新制定分配器 无法通过用户代码进行处理 函数重载 允许 不允许 构造函数与析构函数 调用 不调用 malloc给你的就好像一块原始的土地，你要种什么需要自己在土地上来播种 img 而new帮你划好了田地的分块（数组），帮你播了种（构造函数），还提供其他的设施给你使用: img 当然，malloc并不是说比不上new，它们各自有适用的地方。在C++这种偏重OOP的语言，使用new/delete自然是更合适的。 参考：https://www.cnblogs.com/QG-whz/p/5140930.html document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"C++","slug":"C","permalink":"http://blog.iwxyi.com/tags/C/"},{"name":"内存管理","slug":"内存管理","permalink":"http://blog.iwxyi.com/tags/内存管理/"}]},{"title":"公众号token服务器配置","date":"2019-04-14T12:30:00.000Z","path":"2019/04/14/公众号token服务器配置/","text":"修改公众号的服务器配置 Token配置代码，文件放在对应的URL路径下 微信会发送GET请求来验证 12345678910111213141516171819202122232425262728&lt;?phpdefine(\"TOKEN\", \"mrxy\"); // 你自己的Token//验证消息$echoStr = $_GET[\"echostr\"];if(checkSignature()){ echo $echoStr; exit;}//检查签名function checkSignature(){ $signature = $_GET[\"signature\"]; $timestamp = $_GET[\"timestamp\"]; $nonce = $_GET[\"nonce\"]; $token = TOKEN; $tmpArr = array($token, $timestamp, $nonce); sort($tmpArr, SORT_STRING); $tmpStr = implode($tmpArr); $tmpStr = sha1($tmpStr); if($tmpStr == $signature){ return true; }else{ return false; }} 微信授权网页登录：https://www.cnblogs.com/whowhere/p/5787247.html 微信扫码登录：https://www.cnblogs.com/0201zcr/p/5133062.html document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"微信小程序","slug":"微信小程序","permalink":"http://blog.iwxyi.com/tags/微信小程序/"}]},{"title":"Android自定义输入对话框，带联网","date":"2019-03-21T03:36:00.000Z","path":"2019/03/21/Android自定义输入对话框，带联网/","text":"自定义输入方式，回调方法，带输入后联网示例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384 @Overridepublic void onClick(View v) { switch (v.getId()) { case R.id.tv_nickname: inputDialog(\"nickname\", \"修改用户昵称\", User.nickname); break; }}/** * 弹出输入框 * @param aim 目标 * @param title 标题 * @param def 默认值 * @return 输入的字符串 */private String inputDialog(final String aim, String title, String def) { final String[] result = new String[1]; LayoutInflater factory = LayoutInflater.from(PersonActivity.this);//提示框 final View view = factory.inflate(R.layout.edit_box, null);//这里必须是final的 final EditText edit = (EditText) view.findViewById(R.id.editText);//获得输入框对象 edit.setText(def); new AlertDialog.Builder(PersonActivity.this) .setTitle(title)//提示框标题 .setView(view) .setPositiveButton(\"确定\",//提示框的两个按钮 new DialogInterface.OnClickListener() { @Override public void onClick(DialogInterface dialog, int which) { result[0] = edit.getText().toString(); onInputDialog(aim, edit.getText().toString()); } }) .setNegativeButton(\"取消\", null) .create().show(); return result[0];}/** * 输入框结束事件，自定义结果 * @param aim 目标 * @param s 字符串 */private void onInputDialog(String aim, String s) { switch (aim) { case \"nickname\": if (!canMatch(s, \"\\\\S+\")) { App.toast(\"用户名不能有空格\"); return; } mNicknameTv.setText(User.nickname = s); break; } updateContent(aim, s);}/** * 上传用户信息 * @param key 文件名 * @param val 数值 */private void updateContent(final String key, final String val) { String path = Paths.getNetpath(\"updateUserInfo\"); String[] params = new String[]{\"user_id\", User.id(), key, val}; ConnectUtil.Get(path, params, new StringCallback(){ @Override public void onFinish(String result) { if (result.equals(\"OK\")) { Snackbar.make(findViewById(R.id.fab), \"修改成功\", Snackbar.LENGTH_LONG) .setAction(\"Action\", null).show(); } else if (!result.isEmpty()) { Snackbar.make(findViewById(R.id.fab), \"修改失败:\"+ StringUtil.getXml(result, \"result\"), Snackbar.LENGTH_LONG) .setAction(\"Action\", null).show(); } } });}boolean canMatch(String str, String pat) { return StringUtil.canMatch(str, pat);} 布局 edit_box.xml 123456789101112131415&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:orientation=\"vertical\" android:layout_width=\"fill_parent\" android:layout_height=\"fill_parent\"&gt; &lt;EditText android:id=\"@+id/editText\" android:layout_width=\"fill_parent\" android:layout_height=\"wrap_content\"&gt; &lt;requestFocus&gt;&lt;/requestFocus&gt; &lt;/EditText&gt;&lt;/LinearLayout&gt; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Android","slug":"Android","permalink":"http://blog.iwxyi.com/tags/Android/"}]},{"title":"Android状态栏透明","date":"2019-03-21T03:32:00.000Z","path":"2019/03/21/Android状态栏透明/","text":"Java文件： 123456protected void onCreate(Bundle savedInstanceState) { /* ... */ //透明状态栏&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getWindow().addFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS); getWindow().addFlags(WindowManager.LayoutParams.FLAG_TRANSLUCENT_NAVIGATION);} Xml文件： 1android:background=\"@drawable/background\" document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Android","slug":"Android","permalink":"http://blog.iwxyi.com/tags/Android/"}]},{"title":"Android线性时间选择器","date":"2019-03-16T03:24:00.000Z","path":"2019/03/16/Android线性时间选择器/","text":"build.gradle(Module:app) 1implementation 'net.codecrafted:lineartimepicker:1.0.0' // 线性日期时间选择器 日期选择 .java 1234567891011121314151617181920212223boolean data_tutorial = false; // 是否出现使用帮助if (SettingsUtil.getInt(getApplicationContext(), \"LinearDatePicker_tutorial\") != 1) { data_tutorial = true;}LinearDatePickerDialog.Builder.with(RecordActivity.this) .setYear(addYear) .setMinYear(2000) .setMaxYear(2030) .setShowTutorial(data_tutorial) .setButtonCallback(new LinearDatePickerDialog.ButtonCallback() { @Override public void onPositive(DialogInterface dialog, int year, int month, int day) { SettingsUtil.setVal(getApplicationContext(), \"LinearDataPicker_tutorial\", 1); /*...code...*/ } @Override public void onNegative(DialogInterface dialog) { } }) .build() .show(); 时间选择 .java 1234567891011121314151617181920boolean time_tutorial = false;if (SettingsUtil.getInt(getApplicationContext(), \"LinearTimePicker_tutorial\") != 1) { time_tutorial = true;}LinearTimePickerDialog dialog = LinearTimePickerDialog.Builder.with(RecordActivity.this) .setShowTutorial(time_tutorial) .setButtonCallback(new LinearTimePickerDialog.ButtonCallback() { @Override public void onPositive(DialogInterface dialog, int hour, int minutes) { SettingsUtil.setVal(getApplicationContext(), \"LinearDataPicker_tutorial\", 1); /*...code...*/ } @Override public void onNegative(DialogInterface dialog) { } }) .build();dialog.show(); document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Android","slug":"Android","permalink":"http://blog.iwxyi.com/tags/Android/"}]},{"title":"Android简单联网应用","date":"2019-03-16T03:17:00.000Z","path":"2019/03/16/Android简单联网应用/","text":"解决Handler问题 1234567891011121314151617181920212223242526272829static class MyHandler extends Handler { //注意下面的“PopupActivity”类是MyHandler类所在的外部类，即所在的activity WeakReference&lt;PopupActivity&gt; mActivity; MyHandler(PopupActivity activity) { mActivity = new WeakReference&lt;PopupActivity&gt;(activity); } @Override public void handleMessage(Message msg) { PopupActivity theActivity = mActivity.get(); switch (msg.what) { //此处可以根据what的值处理多条信息 case 0x0001: //这里可以改变activity中的UI控件的状态 theActivity.textView.setText(R.string.hello_world); break; } case 0x0002: //这里可以改变activity中的UI控件的状态 theActivity.textView.setText(R.string.welcome); break; /*这里可以有多条要处理信息的操作*/ /*... ...*/ } }}; //实例化一个MyHandler对象MyHandler testHandler = new MyHandler(this); private void test1() { //这里发送了一个空消息，空消息的what值是0x0001 testHandler.sendEmptyMessage(0x0001); } private void test2() { //这里发送了一个空消息，空消息的what值是0x0001 testHandler.sendEmptyMessage(0x0002);} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Android","slug":"Android","permalink":"http://blog.iwxyi.com/tags/Android/"}]},{"title":"Android圆形头像控件","date":"2019-03-07T03:27:00.000Z","path":"2019/03/07/Android圆形头像控件/","text":"自定义控件方式 自定义类：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204import android.content.Context;import android.content.res.TypedArray;import android.graphics.Bitmap;import android.graphics.Canvas;import android.graphics.Paint;import android.graphics.PorterDuff;import android.graphics.PorterDuffXfermode;import android.graphics.Rect;import android.graphics.drawable.BitmapDrawable;import android.graphics.drawable.Drawable;import android.graphics.drawable.NinePatchDrawable;import android.util.AttributeSet;import android.widget.ImageView; import com.iruiyou.pet.R; /** * * @author sgf * 自定义圆形头像 * */public class RoundImageView extends ImageView { private int mBorderThickness = 0; private Context mContext; private int defaultColor = 0xFFFFFFFF; // 外圆边框颜色 private int mBorderOutsideColor = 0; // 内圆边框颜色 private int mBorderInsideColor = 0; // RoundImageView控件默认的长、宽 private int defaultWidth = 0; private int defaultHeight = 0; public RoundImageView(Context context) { super(context); mContext = context; } public RoundImageView(Context context, AttributeSet attrs) { super(context, attrs); mContext = context; // 设置RoundImageView的属性值，比如颜色，宽度等 setRoundImageViewAttributes(attrs); } public RoundImageView(Context context, AttributeSet attrs, int defStyle) { super(context, attrs, defStyle); mContext = context; setRoundImageViewAttributes(attrs); } // 从attr.xml文件中获取属性值，并给RoundImageView设置 private void setRoundImageViewAttributes(AttributeSet attrs) { TypedArray a = mContext.obtainStyledAttributes(attrs, R.styleable.round_image_view); mBorderThickness = a.getDimensionPixelSize( R.styleable.round_image_view_border_width, 0); mBorderOutsideColor = a.getColor( R.styleable.round_image_view_border_outcolor, defaultColor); mBorderInsideColor = a.getColor( R.styleable.round_image_view_border_incolor, defaultColor); a.recycle(); } // 具体解释：比如我自定义一个控件，怎么实现呢，以RoundImageView为例，首先是继承ImageView,然后实现其构造函数，在构造函数中，获取attr中的属性值（再次解释：这里获取的具体的这个属性的值是怎么来的呢？比如颜色和宽度，这个在attr.xml中定义了相关的名字，而在使用RoundImageView的xml布局文件中，我们会设置其值，这里需要用的值，就是从那里设置的），并设置在本控件中，然后继承onDraw方法，画出自己想要的图形或者形状即可 /** * 这个是继承的父类的onDraw方法 * * onDraw和下面的方法不用管，基本和学习自定义没关系，就是实现怎么画圆的，你可以改变下面代码试着画三角形头像，哈哈 */ @Override protected void onDraw(Canvas canvas) { Drawable drawable = getDrawable(); if (drawable == null) { return; } if (getWidth() == 0 || getHeight() == 0) { return; } this.measure(0, 0); if (drawable.getClass() == NinePatchDrawable.class) return; Bitmap b = ((BitmapDrawable) drawable).getBitmap(); Bitmap bitmap = b.copy(Bitmap.Config.ARGB_8888, true); if (defaultWidth == 0) { defaultWidth = getWidth(); } if (defaultHeight == 0) { defaultHeight = getHeight(); } int radius = 0; // 这里的判断是如果内圆和外圆设置的颜色值不为空且不是默认颜色，就定义画两个圆框，分别为内圆和外圆边框 if (mBorderInsideColor != defaultColor &amp;&amp; mBorderOutsideColor != defaultColor) { radius = (defaultWidth &lt; defaultHeight ? defaultWidth : defaultHeight) / 2 - 2 * mBorderThickness; // 画内圆 drawCircleBorder(canvas, radius + mBorderThickness / 2, mBorderInsideColor); // 画外圆 drawCircleBorder(canvas, radius + mBorderThickness + mBorderThickness / 2, mBorderOutsideColor); } else if (mBorderInsideColor != defaultColor &amp;&amp; mBorderOutsideColor == defaultColor) {// 这里的是如果内圆边框不为空且颜色值不是默认值，就画一个内圆的边框 radius = (defaultWidth &lt; defaultHeight ? defaultWidth : defaultHeight) / 2 - mBorderThickness; drawCircleBorder(canvas, radius + mBorderThickness / 2, mBorderInsideColor); } else if (mBorderInsideColor == defaultColor &amp;&amp; mBorderOutsideColor != defaultColor) {// 这里的是如果外圆边框不为空且颜色值不是默认值，就画一个外圆的边框 radius = (defaultWidth &lt; defaultHeight ? defaultWidth : defaultHeight) / 2 - mBorderThickness; drawCircleBorder(canvas, radius + mBorderThickness / 2, mBorderOutsideColor); } else {// 这种情况是没有设置属性颜色的情况下，即没有边框的情况 radius = (defaultWidth &lt; defaultHeight ? defaultWidth : defaultHeight) / 2; } Bitmap roundBitmap = getCroppedRoundBitmap(bitmap, radius); canvas.drawBitmap(roundBitmap, defaultWidth / 2 - radius, defaultHeight / 2 - radius, null); } /** * 获取裁剪后的圆形图片 * * @param bmp * @param radius * 半径 * @return */ public Bitmap getCroppedRoundBitmap(Bitmap bmp, int radius) { Bitmap scaledSrcBmp; int diameter = radius * 2; // 为了防止宽高不相等，造成圆形图片变形，因此截取长方形中处于中间位置最大的正方形图片 int bmpWidth = bmp.getWidth(); int bmpHeight = bmp.getHeight(); int squareWidth = 0, squareHeight = 0; int x = 0, y = 0; Bitmap squareBitmap; if (bmpHeight &gt; bmpWidth) {// 高大于宽 squareWidth = squareHeight = bmpWidth; x = 0; y = (bmpHeight - bmpWidth) / 2; // 截取正方形图片 squareBitmap = Bitmap.createBitmap(bmp, x, y, squareWidth, squareHeight); } else if (bmpHeight &lt; bmpWidth) {// 宽大于高 squareWidth = squareHeight = bmpHeight; x = (bmpWidth - bmpHeight) / 2; y = 0; squareBitmap = Bitmap.createBitmap(bmp, x, y, squareWidth, squareHeight); } else { squareBitmap = bmp; } if (squareBitmap.getWidth() != diameter || squareBitmap.getHeight() != diameter) { scaledSrcBmp = Bitmap.createScaledBitmap(squareBitmap, diameter, diameter, true); } else { scaledSrcBmp = squareBitmap; } Bitmap output = Bitmap.createBitmap(scaledSrcBmp.getWidth(), scaledSrcBmp.getHeight(), Bitmap.Config.ARGB_8888); Canvas canvas = new Canvas(output); Paint paint = new Paint(); Rect rect = new Rect(0, 0, scaledSrcBmp.getWidth(), scaledSrcBmp.getHeight()); paint.setAntiAlias(true); paint.setFilterBitmap(true); paint.setDither(true); canvas.drawARGB(0, 0, 0, 0); canvas.drawCircle(scaledSrcBmp.getWidth() / 2, scaledSrcBmp.getHeight() / 2, scaledSrcBmp.getWidth() / 2, paint); paint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.SRC_IN)); canvas.drawBitmap(scaledSrcBmp, rect, rect, paint); bmp = null; squareBitmap = null; scaledSrcBmp = null; return output; } /** * 画边缘的圆，即内圆或者外圆 */ private void drawCircleBorder(Canvas canvas, int radius, int color) { Paint paint = new Paint(); /* 去锯齿 */ paint.setAntiAlias(true); paint.setFilterBitmap(true); paint.setDither(true); paint.setColor(color); /* 设置paint的 style 为STROKE：空心 */ paint.setStyle(Paint.Style.STROKE); /* 设置paint的外框宽度 */ paint.setStrokeWidth(mBorderThickness); canvas.drawCircle(defaultWidth / 2, defaultHeight / 2, radius, paint); }} 属性文件12345678910&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;resources&gt; &lt;declare-styleable name=\"round_image_view\"&gt; &lt;attr name=\"border_width\" format=\"dimension\" /&gt; &lt;attr name=\"border_incolor\" format=\"color\" /&gt; &lt;attr name=\"border_outcolor\" format=\"color\"&gt;&lt;/attr&gt; &lt;/declare-styleable&gt; &lt;/resources&gt; 用法：123456789101112&lt;com.iruiyou.pet.utils.RoundImageView android:id=\"@+id/headIv\" android:layout_width=\"125dp\" android:layout_height=\"125dp\" android:layout_marginTop=\"92dp\" android:src=\"@drawable/head_home\" loonggg:border_incolor=\"#000fff\" loonggg:border_outcolor=\"#fff000\" loonggg:border_width=\"10dp\" app:layout_constraintLeft_toLeftOf=\"parent\" app:layout_constraintRight_toRightOf=\"parent\" app:layout_constraintTop_toTopOf=\"parent\"/&gt; 使用开源库见下方网页 参考：https://blog.csdn.net/shenggaofei/article/details/83793536 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Android","slug":"Android","permalink":"http://blog.iwxyi.com/tags/Android/"}]},{"title":"Java Lambda表达式简写","date":"2019-02-28T05:11:00.000Z","path":"2019/02/28/Java-Lambda表达式简写/","text":"1、取代匿名内部类无参函数简写如果需要新建一个线程，一种常见的写法是这样： 1234567// JDK7 匿名内部类写法new Thread(new Runnable(){// 接口名 @Override public void run(){// 方法名 System.out.println(\"Thread run()\"); }}).start(); 使用lambda进行无参函数的简写： 1234// JDK8 Lambda表达式写法new Thread( () -&gt; System.out.println(\"Thread run()\")// 省略接口名和方法名).start(); 如果函数体有多行，可以用大括号括起来: 123456new Thread( () -&gt; { System.out.print(\"Hello\"); System.out.println(\" Hoolee\"); }).start(); 有参函数简写如果要给一个字符串列表通过自定义比较器，按照字符串长度进行排序，Java 7的书写形式如下： 123456789101112// JDK7 匿名内部类写法List&lt;String&gt; list = Arrays.asList(\"I\", \"love\", \"you\", \"too\");Collections.sort(list, new Comparator&lt;String&gt;(){// 接口名 @Override public int compare(String s1, String s2){// 方法名 if(s1 == null) return -1; if(s2 == null) return 1; return s1.length()-s2.length(); }}); 上述代码通过内部类重载了Comparator接口的compare()方法，实现比较逻辑。采用Lambda表达式可简写如下： 123456789// JDK8 Lambda表达式写法List&lt;String&gt; list = Arrays.asList(\"I\", \"love\", \"you\", \"too\");Collections.sort(list, (s1, s2) -&gt;{// 省略参数表的类型 if(s1 == null) return -1; if(s2 == null) return 1; return s1.length()-s2.length();}); 自定义函数接口自定义函数接口很容易，只需要编写一个只有一个抽象方法的接口即可。 12345// 自定义函数接口@FunctionalInterfacepublic interface ConsumerInterface&lt;T&gt;{ void accept(T t);} 上面代码中的@FunctionalInterface是可选的，但加上该标注编译器会帮你检查接口是否符合函数接口规范。就像加入@Override标注会检查是否重载了函数一样。 有了上述接口定义，就可以写出类似如下的代码： 1ConsumerInterface&lt;String&gt; consumer = str -&gt; System.out.println(str); 进一步的，还可以这样使用： 1234567891011class MyStream&lt;T&gt;{ private List&lt;T&gt; list; ... public void myForEach(ConsumerInterface&lt;T&gt; consumer){// 1 for(T t : list){ consumer.accept(t); } }}MyStream&lt;String&gt; stream = new MyStream&lt;String&gt;();stream.myForEach(str -&gt; System.out.println(str));// 使用自定义函数接口书写Lambda表达式 参考：https://www.cnblogs.com/CarpenterLee/p/5978721.html document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Lambda","slug":"Lambda","permalink":"http://blog.iwxyi.com/tags/Lambda/"},{"name":"Java","slug":"Java","permalink":"http://blog.iwxyi.com/tags/Java/"}]},{"title":"C++ generate生成","date":"2019-02-27T23:51:00.000Z","path":"2019/02/28/C-generate生成/","text":"根据首地址和尾地址来赋值： 123456template&lt;class ForwardIterator, class Generator&gt;void generate( ForwardIterator _First, ForwardIterator _Last, Generator _Gen); 每次调用该对象，函数为范围的每个元素调用，且不需要返回相同的值。例如，从文件读取或引用和修改本地状态。 生成器的结果类型必须可转换为可用于向前迭代器类型的值范围的。 示例： 1234567891011121314151617#include &lt;vector&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;ostream&gt;int main( ){ using namespace std; vector &lt;int&gt; v1 ( 5 ); vector &lt;int&gt;::iterator Iter1; generate ( v1.begin ( ), v1.end ( ) , rand ); for ( Iter1 = v1.begin( ) ; Iter1 != v1.end( ) ; Iter1++ ) cout &lt;&lt; *Iter1 &lt;&lt; \" \";} // 根据首地址和元素数量来赋值 template&lt;class OutputIterator, class Diff, class Generator&gt; void generate_n( OutputIterator First, Diff Count, Generator Gen); 参见：VS2015https://msdn.microsoft.com/zh-cn/library/46h7chx6.aspx document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"C++","slug":"C","permalink":"http://blog.iwxyi.com/tags/C/"}]},{"title":"Android选取相册图片并压缩","date":"2019-02-27T03:25:00.000Z","path":"2019/02/27/Android选取相册图片并压缩/","text":"现在手机中相机的像素越来越高因,手机照的相片就越来越来大, 我们想通过选择相册中图片来显示在界面中,或者进行分享. 因为图片太大的原因很容易造成手机出现OMM而崩溃,一些分享照片的平台对分享图片的大小也有一定的限制.所以我们就必须对从相册选出来的图片进行压缩. 选取图片1234567891011121314151617181920212223242526/** * 打开系统相册 */public void openAlbum(){ Intent intent = new Intent(Intent.ACTION_GET_CONTENT); intent.setType(\"image/*\"); //设置请求码，以便我们区分返回的数据 startActivityForResult(intent, 100);} @Overrideprotected void onActivityResult(int requestCode, int resultCode, Intent data) { if (100 == requestCode) { if (data != null) { //获取数据、获取内容解析者对象 try { Bitmap mBitmap = BitmapFactory.decodeStream( getContentResolver().openInputStream(data.getData())); imageview.setImageBitmap(mBitmap); } catch (FileNotFoundException e) { e.printStackTrace(); } } }} 压缩打开的图片下面看具体代码: 1234567891011121314151617181920212223242526272829303132333435/** * 计算位图的采样比例大小 * @param options * @param imageView 控件(根据控件的大小进行压缩) * @return */ private static int calculatInSampleSize(BitmapFactory.Options options, ImageView imageView) { //获取位图的原宽高 final int w = options.outWidth; final int h = options.outHeight; if (imageView!=null){ //获取控件的宽高 final int reqWidth = imageView.getWidth(); final int reqHeight = imageView.getHeight(); //默认为一(就是不压缩) int inSampleSize = 1; //如果原图的宽高比需要的图片宽高大 if (w &gt; reqWidth || h &gt; reqHeight) { if (w &gt; h) { inSampleSize = Math.round((float) h / (float) reqHeight); } else { inSampleSize = Math.round((float) w / (float) reqWidth); } } System.out.println(\"压缩比为:\" + inSampleSize); return inSampleSize; }else { return 1; } } 这里是对图像压缩比的计算,因为我项目的原因,所以我的压缩比计算是通过传入的ImageView的宽高来计算的,如果想根据自己设置的宽高来压缩只要把,传入的参数:ImageView imageView，改成int width,int height 然后再修改方法中相应的代码即可! 这个方法在很多博客中也提到过… 1234567891011121314151617181920212223242526272829303132/** * 将Uri转换成Bitmap * @param context * @param uri * @param options * @return */ public static Bitmap decodeBitmap(Context context, Uri uri, BitmapFactory.Options options) { Bitmap bitmap = null; if (uri != null) { ContentResolver cr = context.getContentResolver(); InputStream inputStream = null; try { /** * 将图片的Uri地址转换成一个输入流 */ inputStream = cr.openInputStream(uri); /** * 将输入流转换成Bitmap */ bitmap = BitmapFactory.decodeStream(inputStream, null, options); assert inputStream != null; inputStream.close(); } catch (Exception e) { e.printStackTrace(); } } return bitmap; } 这个方法是将将Uri地址转换成一个Bitmap. 因为我们从相册选择图片后会在 OnActivityResult返回一个Intent对象data,我们通过这个 data的getdata()方法就可以得到一个Uri 地址… 然后就是最后一个方法了 1234567891011121314151617181920212223/** * 对图片进行重新采样 * @param context * @param uri 图片的Uri地址 * @param imageView * @return */ public static Bitmap compressBitmap(Context context, Uri uri, ImageView imageView) { BitmapFactory.Options options = new BitmapFactory.Options(); options.inJustDecodeBounds = false; decodeBitmap(context, uri, options); options = new BitmapFactory.Options(); options.inSampleSize = calculatInSampleSize(options, imageView); Bitmap bitmap = null; try { bitmap = decodeBitmap(context, uri, options); } catch (Exception e) { e.printStackTrace(); } return bitmap; } 这个方法是将得到Bitmap 通过计算出来的压缩比 进行重新采样返回一个压缩后的Bitmap对象!,也是我们最终调用的方法,方法简单不必多说! 具体使用:把上面的代码写在一个工具类中,然后在需要使用的地方调用 compressBitmap()即可! 1234567891011if (requestCode == GALLERY_REQUEST_CODE) {//是否是从图库返回 try { Uri originalUri = data.getData(); // 获得图片的uri //对图片进行压缩 Bitmap bitmap = BitmapCompress.compressBitmap(getActivity(),originalUri,ivpapers); ivpapers.setImageBitmap(bitmap); System.out.println(\"压缩后图片的高度:\"+bitmap.getHeight()); System.out.println(\"压缩后图片的宽度:\"+bitmap.getWidth()); } catch (Exception e) { e.printStackTrace(); } 博参考：https://blog.csdn.net/qq_23179075/article/details/52261588 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Android","slug":"Android","permalink":"http://blog.iwxyi.com/tags/Android/"}]},{"title":"Android双指触摸放大图片","date":"2019-02-26T03:23:00.000Z","path":"2019/02/26/Android双指触摸放大图片/","text":"View.OnTouchListener，MotionEvent.ACTION_POINTER_DOWN、MotionEvent.ACTION_MOVE 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103package com.tongzhen.magnify_test;import android.app.Activity;import android.graphics.Matrix;import android.graphics.PointF;import android.os.Bundle;import android.view.MotionEvent;import android.view.View;import android.widget.ImageView;public class MainActivity extends Activity implements View.OnTouchListener { private ImageView img; // 縮放控制 private Matrix savedMatrix = new Matrix(); // 保存按下时的状态 private Matrix matrix = new Matrix(); // 每次和按下的状态进行比较 // 不同状态的表示： private static final int NONE = 0; private static final int DRAG = 1; private static final int ZOOM = 2; private int mode = NONE; // 定义第一个按下的点，两只接触点的中点，以及两指按下的距离： private PointF startPoint = new PointF(); private PointF midPoint = new PointF(); private float oriDis = 1f; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); img = (ImageView) this.findViewById(R.id.main_imgZooming); img.setOnTouchListener(this); } // 计算两个触摸点之间的距离 private float distance(MotionEvent event) { float x = event.getX(0) - event.getX(1); float y = event.getY(0) - event.getY(1); return Float.valueOf(String.valueOf(Math.sqrt(x * x + y * y))) ; } // 计算两个触摸点的中点 private PointF middle(MotionEvent event) { float x = event.getX(0) + event.getX(1); float y = event.getY(0) + event.getY(1); return new PointF(x / 2, y / 2); } @Override public boolean onTouch(View v, MotionEvent event) { if (v == img) { ImageView view = (ImageView) v; switch (event.getAction() &amp; MotionEvent.ACTION_MASK) { // 单指按下 case MotionEvent.ACTION_DOWN: matrix.set(view.getImageMatrix()); savedMatrix.set(matrix); startPoint.set(event.getX(), event.getY()); mode = DRAG; break; // 双指按下 case MotionEvent.ACTION_POINTER_DOWN: oriDis = distance(event); if (oriDis &gt; 10f) { savedMatrix.set(matrix); midPoint = middle(event); mode = ZOOM; } break; // 手指放开 case MotionEvent.ACTION_UP: case MotionEvent.ACTION_POINTER_UP: mode = NONE; break; // 单指滑动事件 case MotionEvent.ACTION_MOVE: if (mode == DRAG) { // 是一个手指拖动 matrix.set(savedMatrix); matrix.postTranslate(event.getX() - startPoint.x, event.getY() - startPoint.y); } else if (mode == ZOOM) { // 两个手指滑动 float newDist = distance(event); if (newDist &gt; 10f) { matrix.set(savedMatrix); float scale = newDist / oriDis; // 压缩比例 matrix.postScale(scale, scale, midPoint.x, midPoint.y); } } break; default : break; } // 设置ImageView的Matrix view.setImageMatrix(matrix); } return true; }} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Android","slug":"Android","permalink":"http://blog.iwxyi.com/tags/Android/"}]},{"title":"Android动态创建控件","date":"2019-02-26T03:09:00.000Z","path":"2019/02/26/Android动态创建控件/","text":"动态创建绝对布局的控件12345678void initView() { TextView tv = new TextView(this); tv.setText(\"TextView的内容\"); AbsoluteLayout.LayoutParams lp1 = new AbsoluteLayout.LayoutParams( ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT, 0,100); absoluteLayout.addView(tv, lp1); //tv.layout(100, 100, 100, 100);} 如果原来是 LinearLayout 等布局，则可以嵌套在一个 AbsoluteLayout 中 控件移动直接 layout 方法就可以，但是有些不能这样移动，于是要用到 LayoutParams： 123// 动态创建AbsoluteLayout.LayoutParams lp = new AbsoluteLayout.LayoutParams( ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT, 0,100); 1234LayoutParams layoutParams=tv.getLayoutParams();layoutParams.height=x;layoutParams.width=y;tv.setLayoutParams(layoutParams); 来个复杂一点的网上找的野教程 12345678910111213141516171819202122232425262728293031323334353637public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); &nbsp; //设置界面的布局 RelativeLayout relativeLayout = new RelativeLayout(this); setContentView(relativeLayout); &nbsp; //添加一个AbsoluteLayout子布局,并给这个布局添加一个button AbsoluteLayout abslayout = new AbsoluteLayout (this); abslayout.setId(11); Buttonbtn1 = new Button(this); btn1.setText(”thisis a abslayout button”); btn1.setId(1); AbsoluteLayout.LayoutParams lp0 = new AbsoluteLayout.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT, 100, 0); abslayout.addView(btn1, lp0 ); //将这个子布局添加到主布局中 RelativeLayout.LayoutParams lp1 = new RelativeLayout.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT); lp1.addRule(RelativeLayout.ALIGN_PARENT_TOP); lp1.addRule(RelativeLayout.CENTER_HORIZONTAL, RelativeLayout.TRUE); relativeLayout.addView(abslayout , lp1); &nbsp; //再添加一个子布局 RelativeLayout relativeLayout1 = new RelativeLayout(this); Button btn2 = newButton(this); btn2.setText(”thisis a relativeLayout1 button”); btn2.setId(2); RelativeLayout.LayoutParams lp2 = new RelativeLayout.LayoutParams(ViewGroup.LayoutParams.FILL_PARENT, ViewGroup.LayoutParams.WRAP_CONTENT); lp2.addRule(RelativeLayout.ALIGN_PARENT_TOP); lp2.addRule(RelativeLayout.CENTER_HORIZONTAL, RelativeLayout.TRUE); relativeLayout1.addView(btn2 , lp2); &nbsp; //将这个布局添加到主布局中 RelativeLayout.LayoutParams lp11 = new RelativeLayout.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT); lp11.addRule(RelativeLayout.BELOW , 11); relativeLayout.addView(relativeLayout1 , lp11);} 以上代码执行的操作是： 创建一个RelativeLayout relativeLayou创建一个AbsoluteLayout abslayout创建一个Button btn1把btn1添加到abslayout中，然后再把abslayout添加到relativeLayout中然后又创建了一个RelativeLayout relativeLayout1在创建一个Button btn2把btn2添加到relativeLayout1上最后把relativeLayout1添加到了relativeLayout document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Android","slug":"Android","permalink":"http://blog.iwxyi.com/tags/Android/"}]},{"title":"Android等待对话框","date":"2019-02-23T03:06:00.000Z","path":"2019/02/23/Android等待对话框/","text":"导入包(自动) 1import android.app.ProgressDialog; 声明全局变量 1private ProgressDialog progressDialog; 显示对话框 1progressDialog = ProgressDialog.show(this, \"请稍等\", \"正在登录\", true, false); 关闭对话框 12if (progressDialog != null) progressDialog.dismiss(); document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Android","slug":"Android","permalink":"http://blog.iwxyi.com/tags/Android/"}]},{"title":"Android Toast获取全局上下文的静态方法","date":"2019-02-21T02:57:00.000Z","path":"2019/02/21/Android-Toast获取全局上下文的静态方法/","text":"用这个方法，toast即可全局使用…… 因为发现 Log 有时候会打印不出来（强转或出错），所以就改用 toast 在Android的清单文件做如下申明： 123&lt;application android:name=\"com.xyz.MyApplication\"&gt; ...&lt;/application&gt; 然后写这个类： 12345678910111213public class MyApplication extends Application{ private static Context context; public void onCreate(){ super.onCreate(); MyApplication.context = getApplicationContext(); } public static Context getAppContext() { return MyApplication.context; } } 调用MyApplication.getAppContext()来静态的获取你应用程序的context。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Android","slug":"Android","permalink":"http://blog.iwxyi.com/tags/Android/"}]},{"title":"Android List BaseAdapter","date":"2019-02-20T02:50:00.000Z","path":"2019/02/20/Android-List-BaseAdapter/","text":"BaseAdapter 12345678910111213141516171819202122232425262728293031323334353637383940414243public class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); ListView lv = findViewById(R.id.lv); lv.setAdapter(new MyListAdapter()); // 设置 数据适配器 } // 实现 BaseAdapter 方法 private class MyListAdapter extends BaseAdapter { @Override public int getCount() { return 4; } @Override public Object getItem(int position) { return null; } @Override public long getItemId(int position) { return 0; } @Override public View getView(int position, View convertView, ViewGroup parent) { TextView tv; if (convertView == null) { tv = new TextView(MainActivity.this); } else { tv = (TextView) convertView; } tv.setText(\"索引：\" + position); return tv; } }} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Android","slug":"Android","permalink":"http://blog.iwxyi.com/tags/Android/"}]},{"title":"Android项目精简","date":"2019-02-15T02:37:00.000Z","path":"2019/02/15/Android项目精简/","text":"Build –&gt; Clean Project 可以清理出很大一部分的空间 手动删除以下文件或者目录 Dir : ProjectFolder/build Dir : ProjectFolder/app/build Dir : ProjectFolder/.gradle Dir : ProjectFolder/.idea Dir : ProjectFolder/captures File : ProjectFolder/*.iml File : ProjectFolder/local.properties File : ProjectFolder/.DS_Store File : ProjectFolder/.externalNativeBuild document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Android","slug":"Android","permalink":"http://blog.iwxyi.com/tags/Android/"},{"name":"项目管理","slug":"项目管理","permalink":"http://blog.iwxyi.com/tags/项目管理/"}]},{"title":"Android PopupMenu弹出菜单","date":"2019-02-14T02:52:00.000Z","path":"2019/02/14/Android-PopupMenu弹出菜单/","text":"菜单文件 12345678910&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;menu xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;item android:id=\"@+id/exit\" android:title=\"退出\"/&gt; &lt;item android:id=\"@+id/set\" android:title=\"设置\"/&gt; &lt;item android:id=\"@+id/account\" android:title=\"账号\"/&gt;&lt;/menu&gt; 代码文件 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162package com.example.menutest03;import android.app.Activity;import android.os.Bundle;import android.view.MenuInflater;import android.view.MenuItem;import android.view.View;import android.view.View.OnClickListener;import android.widget.Button;import android.widget.PopupMenu;import android.widget.PopupMenu.OnMenuItemClickListener;import android.widget.Toast;public class MainActivity extends Activity implements OnClickListener,OnMenuItemClickListener{ private Button button1; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); button1 = (Button)findViewById(R.id.button1); button1.setOnClickListener(this); } //点击按钮后，加载弹出式菜单 @Override public void onClick(View v) { //创建弹出式菜单对象（最低版本11） PopupMenu popup = new PopupMenu(this, v);//第二个参数是绑定的那个view //获取菜单填充器 MenuInflater inflater = popup.getMenuInflater(); //填充菜单 inflater.inflate(R.menu.main, popup.getMenu()); //绑定菜单项的点击事件 popup.setOnMenuItemClickListener(this); //显示(这一行代码不要忘记了) popup.show(); } //弹出式菜单的单击事件处理 @Override public boolean onMenuItemClick(MenuItem item) { // TODO Auto-generated method stub switch (item.getItemId()) { case R.id.exit: Toast.makeText(this, \"退出\", Toast.LENGTH_SHORT).show(); break; case R.id.set: Toast.makeText(this, \"设置\", Toast.LENGTH_SHORT).show(); break; case R.id.account: Toast.makeText(this, \"账号\", Toast.LENGTH_SHORT).show(); break; default: break; } return false; } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Android","slug":"Android","permalink":"http://blog.iwxyi.com/tags/Android/"}]},{"title":"Android带数据切换Activity","date":"2019-02-11T03:05:00.000Z","path":"2019/02/11/Android带数据切换Activity/","text":"当前 Activity 传递数据12345Intent activity_change= new Intent(Activityanother.this, MainActivity.class); //切换 Activityanother至MainActivityBundle bundle = new Bundle();// 创建Bundle对象bundle.putInt(\"data\",data );// 放入data值为int型activity_change.putExtras(bundle);// 将Bundle对象放入到Intent上startActivity(activity_change);// 开始跳转 如果要是 不是int型可以自己put可种类型有很多种put 另一个 Activity读取数据12Intent intent = getIntent();data= intent.getExtras().get(\"data\"); 注意别忘了在 AndroidManifest 中声明 activity document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Android","slug":"Android","permalink":"http://blog.iwxyi.com/tags/Android/"}]},{"title":"Android Spinner用法","date":"2019-02-11T02:56:00.000Z","path":"2019/02/11/Android-Spinner用法/","text":"常用属性: 12345android:spinnerMode //显示模式 :dropdown和dialog两种android:dropDownWidth=\"230dp\"//显示弹出框的宽度android:popupBackground=\"#66ccff\"//显示弹出框的背景颜色android:entries=\"@array/week\"//添加XML布局android:prompt //当显示模式为dialog时生效,作用为显示dialog的标题内容 android:prompt 属性使用常见问题: 设置之后不起作用:prompt属性只有在dialog状态才有用，所以要在xml中，将style设置为Widget.Spinner prompt属性要用string下资源，不支持字符直接输入，否则会报错误 两种写法XML文件中设置数据源 123456789&lt;Spinner android:id=\"@+id/spinner_arrays\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_marginBottom=\"50dp\" android:dropDownWidth=\"230dp\" android:entries=\"@array/week\" android:popupBackground=\"#66ccff\" android:spinnerMode=\"dropdown\"&gt;&lt;/Spinner&gt; values/arrays.xml文件 123456789101112&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;resources&gt; &lt;string-array name=\"week\"&gt; &lt;item &gt;星期一&lt;/item&gt; &lt;item &gt;星期二&lt;/item&gt; &lt;item &gt;星期三&lt;/item&gt; &lt;item &gt;星期四&lt;/item&gt; &lt;item &gt;星期五&lt;/item&gt; &lt;item &gt;星期六&lt;/item&gt; &lt;item &gt;星期天&lt;/item&gt; &lt;/string-array&gt;&lt;/resources&gt; 代码中设置数据源 12345&lt;Spinner android:id=\"@+id/spinner_code\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:spinnerMode=\"dropdown\"&gt;&lt;/Spinner&gt; 1234567891011121314151617codeSp = (Spinner) findViewById(R.id.spinner_code);final String[] arr={\"深圳\",\"上海\",\"北京\",\"山西\"};//创建ArrayAdapter对象ArrayAdapter&lt;String&gt; adapter=new ArrayAdapter&lt;String&gt;(this,android.R.layout.simple_list_item_multiple_choice,arr);codeSp.setAdapter(adapter);/**选项选择监听*/codeSp.setOnItemSelectedListener(new AdapterView.OnItemSelectedListener() { @Override public void onItemSelected(AdapterView&lt;?&gt; parent, View view, int position, long id) { Toast.makeText(SpinnerTestActivity.this, \"点击了\" + arr[position], Toast.LENGTH_SHORT).show(); } @Override public void onNothingSelected(AdapterView&lt;?&gt; parent) { }}); document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Android","slug":"Android","permalink":"http://blog.iwxyi.com/tags/Android/"}]},{"title":"搭建SSR","date":"2019-02-04T05:53:00.000Z","path":"2019/02/04/搭建SSR/","text":"一键搭建 1234567891011wget -N --no-check-certificate https://raw.githubusercontent.com/ToyoDAdoubi/doubi/master/ssrmu.sh &amp;&amp; chmod +x ssrmu.sh &amp;&amp; bash ssrmu.sh1102n5n 手动搭建SSR12yum -y install wgetwget -N --no-check-certificate https://softs.fun/Bash/ssr.sh &amp;&amp; chmod +x ssr.sh &amp;&amp; bash ssr.sh 备用下载地址1wget -N --no-check-certificate https://raw.githubusercontent.com/ToyoDAdoubi/doubi/master/ssrmu.sh &amp;&amp; chmod +x ssrmu.sh &amp;&amp; bash ssrmu.sh 启动1bash ssr.sh 谷歌BBR加速1234yum -y install wgetwget --no-check-certificate https://github.com/teddysun/across/raw/master/bbr.shchmod +x bbr.sh./bbr.sh document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"服务器","slug":"服务器","permalink":"http://blog.iwxyi.com/tags/服务器/"}]},{"title":"ASP.NET文件操作","date":"2019-01-24T13:09:00.000Z","path":"2019/01/24/ASP-NET文件操作/","text":"以文件为例,如果对文件夹操作,基本上将File换为Directory即可(例:FileInfo file = new FileInfo(Path);与DirectoryInfo directory = new DirectoryInfo (Path);) 1获取文件信息 在知道文件相对路径的情形,下面代码可以获取文件的详细信息 12345678910public static void fileinfo(string Path){ Path = Server.MapPath(Path);//获取文件的物理路径 FileInfo file = new FileInfo(Path);//实例该路径文件信息 var length=file.Length;//文件大小,字节 var name = file.Name;//文件名 var fullname = file.FullName;//文件路径 var extension = file.Extension;//文件后缀名 ......} 获取的信息还有创建时间,最后访问时间等等,可以自行研究 2新建文件 新建一个文件。（Create 后会一直占用，最好加上 Dispose） 123456789101112public static void NewFile(string filePath){ filePath=Server.MapPath(filePath);//获取想创建文件的物理路径 if (System.IO.File.Exists(newfilepath)) { //判断新建的文件是否已经存在 throw new Exception(\"文件已经存在\") } System.IO.File.Create(newfilepath);//创建 ......} 3复制文件,移动(剪切)文件,重命名文件 复制文件: 123456789101112public static void Copy(string Path,string targetPath){ Path = Server.MapPath(Path);//原文件的物理路径 targetPath = Server.MapPath(targetPath);//复制到的新位置物理路径 //判断到的新地址是否存在重命名文件 if (System.IO.File.Exists(targetPath)) { throw new Exception(\"存在同名文件\");//抛出异常 } System.IO.File.Copy(Path,targetPath);//复制到新位置,不允许覆盖现有文件 .......} 移动文件,重命名: 12345678910111213public static void MoveOrRename(string Path,string targetPath){ Path = Server.MapPath(Path);//原文件的物理路径 targetPath = Server.MapPath(targetPath);//移动到的新位置的物理路径(如果还是当前文件夹,则会重命名文件) //判断到的新地址是否存在重命名文件 if (System.IO.File.Exists(targetPath)) { //判断是新位置是否存在同名(判断重命名是狗和其他文件冲突) throw new Exception(\"已经存在同名文件\"); } System.IO.File.Move(Path,targetPath);//2个文件在不同目录则是移动,如果在相同目录下则是重命名 ......} 复制文件不会删除,移动或者重命名(方法相同,就是目标位置不同)会删除原文件. 4上传文件 12345678910111213141516171819[HttpPost]//通过Post请求接收前台传来的文件数据public ActionResult UploadFile(string dirPath){ var filepath = Server.MapPath(Path);//获取上传的文件存入目录的物理路径 var file = Request.Files[\"file\"];//获取文件内容 if (file == null || file.ContentLength == 0) { throw new Exception(\"文件不存在\");//简单判断下文件 } var newfilepath = Server.MapPath(dirPath + \"\\\\\" + file.FileName);//获取文件名的物理路径 //判断要上传的文件是否与目录中的文件重命名 if (System.IO.File.Exists(newfilepath)) { throw new Exception(\"文件不存在\");//简单判断下文件是否存在 } //文件存放到指定的文件中 ; file.SaveAs(newfilepath); ......} 会自动创建存有该类容和命名的文件,不用多此一举去创建一个新文件再放入内容. 5遍历当前目录和其子目录所有文件 12345678910111213141516171819202122232425262728293031private static string[] GetFiles(string dir, string regexPattern = null, bool recurse = true, bool throwEx = false){ //recurse:是否递归 //throwEx:是否报出异常 List&lt;string&gt; lst = new List&lt;string&gt;(); try { foreach (string item in Directory.GetFileSystemEntries(dir)) { try { bool isFile = (System.IO.File.GetAttributes(item) &amp; FileAttributes.Directory) != FileAttributes.Directory; if (isFile &amp;&amp; (regexPattern == null || Regex.IsMatch(Path.GetFileName(item), regexPattern, RegexOptions.IgnoreCase | RegexOptions.Multiline))) { lst.Add(item); } //递归 if (recurse &amp;&amp; !isFile) { lst.AddRange(GetFiles(item, regexPattern, true)); } } catch { if (throwEx) { throw; } } } } catch { if (throwEx) { throw; } } return lst.ToArray();} 这个不多说,网上找到的代码,亲测有效 System.IO.File.Create 不会自动释放，一定要Dispose这样会导致W3P进程一直占用这个文件 System.IO.File.Create(HttpContext.Current.Server.MapPath(strName)); 最好加上Dispose() System.IO.File.Create(HttpContext.Current.Server.MapPath(strName)).Dispose(); document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"ASP.NET","slug":"ASP-NET","permalink":"http://blog.iwxyi.com/tags/ASP-NET/"},{"name":"文件","slug":"文件","permalink":"http://blog.iwxyi.com/tags/文件/"}]},{"title":"Android ToggleButton开关设置图片","date":"2019-01-18T02:58:00.000Z","path":"2019/01/18/Android-ToggleButton开关设置图片/","text":"图片设置开关 准备开关不同状态的两张图片放入drawable中。 xml文件中添加代码： 12345678910&lt;ToggleButton android:id=\"@+id/switch1\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_gravity=\"center\" android:background=\"@android:color/transparent\" android:button=\"@drawable/btn_backgrounds\" android:checked=\"false\" android:textOff=\"\" android:textOn=\"\" /&gt; 123456android:button=\"@drawable/btn_backgrounds\"是自己定义的android selector文件：&lt;selector xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;item android:state_checked=\"true\" android:drawable=\"@drawable/toggle_btn_on\" /&gt; &lt;item android:drawable=\"@drawable/toggle_btn_off\" /&gt;&lt;/selector&gt; 之后在java文件中声明ToggleButton控件并且实例化，添加点击事件： 1234567891011121314151617/** * 自己出创建的内部类，监听按钮点击事件 * * @author cyf * */class MyOnCheckedChangeListener implements OnCheckedChangeListener { @Override public void onCheckedChanged(CompoundButton arg0, boolean arg1) { if (arg1) { // 开 } else { // 关 } }} 添加监听： 1switch1.setOnCheckedChangeListener((OnCheckedChangeListener) new MyOnCheckedChangeListener()); 参考：https://www.cnblogs.com/yunfang/p/5485390.html 自定义动画Github 项目地址：https://github.com/xiaosong520/SwitchButtonDemo.git 步骤： 1.创建SwitchButton类添加到自己的项目中： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304/** * @TODO&lt;自定义选择开关按钮&gt; * @author 小嵩 * @date 2016-8-5 09:57:29 */public class SwitchButton extends View{ /** 圆角大小*/ private float radius; /** 开启颜色*/ private int onColor = Color.parseColor(\"#4ebb7f\"); /** 关闭颜色*/ private int offBorderColor = Color.parseColor(\"#dadbda\"); /** 灰色带颜色*/ private int offColor = Color.parseColor(\"#ffffff\"); /** 手柄颜色*/ private int spotColor = Color.parseColor(\"#ffffff\"); /** 边框颜色*/ private int borderColor = offBorderColor; /** 画笔*/ private Paint paint ; /** 开关状态*/ private boolean toggleOn = false; /** 边框大小*/ private int borderWidth = 2; /** 垂直中心*/ private float centerY; /** 按钮的开始和结束位置*/ private float startX, endX; /** 手柄X位置的最小和最大值*/ private float spotMinX, spotMaxX; /**手柄大小 */ private int spotSize ; /** 手柄X位置*/ private float spotX; /** 关闭时内部灰色带高度*/ private float offLineWidth; /** */ private RectF rect = new RectF(); /** 默认使用动画*/ private boolean defaultAnimate = true; private OnToggleChanged listener; private SwitchButton(Context context) { super(context); } public SwitchButton(Context context, AttributeSet attrs, int defStyleAttr) { super(context, attrs, defStyleAttr); setup(attrs); } public SwitchButton(Context context, AttributeSet attrs) { super(context, attrs); setup(attrs); } public void setup(AttributeSet attrs) { paint = new Paint(Paint.ANTI_ALIAS_FLAG); paint.setStyle(Style.FILL); paint.setStrokeCap(Cap.ROUND); this.setOnClickListener(new OnClickListener() { @Override public void onClick(View arg0) { toggle(defaultAnimate); } }); TypedArray typedArray = getContext().obtainStyledAttributes(attrs, R.styleable.SwitchButton); offBorderColor = typedArray.getColor(R.styleable.SwitchButton_offBorderColor, offBorderColor); onColor = typedArray.getColor(R.styleable.SwitchButton_onColor, onColor); spotColor = typedArray.getColor(R.styleable.SwitchButton_spotColor, spotColor); offColor = typedArray.getColor(R.styleable.SwitchButton_offColor, offColor); borderWidth = typedArray.getDimensionPixelSize(R.styleable.SwitchButton_borderWidth, borderWidth); defaultAnimate = typedArray.getBoolean(R.styleable.SwitchButton_animate, defaultAnimate); typedArray.recycle(); borderColor = offBorderColor; } public void toggle() { toggle(true); } public void toggle(boolean animate) { toggleOn = !toggleOn; takeEffect(animate); if(listener != null){ listener.onToggle(toggleOn); } } public void toggleOn() { setToggleOn(); if(listener != null){ listener.onToggle(toggleOn); } } public void toggleOff() { setToggleOff(); if(listener != null){ listener.onToggle(toggleOn); } } /** * 设置显示成打开样式，不会触发toggle事件 */ public void setToggleOn() { setToggleOn(true); } /** * @param animate */ public void setToggleOn(boolean animate){ toggleOn = true; takeEffect(animate); } /** * 设置显示成关闭样式，不会触发toggle事件 */ public void setToggleOff() { setToggleOff(true); } public void setToggleOff(boolean animate) { toggleOn = false; takeEffect(animate); } private void takeEffect(boolean animate) { if(animate){ slide(); }else{ calculateEffect(toggleOn ? 1 : 0); } } @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) { final int widthMode = MeasureSpec.getMode(widthMeasureSpec); final int heightMode = MeasureSpec.getMode(heightMeasureSpec); int widthSize = MeasureSpec.getSize(widthMeasureSpec); int heightSize = MeasureSpec.getSize(heightMeasureSpec); Resources r = Resources.getSystem(); if(widthMode == MeasureSpec.UNSPECIFIED || widthMode == MeasureSpec.AT_MOST){ widthSize = (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, 50, r.getDisplayMetrics()); widthMeasureSpec = MeasureSpec.makeMeasureSpec(widthSize, MeasureSpec.EXACTLY); } if(heightMode == MeasureSpec.UNSPECIFIED || heightSize == MeasureSpec.AT_MOST){ heightSize = (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, 30, r.getDisplayMetrics()); heightMeasureSpec = MeasureSpec.makeMeasureSpec(heightSize, MeasureSpec.EXACTLY); } super.onMeasure(widthMeasureSpec, heightMeasureSpec); } @Override protected void onLayout(boolean changed, int left, int top, int right, int bottom) { super.onLayout(changed, left, top, right, bottom); final int width = getWidth(); final int height = getHeight(); radius = Math.min(width, height) * 0.5f; centerY = radius; startX = radius; endX = width - radius; spotMinX = startX + borderWidth; spotMaxX = endX - borderWidth; spotSize = height - 4 * borderWidth; spotX = toggleOn ? spotMaxX : spotMinX; offLineWidth = 0; } private void slide(){ Animation animation = new Animation() { @Override protected void applyTransformation(float interpolatedTime, Transformation t) { if(toggleOn){ calculateEffect(interpolatedTime); }else{ calculateEffect(1-interpolatedTime); } } }; animation.setDuration(200); clearAnimation(); startAnimation(animation); } private int clamp(int value, int low, int high) { return Math.min(Math.max(value, low), high); } @Override public void draw(Canvas canvas) { // rect.set(0, 0, getWidth(), getHeight()); paint.setColor(borderColor); canvas.drawRoundRect(rect, radius, radius, paint); if(offLineWidth &gt; 0){ final float cy = offLineWidth * 0.5f; rect.set(spotX - cy, centerY - cy, endX + cy, centerY + cy); paint.setColor(offColor); canvas.drawRoundRect(rect, cy, cy, paint); } rect.set(spotX - 1 - radius, centerY - radius, spotX + 1.1f + radius, centerY + radius); paint.setColor(borderColor); canvas.drawRoundRect(rect, radius, radius, paint); final float spotR = spotSize * 0.5f; rect.set(spotX - spotR, centerY - spotR, spotX + spotR, centerY + spotR); paint.setColor(spotColor); canvas.drawRoundRect(rect, spotR, spotR, paint); } /** * @param value */ private void calculateEffect(final double value) { final float mapToggleX = (float) mapValueFromRangeToRange(value, 0, 1, spotMinX, spotMaxX); spotX = mapToggleX; float mapOffLineWidth = (float) mapValueFromRangeToRange(1 - value, 0, 1, 10, spotSize); offLineWidth = mapOffLineWidth; final int fb = Color.blue(onColor); final int fr = Color.red(onColor); final int fg = Color.green(onColor); final int tb = Color.blue(offBorderColor); final int tr = Color.red(offBorderColor); final int tg = Color.green(offBorderColor); int sb = (int) mapValueFromRangeToRange(1 - value, 0, 1, fb, tb); int sr = (int) mapValueFromRangeToRange(1 - value, 0, 1, fr, tr); int sg = (int) mapValueFromRangeToRange(1 - value, 0, 1, fg, tg); sb = clamp(sb, 0, 255); sr = clamp(sr, 0, 255); sg = clamp(sg, 0, 255); borderColor = Color.rgb(sr, sg, sb); postInvalidate(); } public interface OnToggleChanged{ /** * @param on */ public void onToggle(boolean on); } public void setOnToggleChanged(OnToggleChanged onToggleChanged) { listener = onToggleChanged; } public boolean isAnimate() { return defaultAnimate; } public void setAnimate(boolean animate) { this.defaultAnimate = animate; } /** * Map a value within a given range to another range. * @param value the value to map * @param fromLow the low end of the range the value is within * @param fromHigh the high end of the range the value is within * @param toLow the low end of the range to map to * @param toHigh the high end of the range to map to * @return the mapped value */ public static double mapValueFromRangeToRange( double value, double fromLow, double fromHigh, double toLow, double toHigh) { double fromRangeSize = fromHigh - fromLow; double toRangeSize = toHigh - toLow; double valueScale = (value - fromLow) / fromRangeSize; return toLow + (valueScale * toRangeSize); }} 2.在项目res - values目录下 - 找到 attrs.xml 文件，在resource中间添加如下代码：（文件名好像无所谓） 1234567891011121314151617&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;resources&gt; &lt;declare-styleable name=\"SwitchButton\"&gt; &lt;attr name=\"borderWidth\" format=\"dimension\"&gt; &lt;/attr&gt; &lt;attr name=\"offBorderColor\" format=\"reference|color\"&gt; &lt;/attr&gt; &lt;attr name=\"offColor\" format=\"reference|color\"&gt; &lt;/attr&gt; &lt;attr name=\"onColor\" format=\"reference|color\"&gt; &lt;/attr&gt; &lt;attr name=\"spotColor\" format=\"reference|color\"&gt; &lt;/attr&gt; &lt;attr name=\"animate\" format=\"reference|boolean\"&gt; &lt;/attr&gt; &lt;/declare-styleable&gt;&lt;/resources&gt; 以及 colors.xml 文件： 123456&lt;!-- 白色 --&gt;&lt;color name=\"common_white\"&gt;#FFFFFF&lt;/color&gt;&lt;!-- 浅灰色 --&gt;&lt;color name=\"light_gray\"&gt;#DDDDDD&lt;/color&gt;&lt;!-- 浅蓝色 --&gt;&lt;color name=\"common_light_blue\"&gt;#039AE3&lt;/color&gt; 3.在XML布局文件中使用控件（路径引用需改成SwitchButton类所在目录）： 1234567891011&lt;com.yourpath.SwitchButton android:id=\"@+id/switchButton\" android:layout_width=\"45dp\" android:layout_height=\"25dp\" app:borderWidth=\"0.8dp\" app:offBorderColor=\"@color/light_gray\" app:offColor=\"@color/common_white\" app:onColor=\"@color/common_light_blue\" app:spotColor=\"@color/common_white\" app:animate=\"true\" android:layout_margin=\"20dp\" /&gt; 控件的属性介绍： borderWidth 描边宽度 offBorderColor 关闭状态下描边的颜色 offColor 关闭状态的颜色 onColor 打开状态的颜色 spotColor 控件中间的圆点的颜色 animate 是否打开动画效果 4.在Activity中使用： 4.1绑定控件：如果使用ButterKinfe库的话： 1@Bind(R.id.switchButton) SwitchButton switchButton; findViewById的方式: 1SwitchButton switchButton = (SwitchButton)findViewById(R.id.switchButton); 4.2使用控件： 12345678switchButton.setToggleOn(false);//默认打开。如果参数传false,则打开页面初始化时不会有动画效果(改变状态还是会有动画) switchButton.setOnToggleChanged(new SwitchButton.OnToggleChanged(){ @Override public void onToggle(boolean isOn) { //处理自己的逻辑 showToast( \"SwitchButton\"+isOn); } }); 参考：https://blog.csdn.net/qq_22393017/article/details/52198453 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Android","slug":"Android","permalink":"http://blog.iwxyi.com/tags/Android/"}]},{"title":"ASP.NET-学习笔记","date":"2019-01-15T13:11:00.000Z","path":"2019/01/15/ASP-NET-学习笔记/","text":"ASP.NET 简介ASP.NET 是新一代的 ASP。它无法兼容经典 ASP，但 ASP.NET 可以引用 ASP。 ASP.NET 页面需要编译，因此比经典 ASP 更快。 ASP.NET 拥有更好的语言支持，大量用户控件，基于 XML 的组件，以及对用户认证的整合。 ASP.NET 页面的扩展名是 .aspx，通常由 VB (Visual Basic) 或 C# (C sharp) 编写。 ASP.NET 中的用户控件可以通过不同的语言进行编写，包括 C++ 和 Java。 当浏览器请求 ASP.NET 文件时，ASP.NET 引擎读取该文件，编译并执行文件中的脚本，然后以纯 HTML 向浏览器返回结果。 扩展名 ASP 文件的文件扩展名是 .asp ASP.NET 文件的文件扩展名是 .aspx ASP.NET 文件使用 C# 语法的文件扩展名是 .cshtml ASP.NET 文件使用 Razor VB 语法的文件扩展名是 .vbhtml WP 教程Web Pages 是三种 ASP.NET 编程模型中的一种，用于创建 ASP.NET 网站和 web 应用程序。 其他两种编程模型是 Web Forms 和 MVC (Model, View, Controller)。 Web Pages 是最简单的 ASP.NET 网页开发编程模型。它提供了一种简单的方法将 HTML、CSS、JavaScript 以及服务器代码结合起来。 WP Razor Razor 是一种向网页添加基于服务器的代码的标记语法 Razor 拥有传统 ASP.NET 标记的能力，但是更易学习，更易使用 Razor 是一种类似 ASP 和 PHP 的服务器端标记语法 Razor 支持 C# 和 Visual Basic 编程语言 1&lt;p&gt;The time is @DateTime.Now&lt;/p&gt; 包含常规的 HTML 标记，此外还包含：由 @ 标记的 Razor 代码。 C# 的主要 Razor 语法规则 Razor 代码块由 @{ … } 包围 行内表达式（变量和函数）以 @ 开始 代码语句以分号结束 变量通过 var 关键词进行声明 字符串用引用来包围 C# 代码对大小写敏感 C# 文件的扩展名是 .cshtml 实例 12345678910111213&lt;!-- 单行代码块 --&gt;@{ var myMessage = \"Hello World\"; }&lt;!-- 行内表达式或变量 --&gt;&lt;p&gt;The value of myMessage is: @myMessage&lt;/p&gt; &lt;!-- 多行代码块 --&gt;@{var greeting = \"Welcome to our site!\";var weekDay = DateTime.Now.DayOfWeek;var greetingMessage = greeting + \" Today is: \" + weekDay;}&lt;p&gt;The greeting is: @greetingMessage&lt;/p&gt; VB 的主要 Razor 语法规则 Razor 代码块由 @Code … End 包围 行内表达式（变量和函数）以 @ 开始 变量通过 Dim 关键词进行声明 字符串用引用来包围 C# 代码对大小写不敏感 C# 文件的扩展名是 .vbhtml 实例 1234567891011121314&lt;!-- 单行代码块 --&gt;@Code dim myMessage = \"Hello World\" End Code &lt;!-- 行内表达式或变量 --&gt;&lt;p&gt;The value of myMessage is: @myMessage&lt;/p&gt; &lt;!-- 多行代码块 --&gt;@Codedim greeting = \"Welcome to our site!\" dim weekDay = DateTime.Now.DayOfWeek dim greetingMessage = greeting &amp; \" Today is: \" &amp; weekDayEnd Code &lt;p&gt;The greeting is: @greetingMessage&lt;/p&gt; WP 布局###内容快 使用 @RenderPage() 方法从不同的文件导入内容。 内容块（来自另一个文件）能够被输入网页中的任意位置，并可包含文本、标记和代码，就像任何常规的网页那样。 12345678&lt;html&gt;&lt;body&gt; @RenderPage(\"header.cshtml\") &lt;h1&gt;Hello Web Pages&lt;/h1&gt; &lt;p&gt;This is a paragraph&lt;/p&gt; @RenderPage(\"footer.cshtml\")&lt;/body&gt;&lt;/html&gt; 布局页面创建一致外观的另一种方法是使用布局网页。布局网页包含网页的结构，而不是内容。当网页（内容页）链接到布局页时，它会根据布局页（模板）来显示。 布局页类似普通的网页，但是会在引用内容页的位置调用 @RenderBody() 方法。 每个内容页必须以 Layout 指令开头。 布局网页：Layout.cshtml 1234567&lt;html&gt;&lt;body&gt; &lt;p&gt;This is header text&lt;/p&gt; @RenderBody() &lt;p&gt;© 2012 W3School. All rights reserved.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 任意网页：（被包含在布局网页中） 123456789@{Layout=\"Layout.cshtml\";}&lt;h1&gt;Welcome to W3Schools&lt;/h1&gt;&lt;p&gt;Lorem ipsum dolor sit amet, consectetur adipisicing elit,sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laborisnisi ut aliquip ex ea commodo consequat.&lt;/p&gt; 防止代码泄露名称以下划线开头的文件无法通过 web 来浏览。 隐藏敏感信息（数据库密码、电邮密码等）的常用方法是把这些信息保存在名为 “_AppStart” 的独立文件中 _AppStart.cshtml1234567@{ WebMail.SmtpServer = \"mailserver.example.com\"; WebMail.EnableSsl = true; WebMail.UserName = \"username@example.com\"; WebMail.Password = \"your-password\"; WebMail.From = \"your-name-here@example.com\";} WP 文件夹ASP.NET 网页的典型文件夹结构： “Account” 文件夹包含登录和安全文件 “App_Data” 文件包含数据库和数据文件 “Images” 文件夹包含图片 “Scripts” 文件夹包含浏览器脚本 “Shared” 文件夹包含通用文件（比如布局和样式文件） 物理文件结构类似：C:\\Johnny\\Documents\\MyWebSites\\Demo\\Images URL 和路径URL 用于从 web 访问文件： http://www.w3school.com.cn/html5/html5_intro.asp URL 在服务器上对应的文件是： C:\\MyWebSites\\htm5\\html5_intro.asp 1234URL http://www.w3school.com.cn/html/html5_intro.asp服务器名 w3school虚拟路径 /html/html5_intro.asp物理路径 C:\\MyWebSites\\w3school\\/html/html5_intro.asp ~ 操作符如需在编程代码中规定虚拟根目录，请使用 ~ 操作符。 如果您使用 ~ 操作符，而不是路径，就能够在不改变任何代码的情况下，将网站移动到不同的文件夹或位置： 12var myImagesFolder = \"~/images\";var myStyleSheet = \"~/styles/StyleSheet.css\"; Server.MapPath 方法Server.MapPath 方法将虚拟路径 (/default.cshtml) 转换为服务器能够理解的物理路径 (C:\\Johnny\\MyWebSited\\Demo\\default.cshtml)。 当需要打开位于服务器上的数据文件时，您就会用到该方法（数据文件只能通过完整的物理路径来访问）： 12var pathName = \"~/dataFile.txt\";var fileName = Server.MapPath(pathName); Href 方法Href 方法把代码中的路径转换为浏览器能够理解的路径（浏览器无法理解 ~ 操作符）。 您使用 Href 方法来创建指向资源（比如图片和 CSS 文件）的路径。 您会经常在 HTML 、&lt;a&gt;、&lt;img&gt; 以及 &lt;link&gt; 元素中用到该方法： 123456@{var myStyleSheet = \"~/Shared/Site.css\";}&lt;!-- 创建指向 CSS 文件的链接 --&gt;&lt;link rel=\"stylesheet\" type=\"text/css\" href=\"@Href(myStyleSheet)\" /&gt;&lt;!-- 同上 : --&gt; WP 全局Web 启动之前：_AppStart假如站点根目录中名为 _AppStart 的页面存在，ASP.NET 会在站点内的任何页面被请求之前首先运行这个页面。 通常 _AppStart 用于启动代码和全局值的初始化，比如计数器和全局名称。 注释 1：_AppStart 的文件扩展名应与网页相同，比如 _AppStart.cshtml。 注释 2：_AppStart 有下划线前缀。正因如此，用户才无法直接查看该文件 每张页面之前：_PageStart就像在站点启动前运行 _AppStart 那样，您能够在每个文件夹中的任意页面之前运行代码。 对于 web 中的每个文件夹，您能够添加名为 _PageStart 的文件。 通常 _PageStart 用于设置文件夹中所有页面的布局文件，或者在运行页面之前检查用户登录。 当请求到来时，ASP.NET 检查 _AppStart 是否存在。如果存在，并且这是对站点的第一次请求，则运行 _AppStart。 然后 ASP.NET 检查 _PageStart 是否存在。如果存在，则运行 _PageStart，在被请求的页面之前。 如果您在 _PageStart 内部引用了对 RunPage() 的调用，那么您可以规定在何处运行被请求的页面。否则，_PageStart 在被请求页面之前运行。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"ASP.NET","slug":"ASP-NET","permalink":"http://blog.iwxyi.com/tags/ASP-NET/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://blog.iwxyi.com/tags/学习笔记/"}]},{"title":"Spring框架入门-学习笔记","date":"2019-01-13T05:23:00.000Z","path":"2019/01/13/Spring框架入门/","text":"介绍 Spring框架是个轻量级的Java EE框架。所谓轻量级，是指不依赖于容器就能运行的。Struts、Hibernate也是轻量级的。 Spring以IoC、AOP为主要思想，其中IoC，Inversion of Control 指控制反转或反向控制。在Spring框架中我们通过配置创建类对象，由Spring在运行阶段实例化、组装对象。AOP，Aspect Oriented Programming，面向切面编程，其思想是在执行某些代码前执行另外的代码，使程序更灵活、扩展性更好，可以随便地添加、删除某些功能。Servlet中的Filter便是一种AOP思想的实现。 Spring同时也是一个“一站式”框架，即Spring在JavaEE的三层架构[表现层（Web层）、业务逻辑层（Service层）、数据访问层（DAO层）]中，每一层均提供了不同的解决技术。如下： 表现层（Web层）：Spring MVC 业务逻辑层（Service层）：Spring的IoC 数据访问层（DAO层）：Spring的jdbcTemplate Spring中的IoC操作 将对象的创建交由Spring框架进行管理。 IoC操作分为：IoC配置文件方式和IoC的注解方式。 IoC入门案例（1）导入Spring框架中的相关jar包，这里只导入Spring的Core模块（Core模块是框架的核心类库）下的jar包（使用IoC的基本操作，并不需要导入Spring的所有jar包，只导入spring-beans、spring-core、spring-context、spring-expression这4个jar包），以及 支持日志输出的 commons-logging 和 log4j 的jar包；（2）创建一个普通的Java类，并在该类中创建方法，如下： User.java 123456789101112131415package com.wm103.ioc;/** * Created by DreamBoy on 2018/3/17. */public class User { public void add() { System.out.println(\"User Add Method.\"); } @Override public String toString() { return \"This is a user object.\"; }}123456789101112131415 （3）创建Spring的配置文件，进行Bean的配置 Spring的核心配置文件名称和位置不是固定的。但官方件建议将该核心配置文件放在src目录下，且命名为 applicationContext.xml。 这里为了方便，将核心配置文件放在src目录下，并命名为 applicationContext.xml，内容如下： 123456&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"user\" class=\"com.wm103.ioc.User\"&gt;&lt;/bean&gt;&lt;/beans&gt;123456 （４）编写测试类进行测试，通过配置文件创建类对象 TestIoC.java 123456789101112131415161718192021package com.wm103.ioc;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;/** * Created by DreamBoy on 2018/3/17. */public class TestIoc { @Test public void runUser() { // 1. 加载Spring配置文件，根据创建对象 ApplicationContext context = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); // 2. 得到配置创建的对象 User user = (User) context.getBean(\"user\"); System.out.println(user); user.add(); }}123456789101112131415161718192021 Spring的bean管理（配置文件）Bean实例化的方式 在Spring中通过配置文件创建对象。 Bean实例化三种方式实现：（1）使用类的无参数构造创建，如： 12&lt;!-- 等同于 user = new com.wm103.ioc.User(); --&gt;&lt;bean id=\"user\" class=\"com.wm103.ioc.User\"&gt;&lt;/bean&gt;12 （2）使用静态工厂创建 如果一个Bean不能通过new直接实例化，而是通过工厂类的某个静态方法创建的，需要把&lt;bean&gt;的class属性配置为工厂类。如： 12&lt;!-- 等同于 user = com.wm103.ioc.UserFactory.createInstance(); --&gt;&lt;bean id=\"user\" class=\"com.wm103.ioc.UserFactory\" factory-method=\"createInstance\"&gt;&lt;/bean&gt;12 （3）使用实例工厂创建 如果一个Bean不能通过new直接实例化，而是通过工厂类的某个实例方法创建的，需要先配置工厂的&lt;bean&gt;标签，然后在需要创建的对象的bean标签的factory-bean属性配置为工厂类对象，factory-method属性配置为产生实例的方法。如： 1234&lt;!-- 等同于 userFactory = new com.wm103.ioc.UserFactory(); --&gt;&lt;bean id=\"userFactory\" class=\"com.wm103.ioc.UserFactory\"&gt;&lt;/bean&gt;&lt;!-- 等同于 user = userFactory.createInstance(); --&gt;&lt;bean id=\"user\" factory-bean=\"userFactory\" factory-method=\"createInstance\"&gt;&lt;/bean&gt;1234 Bean标签的常用属性（1）id属性：用于指定配置对象的名称，不能包含特殊符号。（2）class属性：创建对象所在类的全路径。（3）name属性：功能同id属性一致。但是在name属性值中可以包含特殊符号。（4）scope属性 singleton：默认值，单例单例模式下，在程序下只有一个实例。非单态模式下，每次请求该Bean，都会生成一个新的对象。 prototype：多例 request：创建对象后将对象存放到request域 session：创建对象后将对象存放到session域 globalSession：创建对象后将对象存放到globalSession域 属性注入 属性注入指创建对象时，向类对象的属性设置属性值。 在Spring框架中支持set方法注入和有参构造函数注入，即创建对象后通过set方法设置属性或采用有参构造函数创建对象并初始化属性。 使用有参构造函数注入属性 案例： Student.java 提供有参的构造方法 12345678910111213141516package com.wm103.ioc;public class Student { private String name; public Student(String name) { this.name = name; } @Override public String toString() { return \"Student{\" + \"name='\" + name + '\\'' + '}'; }}12345678910111213141516 bean的配置： 123&lt;bean id=\"student\" class=\"com.wm103.ioc.Student\"&gt; &lt;constructor-arg name=\"name\" value=\"DreamBoy\"&gt;&lt;/constructor-arg&gt;&lt;/bean&gt;123 创建Student对象进行测试： 12345678@Testpublic void runStudent() { // 1. 加载Spring配置文件，根据创建对象 ApplicationContext context = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); // 2. 得到配置创建的对象 Student student = (Student) context.getBean(\"student\"); System.out.println(student);}12345678 使用set方法注入属性 案例： Teacher.java 提供属性的set方法 123456789101112131415package com.wm103.ioc;public class Teacher { private String name; public void setName(String name) { this.name = name; } @Override public String toString() { return \"Teacher{\" + \"name='\" + name + '\\'' + '}'; }}123456789101112131415 bean的配置： 123&lt;bean id=\"teacher\" class=\"com.wm103.ioc.Teacher\"&gt; &lt;property name=\"name\" value=\"Teacher Wu\"&gt;&lt;/property&gt;&lt;/bean&gt;123 创建Teacher对象进行测试： 12345678@Testpublic void runTeacher() { // 1. 加载Spring配置文件，根据创建对象 ApplicationContext context = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); // 2. 得到配置创建的对象 Teacher teacher = (Teacher) context.getBean(\"teacher\"); System.out.println(teacher);}12345678 注入对象类型属性 以三层架构中的service层和dao层为例，为了让service层使用dao层的类创建的对象，需要将dao对象注入到service层类中。具体实现过程中如下：（1）创建service类、dao层接口、dao类，如下：UserService.java 12345678910111213package com.wm103.exp;public class UserService { private UserDao userDao; // 声明为接口类型，降低service层与dao层的耦合度，不依赖于dao层的具体实现 public void setUserDao(UserDao userDao) { this.userDao = userDao; } public void add() { System.out.println(\"UserService Add...\"); this.userDao.add(); }}12345678910111213 UserDao.java 123456789package com.wm103.exp;/** * 暴露给service层的接口 * Created by DreamBoy on 2018/3/17. */public interface UserDao { void add();}123456789 UserDaoImpl.java 123456789101112package com.wm103.exp;/** * 接口UserDao的具体实现 * Created by DreamBoy on 2018/3/17. */public class UserDaoImpl implements UserDao { @Override public void add() { System.out.println(\"UserDaoImpl Add...\"); }}123456789101112 （2）在配置文件中注入关系，如下： 1234567891011&lt;!-- 配置service和dao对象 --&gt;&lt;!-- 因为service依赖于dao，所以先进行dao对象的bean配置 --&gt;&lt;bean id=\"userDaoImpl\" class=\"com.wm103.exp.UserDaoImpl\"&gt;&lt;/bean&gt;&lt;bean id=\"userService\" class=\"com.wm103.exp.UserService\"&gt; &lt;!-- 注入dao对象 name属性值为：service中的某一属性名称 ref属性值为：被引用的对象对应的bean标签的id属性值 --&gt; &lt;property name=\"userDao\" ref=\"userDaoImpl\"&gt;&lt;/property&gt;&lt;/bean&gt;1234567891011 （3）创建测试方法进行测试，如下： 12345678@Testpublic void runUserService() { // 1. 加载Spring配置文件，根据创建对象 ApplicationContext context = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); // 2. 得到配置创建的对象 UserService userService = (UserService) context.getBean(\"userService\"); userService.add();}12345678 p名称空间注入属性 之前提到了一种set方法的属性注入方式，这里将介绍另一种属性注入的方式，名为 p名称空间注入。对比set方法的属性注入方式，核心配置文件配置修改如下： 1234567&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:p=\"http://www.springframework.org/schema/p\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"teacher\" class=\"com.wm103.ioc.Teacher\" p:name=\"Teacher Wu\"&gt;&lt;/bean&gt;&lt;/beans&gt;1234567 注入复杂类型属性 对象注入复杂类型属性，如数组、List、Map、Properties。 案例： PropertyDemo.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344package com.wm103.ioc;import java.util.List;import java.util.Map;import java.util.Properties;public class PropertyDemo { private String[] arrs; private List&lt;String&gt; list; private Map&lt;String, String&gt; map; private Properties properties; public String[] getArrs() { return arrs; } public void setArrs(String[] arrs) { this.arrs = arrs; } public List&lt;String&gt; getList() { return list; } public void setList(List&lt;String&gt; list) { this.list = list; } public Map&lt;String, String&gt; getMap() { return map; } public void setMap(Map&lt;String, String&gt; map) { this.map = map; } public Properties getProperties() { return properties; } public void setProperties(Properties properties) { this.properties = properties; }}1234567891011121314151617181920212223242526272829303132333435363738394041424344 bean配置文件，内容如下： 1234567891011121314151617181920212223242526272829303132333435363738&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"prop\" class=\"com.wm103.ioc.PropertyDemo\"&gt; &lt;!-- 注入数组 --&gt; &lt;property name=\"arrs\"&gt; &lt;list&gt; &lt;value&gt;Value 1 of Array&lt;/value&gt; &lt;value&gt;Value 2 of Array&lt;/value&gt; &lt;value&gt;Value 3 of Array&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;!-- 注入List集合 --&gt; &lt;property name=\"list\"&gt; &lt;list&gt; &lt;value&gt;Value 1 of List&lt;/value&gt; &lt;value&gt;Value 2 of List&lt;/value&gt; &lt;value&gt;Value 3 of List&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;!-- 注入Map集合 --&gt; &lt;property name=\"map\"&gt; &lt;map&gt; &lt;entry key=\"key1\" value=\"Value 1 of Map\"&gt;&lt;/entry&gt; &lt;entry key=\"key2\" value=\"Value 2 of Map\"&gt;&lt;/entry&gt; &lt;entry key=\"key3\" value=\"Value 3 of Map\"&gt;&lt;/entry&gt; &lt;/map&gt; &lt;/property&gt; &lt;!-- 注入Properties --&gt; &lt;property name=\"properties\"&gt; &lt;props&gt; &lt;prop key=\"username\"&gt;root&lt;/prop&gt; &lt;prop key=\"password\"&gt;123456&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt;1234567891011121314151617181920212223242526272829303132333435363738 创建PropertyDemo对象进行测试： 12345678910@Testpublic void runPropertyDemo() { ApplicationContext context = new ClassPathXmlApplicationContext(\"applicationContext.xml\"); PropertyDemo pd = (PropertyDemo) context.getBean(\"prop\"); System.out.println(pd); System.out.println(Arrays.toString(pd.getArrs())); System.out.println(pd.getList()); System.out.println(pd.getMap()); System.out.println(pd.getProperties());}12345678910 IoC和DI的区别 IoC，控制反转，将传统的对象创建流程转变为交由框架进行创建和管理。在Spring中，对象的创建交给Spring进行配置。它包括依赖注入。 DI，依赖注入，向类的属性设置值。 IoC与DI的关系：依赖注入不能单独存在，需要在IoC基础之上完成操作。 Spring的bean管理（注解） 注解是代码中特殊的标记，使用注解可以完成特定的功能。注解可以使用在类、方法或属性上，写法如：@注解名称(属性名称=属性值)。 Spring的bean管理注解方式，案例如下。 Spring注解开发准备（1）导入jar包： 导入基本的jar包：commons-logging、log4j、spring-beans、spring-context、spring-core、spring-expression相关jar包。 导入AOP的jar包：spring-aopjar包。 （2）创建类、方法 User.java 123456789package com.wm103.anno;import org.springframework.stereotype.Component;public class User { public void add() { System.out.println(\"User Add Method.\"); }}123456789 （3）创建Spring配置文件，引入约束；并开启注解扫描 bean1.xml 123456789101112131415161718&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;!-- 开启注解扫描 （1）到包中扫描类、方法、属性上是否有注解 --&gt; &lt;context:component-scan base-package=\"com.wm103\"&gt;&lt;/context:component-scan&gt; &lt;!-- （2）只扫描属性上的注解 --&gt; &lt;!--&lt;context:annotation-config&gt;&lt;/context:annotation-config&gt;--&gt;&lt;/beans&gt;123456789101112131415161718 注解创建对象 在创建对象的类上面使用注解实现，如： 12@Component(value=\"user\")public class User {12 创建测试类 TestAnno.java和测试方法，如： 123456789101112131415package com.wm103.anno;import org.junit.Test;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class TestAnno { @Test public void runUser() { ApplicationContext context = new ClassPathXmlApplicationContext(\"bean1.xml\"); User user = (User) context.getBean(\"user\"); user.add(); }}123456789101112131415 除了上述提到的 @Component注解外，Spring中还提供了@Component的3个衍生注解，其功能就目前来说是一致的，均是为了创建对象。 @Controller ：WEB层 @Service ：业务层 @Repository ：持久层 以单例或多实例方式创建对象，默认为单例，多例对象设置注解如下： 123@Component(value=\"user\")@Scope(value=\"prototype\")public class User {123 注解注入属性 案例：创建Service类和Dao类，并在Service中注入Dao对象。如下：（1）创建Dao和Service对象 UserDao.java 12345678910package com.wm103.anno;import org.springframework.stereotype.Repository;@Repository(value=\"userDao\")public class UserDao { public void add() { System.out.println(\"UserDao Add Method.\"); }}12345678910 UserService.java 12345678910111213package com.wm103.anno;import org.springframework.stereotype.Service;import javax.annotation.Resource;@Service(value=\"userService\")public class UserService { public void add() { System.out.println(\"UserService Add Method.\"); userDao.add(); }}12345678910111213 （2）在Service类中定义UserDao类型的属性，并使用注解完成对象的注入@Autowired：自动注入或自动装配，是根据类名去找到类对应的对象来完成注入的。 12@Autowiredprivate UserDao userDao;12 或者 @Resource 12@Resource(name=\"userDao\")private UserDao userDao;12 其中该注解的name属性值为注解创建Dao对象的value属性的值。 这两种注解方式都不一定要为需要注入的属性定义set方法。（3）创建测试方法 123456@Testpublic void runUserService() { ApplicationContext context = new ClassPathXmlApplicationContext(\"bean1.xml\"); UserService userService = (UserService) context.getBean(\"userService\"); userService.add();}123456 注：配置文件和注解混合使用1）创建对象的操作一般使用配置文件方式实现；2）注入属性的操作一般使用注解方式实现。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://blog.iwxyi.com/tags/学习笔记/"},{"name":"Spring","slug":"Spring","permalink":"http://blog.iwxyi.com/tags/Spring/"}]},{"title":"Android切换Activity并返回数据","date":"2019-01-03T03:19:00.000Z","path":"2019/01/03/Android切换Activity/","text":"切换Activity12Intent intent = new Intent(LoginActivity.this, MainActivity.class);startActivity(intent); 给子Activity传递数据如果给新启动的子Activity传递数据，只需要在Intent对象中加入key-value，key为准备传递数据的字符指示名称，value为准备传递的数据 12intent.putExtra(\"KEY\",data);startActivity(intent); 12345@Overrideprotected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); int data= getIntent().getIntExtra(\"KEY\"); // DataType用需要的数据类型} 从子Activity返回数据1234Intent intent = new Intent();intent.putExtra(“KEY”, data);setResult(RESULT_OK, intent);this.finish(); setResult(RESULT_OK, intent) 设置子Activity要返回父Activity（打开新Activity的Activity）的信息，RESULT_OK为int值，表子Activity成功执行完毕，intent里面就是包含要返回的数据。 记得要关闭哦 finish()在父Activity中如果要接收子Activity的返回结果，需要使用 startActivityForResult(intent, requestCode)打开子Activity，并且要重写 onActivityResult方法 12345678910/*............*/Intent intent = new Intent(this, DrugLibActivity.class);startActivityForResult(intent, 10);/*............*/@Overrideprotected void onActivityResult(int requestCode, int resultCode, Intent data) { if (10 == requestCode) { int index = data.getIntExtra(KEY,0); } } 如果在同一个Activity中有多个地方可调用 startActivityForResult 打开多个子 Activity 的情况，那你应该在 onActivityResult 返回时判断 requestCode，这样你就能搞清楚是哪个子Activity返回了数据。 参考：https://www.cnblogs.com/dw039/p/7411210.html document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Android","slug":"Android","permalink":"http://blog.iwxyi.com/tags/Android/"}]},{"title":"SSR+FCM","date":"2018-12-27T06:03:00.000Z","path":"2018/12/27/SSR-FCM/","text":"SSR+FCMSSR+BBRBBR 加速因为安装BBR重启后SSR会失效，需要重新安装，所以先安装BBR 实测 vultr 使用 BBR 加速的话，会经常出现连不上的情况 1234yum -y install wgetwget --no-check-certificate https://github.com/teddysun/across/raw/master/bbr.shchmod +x bbr.sh./bbr.sh （回车） （任意按键重启） SSR1wget -N --no-check-certificate https://raw.githubusercontent.com/ToyoDAdoubi/doubi/master/ssrmu.sh &amp;&amp; chmod +x ssrmu.sh &amp;&amp; bash ssrmu.sh 数字：1 IP ：（回车） 用户：（回车） 端口：（回车） 密码：（回车） 加密：10 协议：2 旧版：n 混淆：5 原版：n 设备：（回车） 限速：（回车） 总速：（回车） 流量：（回车） 禁端：（回车） 确认：y 搭建参数123456789101102n5n FCM-for-Mojo::WebQQ先进行一键安装，装好大体环境 然后再分布安装，去除bug 别忘了后面修复错误的命令 一键安装12yum install git -ygit clone https://github.com/null-ecp/FFM-one-step.git &amp;&amp; source ~/FFM-one-step/GCM.sh 1 y 1 1 分步安装123456789101112systemctl stop firewalldsystemctl disable firewalldyum install -y perl-Crypt-OpenSSL-RSA perl-Crypt-OpenSSL-Bignumcpanm Webqq::Encryptioncurl -sL https://rpm.nodesource.com/setup_9.x | bash -yum -y install nodejsgit clone https://github.com/RikkaApps/FCM-for-Mojo-Server.gitcd FCM-for-Mojo-Servercp config.example.js config.jsnpm installscreen -S qqnpm start 修复12月6日1234git clone https://github.com/sjdy521/Mojo-Webqqcd Mojo-Webqqperl Makefile.PLmake install document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"服务器","slug":"服务器","permalink":"http://blog.iwxyi.com/tags/服务器/"}]},{"title":"解决Ubuntu安装包不存在问题","date":"2018-12-23T05:56:00.000Z","path":"2018/12/23/解决Ubuntu安装vim的Package-vim-has-no-installation-candidate问题/","text":"解决Ubuntu安装vim的Package vim has no installation candidate问题当输入sudo apt-get install vim-gtk时出现了下面问题： 12345678nigel@yq-ubuntu:~/worksp$ sudo apt-get install vim-gtkReading package lists... DoneBuilding dependency tree Reading state information... DonePackage vim-gtk is not available, but is referred to by another package.This may mean that the package is missing, has been obsoleted, oris only available from another sourceE: Package 'vim-gtk' has no installation candidate 解决办法就是修改软件源设置 备份源文件，cp -i /etc/apt/sources.list /etc/apt/sources.list_backup 打开sources.list，root@ubuntu:/etc/apt# gedit sources.list 在源文件中加入如下阿里巴巴的阿里云服务器的地址并保存。（当然也可以是其他公司的地址） 1234567891011deb http://mirrors.aliyun.com/ubuntu/ trusty main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ trusty-security main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ trusty-updates main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ trusty-proposed main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ trusty-backports main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ trusty main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ trusty-security main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ trusty-updates main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ trusty-proposed main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ trusty-backports main restricted universe multiverse 更新：apt-get update 更新后，再安装vim，sudo apt-get install vim 这样问题就解决了。 163源12345678910deb http://mirrors.163.com/ubuntu/ trusty main restricted universe multiversedeb http://mirrors.163.com/ubuntu/ trusty-security main restricted universe multiversedeb http://mirrors.163.com/ubuntu/ trusty-updates main restricted universe multiversedeb http://mirrors.163.com/ubuntu/ trusty-proposed main restricted universe multiversedeb http://mirrors.163.com/ubuntu/ trusty-backports main restricted universe multiversedeb-src http://mirrors.163.com/ubuntu/ trusty main restricted universe multiversedeb-src http://mirrors.163.com/ubuntu/ trusty-security main restricted universe multiversedeb-src http://mirrors.163.com/ubuntu/ trusty-updates main restricted universe multiversedeb-src http://mirrors.163.com/ubuntu/ trusty-proposed main restricted universe multiversedeb-src http://mirrors.163.com/ubuntu/ trusty-backports main restricted universe multiverse document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Linux","slug":"Linux","permalink":"http://blog.iwxyi.com/tags/Linux/"}]},{"title":"MySQL百万级以上数据常识","date":"2018-12-20T05:33:00.000Z","path":"2018/12/20/MySQL百万级以上数据常识/","text":"最近的项目需要用到实现节点的管理规模达到百万规模，需要用数据库对中间数据以及最后的结果进行存储，存储规模可以达到千万级别。初步实现了10万节点数据的存储，但是访问速度实在太慢，查阅相关的资料，发现导致节点插入时间非常慢的原因： 连接数据库的问题：建立连接和关闭连接的次数太多，导致IO访问次数太频繁。 应该使用批量插入和批量修改的方法，而不是有一条数据就进行插入，这样会导致访问数据库的实际特别的慢。 在建立库的时候要建立适当的索引：如主键、外键、唯一等，优化查询效率。 ​ 具体的讨论见此处的链接：http://www.oschina.net/question/1859_62586?sort=default&amp;p=3#answers ​ 该链接中的一些讨论可以提供思路~ ​ 另外转载的内容如下： 最近一段时间参与的项目要操作百万级数据量的数据，普通SQL查询效率呈直线下降，而且如果where中的查询条件较多时，其查询速度简直无法容忍。之前数据量小的时候，查询语句的好坏不会对执行时间有什么明显的影响，所以忽略了许多细节性的问题。 经测试对一个包含400多万条记录的表执行一条件查询，其查询时间竟然高达40几秒，相信这么高的查询延时，任何用户都会抓狂。因此如何提高sql语句查询效率，显得十分重要。以下是结合网上流传比较广泛的几个查询语句优化方法： 索引不会生效的情况首先，数据量大的时候，应尽量避免全表扫描，应考虑在 where 及 order by 涉及的列上建立索引，建索引可以大大加快数据的检索速度。 但是，有些情况索引是不会起效的： 应尽量避免在 where 子句中使用!=或&lt;&gt;操作符，否则将引擎放弃使用索引而进行全表扫描。 应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如：​ select id from t where num is null可以在num上设置默认值0，确保表中num列没有null值，然后这样查询：​ select id from t where num=0 尽量避免在 where 子句中使用 or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，如：​ select id from t where num=10 or num=20可以这样查询：​ select id from t where num=10 ​ union all ​ select id from t where num=20 下面的查询也将导致全表扫描： select id from t where name like ‘%abc%’ ​ 若要提高效率，可以考虑全文检索。 in 和 not in 也要慎用，否则会导致全表扫描，如：​ select id from t where num in(1,2,3)对于连续的数值，能用 between 就不要用 in 了：​ `select id from t where num between 1 and 3 如果在 where 子句中使用参数，也会导致全表扫描。因为SQL只有在运行时才会解析局部变量，但优化程序不能将访问计划的选择推迟到运行时；它必须在编译时进行选择。然而，如果在编译时建立访问计划，变量的值还是未知的，因而无法作为索引选择的输入项。如下面语句将进行全表扫描：​ select id from t where num=@num可以改为强制查询使用索引：​ select id from t with(index(索引名)) where num=@num 应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。如：​ select id from t where num/2=100应改为:​ select id from t where num=100*2 应尽量避免在where子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。如：​ select id from t where substring(name,1,3)=’abc’–name以abc开头的id​ select id from t where datediff(day,createdate,’2005-11-30′)=0–’2005-11-30′生成的id​ 应改为:​ select id from t where name like ‘abc%’​ select id from t where createdate&gt;=’2005-11-30′ and createdate&lt;’2005-12-1′ 不要在 where 子句中的“=”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引。 在使用索引字段作为条件时，如果该索引是复合索引，那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，否则该索引将不会被使用，并且应尽可能的让字段顺序与索引顺序相一致。 不要写一些没有意义的查询，如需要生成一个空表结构：​ select col1,col2 into #t from t where 1=0这类代码不会返回任何结果集，但是会消耗系统资源的，应改成这样：​ create table #t(…) 很多时候用 exists 代替 in 是一个好的选择：​ select num from a where num in(select num from b)用下面的语句替换：​ select num from a where exists(select 1 from b where num=a.num) 建索引需要注意的地方 并不是所有索引对查询都有效，SQL是根据表中数据来进行查询优化的，当索引列有大量数据重复时，SQL查询可能不会去利用索引，如一表中有字段 sex，male、female几乎各一半，那么即使在sex上建了索引也对查询效率起不了作用。 索引并不是越多越好，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或 update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有必要。 应尽可能的避免更新 clustered 索引数据列，因为 clustered 索引数据列的顺序就是表记录的物理存储顺序，一旦该列值改变将导致整个表记录的顺序的调整，会耗费相当大的资源。若应用系统需要频繁更新 clustered 索引数据列，那么需要考虑是否应将该索引建为 clustered 索引。 其他需要注意的地方 尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型，这会降低查询和连接的性能，并会增加存储开销。这是因为引擎在处理查询和连接时会逐个比较字符串中每一个字符，而对于数字型而言只需要比较一次就够了。 任何地方都不要使用 select * from t ，用具体的字段列表代替“*”，不要返回用不到的任何字段。 尽量使用表变量来代替临时表。如果表变量包含大量数据，请注意索引非常有限（只有主键索引）。 避免频繁创建和删除临时表，以减少系统表资源的消耗。 临时表并不是不可使用，适当地使用它们可以使某些例程更有效，例如，当需要重复引用大型表或常用表中的某个数据集时。但是，对于一次性事件，最好使用导出表。 在新建临时表时，如果一次性插入数据量很大，那么可以使用 select into 代替 create table，避免造成大量 log ，以提高速度；如果数据量不大，为了缓和系统表的资源，应先create table，然后insert。 如果使用到了临时表，在存储过程的最后务必将所有的临时表显式删除，先 truncate table ，然后 drop table ，这样可以避免系统表的较长时间锁定。 尽量避免使用游标，因为游标的效率较差，如果游标操作的数据超过1万行，那么就应该考虑改写。 使用基于游标的方法或临时表方法之前，应先寻找基于集的解决方案来解决问题，基于集的方法通常更有效。 与临时表一样，游标并不是不可使用。对小型数据集使用 FAST_FORWARD 游标通常要优于其他逐行处理方法，尤其是在必须引用几个表才能获得所需的数据时。在结果集中包括“合计”的例程通常要比使用游标执行的速度快。如果开发时间允许，基于游标的方法和基于集的方法都可以尝试一下，看哪一种方法的效果更好。 在所有的存储过程和触发器的开始处设置 SET NOCOUNT ON ，在结束时设置 SET NOCOUNT OFF 。无需在执行存储过程和触发器的每个语句后向客户端发送 DONE_IN_PROC 消息。 尽量避免向客户端返回大数据量，若数据量过大，应该考虑相应需求是否合理。 尽量避免大事务操作，提高系统并发能力。 参考：https://blog.csdn.net/lynnucas/article/details/50265325 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://blog.iwxyi.com/tags/MySQL/"}]},{"title":"C语言CRC校验算法","date":"2018-12-20T00:20:00.000Z","path":"2018/12/20/C语言CRC校验算法/","text":"CRC32 C语言版 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879static const unsigned int crc32tab[] = { 0x00000000L, 0x77073096L, 0xee0e612cL, 0x990951baL, 0x076dc419L, 0x706af48fL, 0xe963a535L, 0x9e6495a3L, 0x0edb8832L, 0x79dcb8a4L, 0xe0d5e91eL, 0x97d2d988L, 0x09b64c2bL, 0x7eb17cbdL, 0xe7b82d07L, 0x90bf1d91L, 0x1db71064L, 0x6ab020f2L, 0xf3b97148L, 0x84be41deL, 0x1adad47dL, 0x6ddde4ebL, 0xf4d4b551L, 0x83d385c7L, 0x136c9856L, 0x646ba8c0L, 0xfd62f97aL, 0x8a65c9ecL, 0x14015c4fL, 0x63066cd9L, 0xfa0f3d63L, 0x8d080df5L, 0x3b6e20c8L, 0x4c69105eL, 0xd56041e4L, 0xa2677172L, 0x3c03e4d1L, 0x4b04d447L, 0xd20d85fdL, 0xa50ab56bL, 0x35b5a8faL, 0x42b2986cL, 0xdbbbc9d6L, 0xacbcf940L, 0x32d86ce3L, 0x45df5c75L, 0xdcd60dcfL, 0xabd13d59L, 0x26d930acL, 0x51de003aL, 0xc8d75180L, 0xbfd06116L, 0x21b4f4b5L, 0x56b3c423L, 0xcfba9599L, 0xb8bda50fL, 0x2802b89eL, 0x5f058808L, 0xc60cd9b2L, 0xb10be924L, 0x2f6f7c87L, 0x58684c11L, 0xc1611dabL, 0xb6662d3dL, 0x76dc4190L, 0x01db7106L, 0x98d220bcL, 0xefd5102aL, 0x71b18589L, 0x06b6b51fL, 0x9fbfe4a5L, 0xe8b8d433L, 0x7807c9a2L, 0x0f00f934L, 0x9609a88eL, 0xe10e9818L, 0x7f6a0dbbL, 0x086d3d2dL, 0x91646c97L, 0xe6635c01L, 0x6b6b51f4L, 0x1c6c6162L, 0x856530d8L, 0xf262004eL, 0x6c0695edL, 0x1b01a57bL, 0x8208f4c1L, 0xf50fc457L, 0x65b0d9c6L, 0x12b7e950L, 0x8bbeb8eaL, 0xfcb9887cL, 0x62dd1ddfL, 0x15da2d49L, 0x8cd37cf3L, 0xfbd44c65L, 0x4db26158L, 0x3ab551ceL, 0xa3bc0074L, 0xd4bb30e2L, 0x4adfa541L, 0x3dd895d7L, 0xa4d1c46dL, 0xd3d6f4fbL, 0x4369e96aL, 0x346ed9fcL, 0xad678846L, 0xda60b8d0L, 0x44042d73L, 0x33031de5L, 0xaa0a4c5fL, 0xdd0d7cc9L, 0x5005713cL, 0x270241aaL, 0xbe0b1010L, 0xc90c2086L, 0x5768b525L, 0x206f85b3L, 0xb966d409L, 0xce61e49fL, 0x5edef90eL, 0x29d9c998L, 0xb0d09822L, 0xc7d7a8b4L, 0x59b33d17L, 0x2eb40d81L, 0xb7bd5c3bL, 0xc0ba6cadL, 0xedb88320L, 0x9abfb3b6L, 0x03b6e20cL, 0x74b1d29aL, 0xead54739L, 0x9dd277afL, 0x04db2615L, 0x73dc1683L, 0xe3630b12L, 0x94643b84L, 0x0d6d6a3eL, 0x7a6a5aa8L, 0xe40ecf0bL, 0x9309ff9dL, 0x0a00ae27L, 0x7d079eb1L, 0xf00f9344L, 0x8708a3d2L, 0x1e01f268L, 0x6906c2feL, 0xf762575dL, 0x806567cbL, 0x196c3671L, 0x6e6b06e7L, 0xfed41b76L, 0x89d32be0L, 0x10da7a5aL, 0x67dd4accL, 0xf9b9df6fL, 0x8ebeeff9L, 0x17b7be43L, 0x60b08ed5L, 0xd6d6a3e8L, 0xa1d1937eL, 0x38d8c2c4L, 0x4fdff252L, 0xd1bb67f1L, 0xa6bc5767L, 0x3fb506ddL, 0x48b2364bL, 0xd80d2bdaL, 0xaf0a1b4cL, 0x36034af6L, 0x41047a60L, 0xdf60efc3L, 0xa867df55L, 0x316e8eefL, 0x4669be79L, 0xcb61b38cL, 0xbc66831aL, 0x256fd2a0L, 0x5268e236L, 0xcc0c7795L, 0xbb0b4703L, 0x220216b9L, 0x5505262fL, 0xc5ba3bbeL, 0xb2bd0b28L, 0x2bb45a92L, 0x5cb36a04L, 0xc2d7ffa7L, 0xb5d0cf31L, 0x2cd99e8bL, 0x5bdeae1dL, 0x9b64c2b0L, 0xec63f226L, 0x756aa39cL, 0x026d930aL, 0x9c0906a9L, 0xeb0e363fL, 0x72076785L, 0x05005713L, 0x95bf4a82L, 0xe2b87a14L, 0x7bb12baeL, 0x0cb61b38L, 0x92d28e9bL, 0xe5d5be0dL, 0x7cdcefb7L, 0x0bdbdf21L, 0x86d3d2d4L, 0xf1d4e242L, 0x68ddb3f8L, 0x1fda836eL, 0x81be16cdL, 0xf6b9265bL, 0x6fb077e1L, 0x18b74777L, 0x88085ae6L, 0xff0f6a70L, 0x66063bcaL, 0x11010b5cL, 0x8f659effL, 0xf862ae69L, 0x616bffd3L, 0x166ccf45L, 0xa00ae278L, 0xd70dd2eeL, 0x4e048354L, 0x3903b3c2L, 0xa7672661L, 0xd06016f7L, 0x4969474dL, 0x3e6e77dbL, 0xaed16a4aL, 0xd9d65adcL, 0x40df0b66L, 0x37d83bf0L, 0xa9bcae53L, 0xdebb9ec5L, 0x47b2cf7fL, 0x30b5ffe9L, 0xbdbdf21cL, 0xcabac28aL, 0x53b39330L, 0x24b4a3a6L, 0xbad03605L, 0xcdd70693L, 0x54de5729L, 0x23d967bfL, 0xb3667a2eL, 0xc4614ab8L, 0x5d681b02L, 0x2a6f2b94L, 0xb40bbe37L, 0xc30c8ea1L, 0x5a05df1bL, 0x2d02ef8dL}; static unsigned int crc32( const unsigned char *buf, unsigned int size){ unsigned int i, crc; crc = 0xFFFFFFFF; for (i = 0; i &lt; size; i++) crc = crc32tab[(crc ^ buf[i]) &amp; 0xff] ^ (crc &gt;&gt; 8); return crc^0xFFFFFFFF;} 参考：https://blog.csdn.net/gongmin856/article/details/77101397 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"C","slug":"C","permalink":"http://blog.iwxyi.com/tags/C/"},{"name":"密码学","slug":"密码学","permalink":"http://blog.iwxyi.com/tags/密码学/"}]},{"title":"Android漂亮的对话框sweet-alert","date":"2018-12-19T03:17:00.000Z","path":"2018/12/19/Android漂亮的对话框sweet-alert/","text":"首先在app的build.gradle中添加依赖compile 'com.github.f0ris.sweetalert:library:1.5.1' 这个时候同步一下项目会报一个错误，解决办法 在AndroidManifest.xml中manifest根标签添加xmlns:tools=\"http://schemas.android.com/tools\" 在application标签下添加tools:replace=\"android:icon,android:theme,android:allowBackup\" 使用代码 12345SweetAlertDialog pDialog = new SweetAlertDialog(this, SweetAlertDialog.PROGRESS_TYPE);pDialog.getProgressHelper().setBarColor(Color.parseColor(\"#A5DC86\"));pDialog.setTitleText(\"Loading\");pDialog.setCancelable(false);pDialog.show(); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113//你可以通过SweetAlertDialog.getProgressHelper()调用materialish-progress中下面这些方法，来动态改变进度条的样式 resetCount()isSpinning()spin()stopSpinning()getProgress()setProgress(float progress)setInstantProgress(float progress)getCircleRadius()setCircleRadius(int circleRadius)getBarWidth()setBarWidth(int barWidth)getBarColor()setBarColor(int barColor)getRimWidth()setRimWidth(int rimWidth)getRimColor()setRimColor(int rimColor)getSpinSpeed()setSpinSpeed(float spinSpeed) //只显示标题： new SweetAlertDialog(this) .setTitleText(\"Here's a message!\") .show();//显示标题和内容： new SweetAlertDialog(this) .setTitleText(\"Here's a message!\") .setContentText(\"It's pretty, isn't it?\") .show();//显示异常样式： new SweetAlertDialog(this, SweetAlertDialog.ERROR_TYPE) .setTitleText(\"Oops...\") .setContentText(\"Something went wrong!\") .show();//显示警告样式： new SweetAlertDialog(this, SweetAlertDialog.WARNING_TYPE) .setTitleText(\"Are you sure?\") .setContentText(\"Won't be able to recover this file!\") .setConfirmText(\"Yes,delete it!\") .show();//显示成功完成样式： new SweetAlertDialog(this, SweetAlertDialog.SUCCESS_TYPE) .setTitleText(\"Good job!\") .setContentText(\"You clicked the button!\") .show();//自定义头部图像： new SweetAlertDialog(this, SweetAlertDialog.CUSTOM_IMAGE_TYPE) .setTitleText(\"Sweet!\") .setContentText(\"Here's a custom image.\") .setCustomImage(R.drawable.custom_img) .show();//确认事件绑定： new SweetAlertDialog(this, SweetAlertDialog.WARNING_TYPE) .setTitleText(\"Are you sure?\") .setContentText(\"Won't be able to recover this file!\") .setConfirmText(\"Yes,delete it!\") .setConfirmClickListener(new SweetAlertDialog.OnSweetClickListener() { @Override public void onClick(SweetAlertDialog sDialog) { sDialog.dismissWithAnimation(); } }) .show();//显示取消按钮及事件绑定： new SweetAlertDialog(this, SweetAlertDialog.WARNING_TYPE) .setTitleText(\"Are you sure?\") .setContentText(\"Won't be able to recover this file!\") .setCancelText(\"No,cancel plx!\") .setConfirmText(\"Yes,delete it!\") .showCancelButton(true) .setCancelClickListener(new SweetAlertDialog.OnSweetClickListener() { @Override public void onClick(SweetAlertDialog sDialog) { sDialog.cancel(); } }) .show();//确认后切换对话框样式： new SweetAlertDialog(this, SweetAlertDialog.WARNING_TYPE) .setTitleText(\"Are you sure?\") .setContentText(\"Won't be able to recover this file!\") .setConfirmText(\"Yes,delete it!\") .setConfirmClickListener(new SweetAlertDialog.OnSweetClickListener() { @Override public void onClick(SweetAlertDialog sDialog) { sDialog .setTitleText(\"Deleted!\") .setContentText(\"Your imaginary file has been deleted!\") .setConfirmText(\"OK\") .setConfirmClickListener(null) .changeAlertType(SweetAlertDialog.SUCCESS_TYPE); } }) .show(); 参考：https://blog.csdn.net/taa1007/article/details/79551928 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Android","slug":"Android","permalink":"http://blog.iwxyi.com/tags/Android/"}]},{"title":"Android-学习笔记","date":"2018-12-19T02:29:00.000Z","path":"2018/12/19/Android-学习笔记/","text":"基础工具adb 命令 adb kill-server 杀死模拟器 adb start-server 启动模拟器 cd desktop 进入桌面文件夹 adb install path/x.apk 安装应用 adb uninstall com.xxx 卸载应用 adb shell 进入linux指令（ctrl+C退出） # ls 列出目录下所有文件（夹）清单 adb pull a.txt 从手机中导出文件 adb push a.txt /mnt/sdcard 把一个文件导入到手机 monkey 1000 随机点模拟器1000次（冒烟测试（压力测试）） 简易拨号应用设置按钮点击事件的四种方式1、内部类使用 onClickListener() 类 12345678910btn = (Button) findViewById(R.id.button1); // 找到按钮btn.setOnClickListener(new MyClickListener()); // 设置按钮点击事件// 在 MainActivity 里面再定义一个类去实现 按钮需要的接口类型private class MyClickListener implements OnClickListener{ @Override public void onClick(View v) { // 当按钮被单击的时候调用 System.out.println(\"按钮被点击了\"); }} 2、匿名内部类123456btn.setOnClickListener(new OnClickListener(){ @Override public void onClick(View v){ // code process }}); 3、setOnClickListener(this)1234567891011121314151617public class MainActivity extends Activity implements onClickListener{ // 注意:接口所属的包名有多个，不能选错：onClickListener - android.view.View public void onCreate() { btn.setOnClickListener(this); // 适用于多个按钮使用同一个事件的情况 } @Override public void onClick(View v){ switch (v.getID()){ // 可根据参数来判断按钮 case R.id.btn1 : break; case R.id.btn2 : break; } }} 4、布局中的 onClick在 AndroidManiFest 中设置 attribute（属性） 1234567&lt;Button //…… android:onClick=\"myClick\" /&gt;public void myClick(View v){ // 方法名必须和 attribute 的 onClick 属性一致 // Kabloey} 获取 EdiText 文本内容12345ed = (EditText) findViewById(R.id.editText1);String str = ed.getText().toString().trim(); // trim()去空格if (str.equals(\"\")){ // 如果文本为空 Toast.makeText(MainActivity.this, \"文本不能为空\", 1).show(); // 弹出吐司} 判断文本是否为空的API：TextUtils.isEmpty(str) 吐司 Toast12Toast.makeText(context/*上下文，可用 this,指当前的activity,即context*/, text, duration).show(); 注意：如果是在自定义的类例如 MyClickListener 中，context 不能是 thiscontext 可以改成：MainActivity.thisduration 弹出时长，参数有： Toast.LENGTH_LONG 值为1 Toast.LENGTH_SHORT值为0 最后别忘了弹出吐司： .show() 意图 Intent1234Intent intent = new Intent(); // 创建一个意图对象intent.setAction(Intent.ACTION_CALL); // 设置动作：打电话intent.setData(Uri.parse(\"tel:\" + num)); // 设置数据：tel:119startActivity(intent); // 开启意图：调用电话进行拨号（注意：权限 android.permission.CALL_PHONE） 布局1、线性布局123456android:orientation=\"horizontal\" // 水平的（默认）android:orientation=\"vertitcal\" // 竖直的android:layout_width=\"match_parent\" // 填充父android:layout_height=\"wrap_content\" // 自适应android:paddingBottom=\"@dimen/activity_vertical_margin\" // 控件内部内容（文字）位置android:marginLeft=\"10dp\" // 控件整体左边留空 10 像素 123456789&lt;!-- 总体布局 --&gt;&lt;LinearLaout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:toos=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"vertical\" tools:context=\".MainActivity\" &gt; &lt;!-- 内部控件布局 --&gt;&lt;/LinearLaout&gt; 2、相对布局控件默认左上角，需手动确定相对关系 12345android:id=\"@+id/btn2\" // 添加一个 IDandroid:layout_below=\"@id/btn1\" // 在 btn1 的下面（即当前控件的的上面）android:layout_toRightOf=\"@id/btn3\" // 在 btn3 的右边android:layout_alignParentRgiht=\"true\" // 在布局的最右边android:layout_alignBottom=\"@id/bt4\" // 与 bt4 底部对齐 123&lt;RelativeLayout xmlns=\"\"&gt; &lt;!-- 控件布局 --&gt;&lt;/RelativeLayout&gt; 3、帧布局一层一层显示，后面的Frame在前面的Frame上面（默认窗口左上角） 1android:layout_gravity=\"center\" center 居中 center_vertical 垂直居中 center_horizontal 水平居中 4、表格布局123456789101112131415161718192021222324252627282930&lt;TableLayout android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" &lt;!--代表一行--&gt; &lt;TableRow android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" &gt; &lt;!--加入第一个控件--&gt; &lt;TextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"所有控件开头都是大写的\" android:textColoe=\"#ff0000\" /&gt; &lt;!--加入第二个控件--&gt; &lt;TextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_marginLeft=\"10dp\" android:text=\"这是第二列\" android:textSize=\"18sp\" /&gt; &lt;/TableRow&gt; &lt;TableRow&gt; &lt;!-- 第二行 --&gt; &lt;/TableRow&gt; &lt;TableRow&gt; &lt;!-- 第三行 --&gt; &lt;/TableRow&gt; &lt;/TableLayout&gt; 5、绝对布局 absolution 已经废弃了 权重只能在线性布局中使用，平分布局。 1234&lt;LinearLayout&gt; &lt;TextView android:layout_weight=\"2\"/&gt; &lt;!--占三分之二--&gt; &lt;TextView android:layout_weight=\"1\"/&gt; &lt;!--占三分之一--&gt;&lt;/LinearLayout&gt; 单位 px 像素（不适配屏幕，不建议使用） dp自动适应屏幕的单位（px的替代单位） sp控件文字大小 textSize 调试单元测试 定义一个类继承 AndroidTestCase 123456789101112import android.test.AndroidTestCasepublic class CalcTest extends AndroidTestCase { // 写测试方法 public void testAdd() { Calc calc = new Calc(); // 这时已经写好的待测试类 int result = calc.add(5, 3); assertEquals(8/*expected*/, result/*actual*/); // 期望与实际进行对比 }} 在清单文件（AndroidManifest） 中加入 uses-library 和 instrumentation： 12345678910111213&lt;manifest xmlns:android...&gt; &lt;application android:icon=\"@drawable/icon\"...&gt; &lt;!-- 配置函数库 （application 里面） --&gt; &lt;uses-library android:name=\"android.test.runner\" /&gt; ... &lt;/application&gt; &lt;uses-sdk android:minSdkVersion=\"6\" /&gt; &lt;!-- 测试指令集 （application 外面） --&gt; &lt;instrumentation android:name=\"android.test.InstrumentationTestRunner\" android:targetPackage=\"应用包名\" android:lable=\"标题（可省）\" /&gt;&lt;/manifest&gt; \\&lt;application android:icon=\"@drawable/icon\"...&gt; ***\\&lt;uses-library android:name=\"android.test.runner\" /&gt;*** \\&lt;/application&gt; ***&lt;instrumentation android:name=\"android.test.InstrumentationTestRunner\"*** ***android:targetPackage=\"cn.itcast.action\" android:lable=\"Tests for My APP\" /&gt;*** Run As : Android JUnit Test 加入误相减，console 会出现：junit.framework.AssertionFailedError: expected:&lt;8&gt; but was &lt;2&gt; 可根据不同的错误级别来显示 日志猫12345Log.v(tag/*一般是 类名*/, msg); // v 级别（和 println 一样） 绿Log.i(tag/*一般是 类名*/, msg); // info 级别 ---- 绿Log.d(tag/*一般是 类名*/, msg); // debug 级别 ---- 蓝Log.w(tag/*一般是 类名*/, msg); // warn 级别 ---- 黄Log.e(tag/*一般是 类名*/, msg); // error 级别 ---- 红 文件存储操作过程：File -&gt; FileStream -&gt; write / read &amp; read_buffer -&gt; close 向SD卡写数据需要存储权限AndroidManiFest 增加权限：android.permission.WRITE_EXTERNAL_STORAGE txt读写例程：绝对路径1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.FileInputStream;public class UserInfoUtiles{ // 写入到文件 public static boolean saveInfo(String username, String password) { try { String result = username + \"&amp;\" + password; // 创建 File类 指定数据存储的位置 File file = new File(\"/data/data/包名/info.txt\"); // 创建一个文件输出流 FileOutputStream fos = new FileOutputStream(file); fos.write(result.getBytes()); fos.close(); return true; } catch (Exception e) { e.printStackTrace(); return false; } } // 从文件读出 public static Map&lt;String, String&gt; readInfo() { try { Map&lt;String, String&gt; maps = new HashMap&lt;String, String&gt;(); File file = new File(\"/data/data/包名/info.txt\"); FileInputStream fis = new FileInputStream(file); BufferedReader bufr = new BufferedReader(new InputStreamReader(fis)); String content = bufr.readLine(); // 读取一行 // 分割文本 String[] splits = content.split(\"&amp;\"); String name = splits[0]; String pwd = splits[1]; // 把数据放到 Map 中 maps.put(\"username\", name); maps.put(\"password\", pwd); fis.close(); return maps; } catch (Exception e) { e.printStackTrace(); } return null; }}// 调用存入if (UserInfoUtils.saveInfo(username, password)){ ...}// 调用取出Map&lt;String, String&gt; maps = UserInfoUtils.readInfo();if (maps != null){ String name = maps.get(\"username\"); String pwd = maps.get(\"password\"); ...} API 获取内部路径12345678910111213141516171819// 使用API获取路径public static boolean saveInfo(Context context, String username, String password){ // path = \"/data/data/包名/files/\" String path = context.getFilesDir().getpath(); // 用 path/info.txt 代替原来的 路径常量 File file = new File(path, \"info.txt\"); // 和前面一样的 FileOutputStream fos = new FileOutputStream(file); fos.write(result.getBytes()); fos.close();}// 调用UserInfoUtils.saveInfo(MainActivity.this, username, password);UserInfoUtils.readInfo(MainActivity.this); context 获取内部路径12345// 使用上下文直接获取 FileOutputStream （类似API）FileOutputStream fos = context.openFileOutput(\"info,txt\", 0/*模式，4种*/);fos.write(result.getBytes());fos.close(); Environment 获取SD卡路径123// sdPath = \"/mnt/sdcard\"String sdPath = Environment.getExternalStorageDirectory().getPath();File file = new File(sdPath, \"info.txt\"); 判断SD卡是否可用123if ( Environment.MEDIA_MOUNTED.equals( Environment.getExternalStorageState() ) ) { Toast.makeText(getApplicationContext(), \"SD卡可用\", 1).show();} 获取SD卡的可用空间1234567File file = Envirinment.getExternalStorageDirectory();long total = file.getTotalSpace(); // 总空间（单位：byte）long usable = file.getUsableSpace(); // 可用空间（单位：byte）//转换数据格式为可视化文本String Total = Formatter.formatFileSize(this, total); // this 是当前的 MainActivityString Usable = Formatter.formatFileSize(this, usable); // 每大于900则除以1024 文件权限四种模式 MODE_PRIVATE — 值为0 MODE_APPEND — MODE_WORLD_READABLE r– MODE_WORLD_WRITEABLE -w- Linux文件权限表示：十位数 第一位：文件的类型 ( 例如：文件夹 d ) 2-4位：用户的权限 5-7位：用户所在的组的权限 8-10位：其他用户的权限 r w x r 可读 w 可写 x 可执行 rw- &lt;=&gt; 110 &lt;=&gt; 6 改变文件权限 Linux下的chhmod命令：chmod 764 a.txt // 文件权限为：rwx rw- r–​ 111 110 100 == 7 6 4 XML保存设置文件 SharedPreferences（必须得会） Sharedpreferences setting = getSharedPreferences(name, mode);name:任意 mode:同上，4种模式会自动生成：/data/data/包名/shared_prefs/name.xml 文件 1234567891011SharedPreferences sp = new SharedPreferences(\"config\", 0); // 文件名为 config.xml 模式为 private 0// 若改成\"config.txt\", 则会生成 config.txt.xml 文件// 获取 sp 的编辑器Editor edit = sp.edit();edit.putString(\"username\", username); // key, valueedit.putInt(\"Age\", age); // edit.putXXX 有多种类型可选edit.putFloat(\"PI\", 3.14);// 记得关闭 edit （提交）edit.commit(); SharedPreferences.getString(key, defaultValue /*默认的，找不到时*/ ); 12SharedPreferences sp = getSharedPreferences(\"config\", 0);sp.getString(\"username\", \"\"); 对应的 xml 内容 123456&lt;?xml version=\"1.0\" encodeing=\"UTF-8\" standalone=\"true\"?&gt;&lt;map&gt; &lt;string name=\"username\"&gt;myname&lt;/string&gt; &lt;string name=\"Age\"&gt;20&lt;/string&gt; ...&lt;/map&gt; 手动构建 xml 文件12345678910111213141516171819202122232425262728293031323334353637383940414243public void build_xml(){ // 声明数组（其中 Sms 是自定义 class） List&lt;Sms&gt; smsLists = new ArrayList&lt;Sms&gt;(); //创建 sb 对象 StringBuffer sb = new StringBuffer(); // 开始组拼 xml 文件头(注意转移双引号) sb.append(\"&lt;?xml version=\\\"1.0\\\" encodeing=\\\"UTF-8\\\" ?&gt;\"); // 开始组拼 xml 根节点 sb.append(\"&lt;smss&gt;\"); // 开始组建 xml 节点 （任意循环增加） for (Sms sms : smsLists) { sb.append(\"&lt;num&gt;\"); sb.append(\"110\"); sb.append(\"&lt;/num&gt;\"); sb.append(\"&lt;people&gt;\"); sb.append(\"小明\"); sb.append(\"&lt;/people&gt;\"); } sb.append(\"&lt;/smss&gt;\"); // 保存到 SD卡 上 try { File file = new File(Environment.getExternalStorageDirectory().getPath(), \"backup.xml\"); FileOutputStream fos = new FileOutputStream(file); fos.write(sb, .toString().getBytes()); fos.close(); // 关闭流 // 注意写入到SD卡权限：WRITE_EXTERNAL_STORAGE } catch ( Exception e) { e.printStackTrace(); }} xml序列化器 xmlSerializer12345678910111213141516171819202122232425262728293031323334353637try{ // 通过 Xml 类获取 XmlSerializer 类的实例 XmlSerializer sl = Xml.newSerializer(); // 设置参数：XML文件路径 File file = new File(Environment.getExternalStorageDirectory().getPath(), \"backup2.xml\"); FileOutputStream fos = new FileOutputStream(file); sl.setOutput(fos, \"utf-8\"); // 文件流与编码 // 开始写 xml 文档开头 sl.startDocument(\"utf-8\", true/*standalone, 表示是一个独立的xml文件，没有其他文件的约束*/); // xml 的根节点，namespace = null sl.startTag(null, \"smss\"); // 循环写xml数据 for (Sms sms : smsLists) { sl.startTag(null, \"sms\"); sl.startTag(null, \"num\"); sl.text(\"110\"); sl.endTag(null, \"num\"); sl.startTag(null, \"people\"); sl.text(\"小明\"); sl.endTag(null, \"people\"); sl.endTag(null, \"sms\"); } sl.endTag(numll, \"smss\"); // 写文档结尾 sl.endDocument(); fos.close(); // 关闭流} xml的解析12345678910111213&lt;!-- 目标 xml 文件 --&gt;&lt;weather&gt; &lt;channel id=\"1\"&gt; &lt;city&gt;背景&lt;/cith&gt; &lt;temp&gt;25&lt;/temp&gt; &lt;/channel&gt; &lt;channel&gt; ... &lt;/channel&gt; ...&lt;/weather&gt; 1234567891011121314151617// 调用：try{ // 获取 Assets 的文件 InputStream inputStream = getAssets().open(\"weather.xml\"); List&lt;Channel&gt; weatherlists = WeatherParser.parserXml(inputstream); StringBuffer sb = new StringBuffer(); for (Channel channel : weatherlists) { sb.append(channel.toString()); } System.out.println(sb.toString());} 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071// WeatherParser类的parserXml方法：public static List&lt;Channel&gt; parserXml(InputStream in){ try { List&lt;Channel&gt; weather: ists = null; Channel channel = null; // 获取解析的实例 XmlPullParser parser = Xml.newPullParser(); // 设置解析参数(in是输入流) parser.setInput(in, \"utf-8\"); // 获取事件类型 int type = parser.getEventType(); while (type != XmlPullParser.END_DOCUMENT /*==1*/) { // 具体判断解析到哪个节点 switch (type) { // 具体判断一下 解析到哪个开始标志 case XmlPullParser.START_TAG : // 解析开始标志 if (\"weather\".equals(parser.getName())) { // 创建一个集合对象 weatherLists = new ArrayList&lt;Channel&gt;(); } else if (\"channel\".equals(parser.getName())) { // 创建Channel对象 channel = new Channel(); // 获取ID：第1个数，下标0 String id = parser.getAttributeValue(0) channel.setId(id); // 自定义类的方法 } else if (\"city\".equals(parser.getName())) { // 获取city的数据 String city = parser.getText(); channel.setCity(city); } else if (\"temp\".equals(parser.getName())) { // 获取temp的数据 String temp = parser.getText(); channel.setTemp(temp); } break; case XmlPullParser.END_TAG : // 解析结束标志 // 判断要解析的结束标签 if (\"channel\".equals(parser.getName())) { // 把 Javabean 对象存到集合中 weatherLists.add(channel); } break; } // 不停地向下解析 parser.next(); } return weatherLists; } catch ( Exception e ) { }} 数据库sqlite 数据库初始化SQLiteOpenHelperSQLiteOpenHelper类 用来管理数据库的创建 ，创建子类来继承它 db.execSQL(string sql) 执行SQL语句 12345678910111213141516171819202122232425262728import android.content.Context;import android.database.sqlite.SQLiteDababase;import android.database.sqlite.SQLiteOpenHelper;public class MyOpenHelper extends SQLiteOpenHelper { // 需要添加无参构造方法 public MyOpenHelper(Context context) { // 创建数据库，上下文、名字、cursor对象（结果集/游标）、数据库版本（从1开始） super(context, \"test.db\", null, 1); } // 数据库第一次创建的时候用（仅一次），特别适合做表结构的初始化 @Override public void onCreate(SQLiteDatabase db) { // 创建表的结构 db.execSQL(\"create table info( _id integer primary key autoincrement, name varchar(20) )\"); // SQLite数据库底层不区分数据类型，但是SQL语句还是得照写声明类别（所有SQL语句都一样） // integer 也是用 string 来存储，varchar(20) 可以存更长的 string } // 数据库升级的时候调用（不能降级，会出错） @Override public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) { //例如：升级 info表 添加 phone字段 db.execSQL(\"alter table info add phone varchar(20)\"); } } MainActivity部分数据库路径：/data/data/包名/databases/数据库名字.db 123456789101112131415161718public class MainActivity extends Activity{ private MyOpenHelp myOpenHelper; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); // 创建数据库（包名），触发 构造方法、onCreate() 事件 myOpenHelper = new MyOpenHelper(getApplicationContext()); // 创建（第一次）或打开数据库 SQLiteDatabase sqLiteDatabase = myOpenHelper.getWriteableDatabase(); // 创建（第一次）或打开数据库；如果磁盘已满则返回只读 // SQLiteDatabase readableDatabase = myOpenHelper.getReadableDatabase(); }} 执行SQL语句execSQLvoid execSQL(sql, bindArgs); // 修改语句，无返回值 SQLiteDatabase execSQL(sql); // 查找语句，有返回值 lite1234insert into info(name, phone) values(\"Tom\", \"110\"); -- 两个斜杠表示注释delete from info where name = \"Tom\"lupdate info set phone = \"120\" where name = \"Tom\";select name, phone from info; 1234567891011121314// 执行 SQL语句public void onClick(View v){ // 获取数据库对象 SQLiteDatabase db = myOpenHelper.getWritableDatabase(); // 执行增加一条的SQL语句 db.execSQL(\"insert into info (name, phone) values(?, ?)\", new Object[] {\"Tim\", \"119\"}); // 执行删除语句 db.execSQL(\"delete from info where name=?\", new Object[] {\"Tom\"}/*bindArgs*/); // 数据库用完需关闭（官方建议关闭，但是不关可提升效率） db.close();} Cursor int getCount() 行数 getColumnCount() 列数 String getString(int columnIndex) boolean moveToNext() moveToFirst() moveToLast() moveToPosition(int position) moveToPrevious() String[] getColumnNames() 所有列的名字 1234567891011121314public void onClick(View v){ SQLiteDatabase db = myOpenHelper.getReadableDatabase(); // 只读就行了 Cursor cursor = db.rawQuery(\"select * from info\", null); if (cursor != null &amp;&amp; cursor.getCount() &gt; 0) { while (cursor.moveToNext()) { String name = cursor.getString(1); // 这一行第二列的值 System.out.println(\"name:\" + name); } }} SQL优缺点缺点 SQL语句容易写错 没有返回值，结果不容易判断 优点 多表查询（自由、功能强） sqlite3命令行SQL语句开启shell adb shell 定位到目录 # cd /data/data/包名/databases 打开数据库 # sqlite3 数据库名字.db sqlite&gt; SQL语句 （不包括前面的sqlite&gt;） 改变DOS编码 如果中文乱码，点击cmd属性，看编码是否为UTF-8（默认GBK） 改成GBK chcp 936 改成UTF-8 chcp 65001 chcp: char change page 谷歌封装好的数据库API原理是组拼SQL语句 1234567891011121314151617181920212223242526272829303132public void onClick(View v){ SQLiteDatabase db = myOpenHelper.getWritableDatabase(); ContentValues values = new ContentValues(); values.put(\"name\", \"Tom\"); values.put(\"phone\", \"110\"); // 添加记录：表名、null、map数组：名字=&gt;值。返回 long -1失败 或 行号（1开始） long num = db.insert(\"info\", null, values); // 删除记录：表名、条件、条件值。返回 int 影响的行数， 0 为没有删除 int num = db.delete(\"info\", \"name=?\", new String[] {\"Tom\"}); // 更新记录：表名、map数组、条件、条件值。 返回 int 影响的行数 int num = db.update(\"info\", values, \"name=?\", new String[] {\"Tom\"}); // 查询：表名、查询的列String[]（null为全部列）、条件、条件值String[]、分组、过滤条件、排序 // 选择查询的列（参数二）：new String[]{\"name\", \"phone\"} Cursor cursor = db.query(\"info\", null, \"name=?\", new String[] {\"Tom\"}, null, null, null); if (cursor != null &amp;&amp; cursor.getCount() &gt; 0) { while(cursor.moveToNext()) { String name = cursor.getString(0); // 第一列（name） String phone = cursor.getString(1); // 第二列（phone） System.out.println(\"name=\" + name + \" phone=\" + phone); } } db.close();} 优点 写法简单 有返回值 缺点 多张表不容易查询 数据库的事物例如：转账，需要取出、存入同时成功 12345678910111213141516171819public void onClick(Veiw v){ SQLiteDatabase db = myOpenHelper.getReadableDatabase(); // 使用事物进行操作 db.beginTransaction(); try{ // 实现逻辑，即SQL语句 db.execSQL(\"update ac_mon set money = money - 100 where name = ?\", new String[]{\"userA\"}); /* int i = 10 / 0; // 运行中断 */ db.execSQL(\"update ac_mon set money = money + 100 where name = ?\", new String[]{\"userB\"}); // 给当前事物设置一个成功的标记 db.setTansactionSuccessful(); } catch (Exception e) { Toast.makeText(getApplicationContext(), \"服务器忙，请稍后再试\", 1).show(); } finally { db.endTransaction(); // 关闭事物 }} ListView使用方法1、布局：activity_main123456&lt;ListView android:id=\"@+id/lv\" android:layout_witdh=\"match_parent\" android:layout_height=\"match_parent\" android:fastScrollEnabled=\"true\"&gt; &lt;!--快速滚动条--&gt;&lt;/ListView&gt; 2、设置Adapter连接到数据适配器：setAdapter() 12345678910111213public class MainActivity extends Activity { @Override protected void onCreate(Bundle saveInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); // 找到控件 ListView lv = (ListView) findViewById(R.id.lv); // 显示数据（数据来源于数据适配器） lv.setAdapter(new MyListAdapter()); }} 3、实现BaseAdapter方法BaseAdapter 可以放到上面的 MainActivity 类的代码里面，作为类中类 12345678910111213141516171819202122232425262728private class MyListAdapter extends BaseAdapter { // 项目数量 @Override public int getCount() { return 4; /*item数量，自定义*/ } // 对应的对象 @Override public Object getItem(int position) { return null; } // 对应的ID @Override public long getItemID(int position) { return 0; } //获取一个view，用来显示每个item的数据 @Override public View getView(int position, View convertView, ViewGroup parent) { TextView tv = new TextView(MainActivity.this/*当前类*/); tv.setText(\"索引：\" + position); return tv; // return null 的话会报错 }} 错误提示Attempt to invoke virtual method 'int android.view.View.getImportantForAccessibility()' on a null object reference 原因是 getView() 返回值为空…… 结果示例getCount()控制条目数量。当数量=4时： 1public int getCount() { return 4; } 结果： 1索引：0 1索引：1 1索引：2 1索引：3 每个item都是一个TextView，其由getView()方法决定 显示数据的原理MVC Javaweb: m : mode 数据 v : view 视图 jsp c : controller 控制 sevlet Android: m : mode 数据(javabean) v : listview c : adapter ListView优化getView() 方法说明只有在屏幕上显示（包括只显示一点点）的item才会触发getView()方法。滚动时新显示的条目也会触发。快速滚动加载大量View可能会导致内存溢出（Out Of Memory）。 convertView 缓存机制item并不是滚动完就销毁。使用 convertView 历史缓存可避免内存溢出。 123456789101112131415161718192021@Overridepublic View getView(int position, View convertView, ViewGroup parent){ TextView tv; if (convertView == null) { // 缓存对象为空，创建新的 view 对象 tv = new TextView(MainActivity.this); } else { // 使用历史缓存对象 tv = (TextView) convertView; } tv.setText(\"索引：\" + position); return tv;} 复用历史缓存对象：一开始时是真的创建可见范围内的对象，滚动上去后，新出现（底部）的对象实际上是复用已经加载好但是看不见了的（顶部）的对象。根据 position 调用 getView() 方法。 例如，快速滚动时加载100个item，不用缓存需要创建100个TextView。使用 convertView 后，只需要设置TextView的值就好了。 List高度设置能否设置成 layout_height=\"wrap_content\" ？ 123&lt;ListView android:layout_height=\"match_parent\"&gt; &lt;!--这是正常的--&gt;&lt;/ListView&gt; 改成android:layout_height=\"wrap_content\"后，无法确定高度，校验很多次，重复调用 getView() 方法，严重影响性能。 复杂的ListView┍━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┑│ ┌───────┐ 这里是项目标题，字… ││ │ Image │ 这个部分是项目相对应 ││ └───────┘ 的信息内容 │┕━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┙ 1、Layout：activity_main12345&lt;ListView android:id=\"@+id/lv\" android:layout_witdh=\"match_parent\" android:layout_height=\"match_parent\"&gt;&lt;/ListView&gt; 2、Layout : item（xml）1234567891011121314151617181920212223242526272829303132333435&lt;RelativeLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_witdh=\"match_parent\" android:layout_height=\"match_parent\" &gt; &lt;ImageView android:id=\"@+id/iv_icon\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:src=\"@drawable/ic_launcher\" /&gt; &lt;TextView android:id=\"@+id/tv_title\" android:layout_width=\"match_parent\" // 左边与父容器右边的距离 android:layout_height=\"wrap_content\" android:layout_toRightOf=\"@id/iv_icon\" // 图片右边 android:layout_marginTop=\"3dp\" // 顶部留空 android:singleLine=\"true\" // 单行显示 android:ellipsize=\"end\" // 显示开头，末尾三个点。start值相反 androi:textColor=\"#000000\" android:textsize=\"20sp\" android:text=\"这个里项目标题，字体加粗加黑\" /&gt; &lt;TextView android:id=\"@+id/tv_message\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_toRightOf=\"@id/iv_icon\" // 图片右边 android:layout_below=\"@id/tv_text\" // 标题下面 android:singleLine=\"true\" android:ellipsize=\"end\" androi:textColor=\"#666666\" android:textsize=\"15sp\" android:text=\"这个里项目标题，字体加粗加黑\" /&gt;&lt;/RelativeLayout&gt; 3、BaseAdapter：打气筒View View.inflate(context, resource, root) 方法（打气筒）介绍：创建新的View对象，把布局资源（xml 文件）折换成一个 View 对象，放到父容器中，并返回这个 View 对象 context : getApplicationContext()，或 this resource : 定义的布局文件 R.id.xxx root : null，或者待放入的容器(ViewGroup) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162public class MainActivity extends Activity{ @Override protected void onCreate(Bundle saveInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); // 找到控件 ListView lv = (ListView) findViewById(R.id.lv); // 显示数据（数据来源于数据适配器） lv.setAdapter(new MyListAdapter); } private class MyListAdapter extends BaseAdapter { // 项目数量 @Override public int getCount() { return 4; /*item数量，自定义*/ } // 对应的对象 @Override public Object getItem(int position) { return null; } // 对应的ID @Override public long getItemID(int position) { return 0; } //获取一个view，用来显示每个item的数据 @Override public View getView(int position, View convertView, ViewGroup parent) { View view; if (convertView == null) { // 获取打气筒服务 view = View.inflate(getApplicationContext, R.id.item, null); } else { // 复用历史缓存对象 view = (TextView) convertView; } //根据列表设置控件数据 //TextView tv = (TextView) view.findViewById(R.id.tv); //view.setText(xxLists.get(position).getXx()); return view; } }} 获取 XML 布局里面的控件：view.findViewById()，不能直接 findViewById() 打气筒的三种写法打气筒写法一：View.inflate() 1view = View.inflate(getApplicationContext, R.id.item, null); // 用法见上 打气筒写法二：LayoutInflater.from() 1view = LayoutInflater.from(getApplicationContext()).inflate(R.layout.item, null); 打气筒写法三：getSystemService()据说实际上用得比较多 12LayoutInflater inflater = (LayoutInflater) getSystemService(LAYOUT_INFLATER_SERVICE);view = inflater.inflate(R.layout.item, null); 其他写法：不常见 ArrayAdapter布局：activity_main 1234&lt;ListView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\"&gt;&lt;/ListView&gt; 布局：item 1234&lt;TextView android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\"&gt;&lt;/TextView&gt; MainActivity ArraryAdapter&lt;String&gt;(context, resource, objects) 123456789101112131415161718192021222324import android.R.array;public class MainAcitivity extends Activity{ String names[] = { \"111\", \"222\", \"333\", \"444\" }; @Override protected void onCreat(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); // 找到控件 ListView lv = (ListView) findViewById(R.id.lv); // 创建 ArrayAdapter : context, resource(只有TextView的xml文件), 数据数组 ArrayAdapter&lt;String&gt; adapter = new ArrayAdapter&lt;String&gt;(this, R.id.item, names); // 设置数据适配器 lv.setAdapter(adapter); }} 结果 1234111222333444 重载的四个参数的ArrayAdapter用法： ArraryAdapter&lt;String&gt;(context, resource, textViewResourceId, objects) textViewResourceId 为 resource 布局文件里面的某个特定的 TextView 的 ID 1ArrayAdapter&lt;String&gt; adapter = new ArrayAdapter&lt;String&gt;(this, R.id.item, R.id.tv, names); 1234&lt;RelativeLayout ...&gt; &lt;TextView android:id=\"@+id/tv\" ... /&gt;&lt;/RelativeLayout&gt; SimpleAdapter┍━━━━━━━━━━━━━━━━━━━━━┑│┌───────┐┌───────┐│││ name │ │ phone │││└───────┘└───────┘│┕━━━━━━━━━━━━━━━━━━━━━┙ 布局：activity_main 123&lt;RelativeLayout ...&gt; &lt;ListView ... /&gt;&lt;/RelativeLayout&gt; 布局：item 123456789101112131415161718&lt;LinearLayout xmlns=\"...\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"horizental\"&gt; &lt;TextView android:id=\"@+id/tv_name\" android:layout_width=\"0dp\" android:layout_weight=\"1\" android:layout_height=\"wrap_content\" /&gt; &lt;TextView android:id=\"@+id/tv_phone\" android:layout_width=\"0dp\" android:layout_weight=\"1\" android:layout_height=\"wrap_content\" /&gt;&lt;/LinearLayout&gt; 代码：MainActivity SimpleAdapter adapter = new SimapleAdapter(context, data, resource, from, to); // 参数长的那个 data 是 List&lt;Map&lt;String, String&gt;&gt; 类型数据 resource 是 布局文件（上面的 item） from 是 String[] 类型，表示 Map&lt;String, String&gt; 的键 to 是 int[] 类型数组，与from 对应的布局文件中的 TextView 的 ID 123456789101112131415161718192021// 找到控件ListView lv = (ListView) findViewById(R.id.lv);// 准备数据List&lt;Map&lt;String, String&gt;&gt; data = new ArrayList&lt;Map&lt;String, String&gt;&gt;();Map&lt;String, String&gt; map1 = new HashMap&lt;String, String&gt;();map1.put(\"name\", \"Tom\");map1.put(\"phone\", \"110\");Map&lt;String, String&gt; map2 = new HashMap&lt;String, String&gt;();map2.put(\"name\", \"Alice\");map2.put(\"phone\", \"120\");data.add(map1);data.add(map2);// 设置数据适配器SimpleAdapter adapter = new SimapleAdapter(getApplicationContext(), data, R.id.item, new String[]{ \"name\", \"phone\" }, new String[]{ R.id.tv_name, R.id.tv_phone });lv.setAdapter(adapter); 用ListView展示数据库的数据┍━━━━━━━━━━━━━━━━━━━━━┑│┌───────┐┌───────┐│││ name │ │ phone │││└───────┘└───────┘│┕━━━━━━━━━━━━━━━━━━━━━┙ 布局：activity_main 1略 布局：item 123456789101112131415161718&lt;LinearLayout xmlns=\"...\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"horizental\"&gt; &lt;TextView android:id=\"@+id/tv_name\" android:layout_width=\"0dp\" android:layout_weight=\"1\" android:layout_height=\"wrap_content\" /&gt; &lt;TextView android:id=\"@+id/tv_phone\" android:layout_width=\"0dp\" android:layout_weight=\"1\" android:layout_height=\"wrap_content\" /&gt;&lt;/LinearLayout&gt; 类：Person 12String name, phone;略 MainActivity 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596public class MainAcitivity extends Activity{ // 找到控件 ListView lv = (ListView) findViewById(R.id.lv); // 整理数据 List&lt;Person&gt; lists = new ArrayList&lt;Person&gt;(); @Override protected void onCreat(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); } public void onClick(View v) { SQLiteDatabase db = myOpenHelper.getWritableDatabase(); // 查询：表名、查询的列String[]（null为全部列）、条件、条件值String[]、分组、过滤条件、排序 //Cursor cursor = db.query(\"info\", null, \"name=?\", new String[]{\"Tom\"}, null, null, null); Cursor cursor = db.query(\"info\", null, null, null, null, null, null); // 查询所有 if (cursor != null &amp;&amp; cursor.getCount() &gt; 0) // 如果有数据 { while(cursor.moveToNext()) { String name = cursor.getString(0); // 第一列（name） String phone = cursor.getString(1); // 第二列（phone） Person person = new Person(name, phone); lists.add(person); } // 设置数据适配器 lv.setAdapter(new MyListAdapter); } db.close(); } private class MyListAdapter extends BaseAdapter { // 项目数量 @Override public int getCount() { return lists.size(); // 返回列表（数据库）中的数据数量 } // 对应的对象 @Override public Object getItem(int position) { return null; } // 对应的ID @Override public long getItemID(int position) { return 0; } //获取一个view，用来显示每个item的数据 @Override public View getView(int position, View convertView, ViewGroup parent) { TextView view; if (convertView == null) { // 缓存对象为空，创建新的 view 对象 view = View.inflate(getApplicationContext, R.id.item, null); } else { // 使用历史缓存对象 view = (TextView) convertView; } Person person = lists.get(position); // 获取从数据库中取出的列表对象 // findViewById() 从当前 activity 中获取 ID，无法直接取到 layout/item 里面的 ID， // 所以需要先用 inflate() 获取到 R.id.item 的 view，再通过 view 获取 ID TextView tv_name = (TextView) view.findViewById(R.id.tv_name); TextView tv_phone = (TextView) view.findViewById(R.id.tv_phone); tv_name.setText(person.getName()); // 设置名字 tv_phone.setText(person.getPhone()); // 设置电话 return view; } }} 网络网页源码查看器联网权限android.permission.INTERNET HttpUrlConnection 类用于发送或者接受数据，取网页源代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 设置网址String path = \"http://www.baidu.com\";URL url = new URL(path);try{ // HttpURLConnection对象，用于发送或者接受数据 HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection(); // 设置发送 get 请求（默认），注意要求【大写】 urlConnection.setRequestMethod(\"GET\"); // 设置请求超时 urlConnection.setConnectTimeout(5000); // 5 秒 // 获取服务器返回的状态码，例如 404 int code = urlConnection.getResponseCode(); if (code == 200) { // 获取服务器返回的数据流 InputStream in = urlConnection.getInputStream(); // 数据流转换成文本，最终的网页源代码 String content = StreamTools.readStream(in); }}// 流转文本的方法public static class StreamTools{ public static String readStream(InputStream in) { int len = -1; byte[] buffer = new byte[1024]; // 1 kb // 定义一个内存输出流 ByteArrayOutputStream baos = new ByteArrayOutputStream(); while ( ( len = in.read(buffer) ) != -1 ) { baos.write(buffer, 0, len); } in.close(); String content = new String(baos.toByteArray()); return content; }} ScrollViewscrollview 只能有一个子控件 布局 12345678&lt;ScrollView android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;TextView android:id=\"@+id/tv\"/&gt;&lt;/ScrollView&gt; 如果要多个子控件，可以将这些子控件包裹在 &lt;LinearLayout&gt; 里面，orientation=\"vertical\" 消息机制的写法主线程（UI线程）ANR Application not response 应用无响应 耗时的操作放到子线程当中 Android 4.0 之后，谷歌强制要求连接网络不能再主线程进行访问 只有主线程（UI线程）才可以更新UI Handler 使用步骤1、在主线程定义一个 Handler 1private Handler handler = new Handler(); 2、使用 Handler，重写里面的 handlerMessage 方法 1public void handleMessage(android.os.Message msg) { } 3、用 Handler 去子线程发消息 1handler.sendMessage(msg); 4、handleMessage 方法就会执行，更新UI 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162public class MainActivity extends Activity{ TextView tv = (TextView) findVIewById(R.id.tv); // 在主线程中定义一个Handler，类后跟{}表示重写类的方法 private Handler handler = new Handler() { // 收到消息。这个方法是在主线程里执行的，可以更新 UI public void handleMessage(android.os.Message msg) { String content = (String) msg.obj; tv.setText(content); }; } public void click(View v) { // 创建一个子线程 new Thread() { public void run() { try { // 设置网址 String path = \"http://www.baidu.com\"; URL url = new URL(path); // 发送、接收数据的对象 HttpURLConnection urlConnection = (HttpURLConnection) url.openConnection(); // 设置GET请求 urlConnection.setRequestMethod(\"GET\"); // 设置超时时间 urlConnection.setConnectTimeout(5000); // 获取服务器返回的状态码 int code = urlConnection.getResponseCode()； if (code == 200) { // 输入流 InputStream in = conn.getInputStream(); // 流转字符串 String content = StreamTools.readStream(in); // 创建 Message 对象 Message msg = new Message(); msg.obj = content; // Handler 发送msg(包含数据)于更新UI handler.sendMessage(msg); } //if } //try } } .start(); //thread run } //function} 消息机制的原理消息队列，有一个Looper不断读取队列，然后 handlerMessage(msg) Handler 完善：what1234567891011121314151617181920212223242526272829303132333435363738protected final int REQUESTSUCESS = 0;protected final int REQUESTNOTFOUND = 1;protected final int REQUESTEXCEPTION = 2;public void handleMessage(android.os.Message msg) { switch (msg.what) { case REQUESTSUCESS : // 代表请求成功 String content = (String) msg.obj; tv.setText(content); break; case REQUESTNOTFOUND : // 代表请求失败 Toast.makeText(getApplicationContext(), \"请求资源不存在\", 0).show(); break; case REQUESTEXCEPTION : // 代表产生异常 Toast.makeText(getApplicationContext(), \"服务器忙，请稍后再访问\", 0).show(); break; }}try{ //... if (code == 200) { Mseeage msg = new Message(); msg.what = REQUESTSUCESS; // 代表哪条消息 handler.sendMessage(msg); } else { Mseeage msg = new Message(); msg.what = REQUESTNOTFOUND; // 代表哪条消息 handler.sendMessage(msg); }} catch (Exception e) { Mseeage msg = new Message(); msg.what = REQUESTEXCEPTION; // 代表哪条消息 handler.sendMessage(msg);} 程序运行错误，尽量提示用户：服务器忙，请稍后访问 而不是：程序运行错误，让用户担忧 图片查看器ImageView 显示网络图片123&lt;manifest&gt; &lt;uses-permission android:name=\"android.permission.INTERNET\" /&gt;&lt;/manifest&gt; 123456&lt;EditView /&gt;&lt;Button /&gt;&lt;ImageView android:id=\"@+id/iv\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" /&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152private Handler handler = new Handler(){ //收到消息，设置图片 public void handleMessage(android.os.Message msg) { bitmap bitmap = (Bitmap) msg.obj; iv.setImageBitmap(bitmap); }}public void click(View v){ new Thread() { public void run() { try { // 使用路径创建 URL 对象 String path = ev.getText().toString().trim(); URL url = new URL(path); // 获取 HttpURLConnection（用户发送或者接收数据） HttpURLConnection conn = (HttpURLConnection) url.openConnection(); // 设置请求的方式、超时时间 conn.setRequestMethond(\"GET\"); conn.setConnectTimeout(5000); int code = conn.getResponseCode(); if (code == 200) { // 获取图片的数据（流 的形式） InputStream in = conn.getInputStream(); // 通过位图工厂 获取 bitmap Bitmap bitmap = BitmapFactory.decodeStream(in); // 发送消息用于更新UI Message msg = Message.obtain(); // 使用 Message 的静态方法 可以减少对象的创建 msg.obj = bitmap; handler.sendMessage(msg); } else { // ... } } catch (Exception e) { e.printStackTrace(); } } } .start();} 使用 Message 的静态方法 可以减少对象的创建 Message msg = Message.obtain(); 效果等同于：Message msg = new Message() 但是效率快 图片缓存到本地1234567891011121314if (code == 2) { //图片的数据流 InputStream in = conn.getInputStream(); File file = new File(getCacheDir(), \"test.png\"); // 谷歌提供的缓存目录 FileOutputStream fos = new FileOutputStream(file); int len = -1; byte[] buffer = new byte[1024]; // 1kb while ((len = in.read(buffer)) != -1) { fos.write(buffer, 0, len); } fos.close(); in.close();} 使用缓存图片123456789101112131415161718192021222324252627282930313233343536373839404142434445new Thread(){ public void run() { try { // 谷歌提供的缓存目录：/data/data/包名/cache/ + test.png File file = new File(getCacheDir(), \"test.png\"); if (file.exists() &amp;&amp; file.length() &gt; 0) { // 使用缓存的图片 Bitmap cacheBitmap = BitmapFactory.decodeFile(file.getAbsolutePath()); // 把 cacheBitmap 显示到 ImageView 上 Message msg = Message.obtain(); msg.obj = cacheBitmap; handler.sendMessage(msg); } else { // 第一次访问，联网获取数据 String path = ev.getText().toString().trim(); URL url = new URL(path); HttpURLConnection conn = (HttpURLConnection) url.openConnection(); conn.setRequestMethond(\"GET\"); conn.setConnectTimeout(5000); int code = conn.getResponseCode(); if (code == 200) { InputStream in = conn.getInputStream(); FileOutputStream fos = new FileOutputStream(file); int len = -1; byte[] buffer = new byte[1024]; // 1kb while ((len = in.read(buffer)) != -1) { fos.write(buffer, 0, len); } fos.close(); in.close(); } } } }} 对图片进行加密Base64加密： Base64.encodeToString(byte[] input, int flags); 1File file = new File(getCacheDir(), Base64.encodeToString(path.getBytes[], Base64.DEFAULT)); 上述代码针对文件路径进行加密，文件名为URL路径加密后的密文 cache 和 filedir 区别写出文件示例1234567891011try { // firledir：/data/data/包名/files/info.txt FileOutputStream fos = openFileOutput(\"info.txt\", 0); // cache：/data/data/包名/cache/info.txt File file = new File(getCacheDir(), \"info.txt\"); FileOutputStream fos = new FileOutputStream(file); fos.write(\"haha\".getByte()); fos.close();} Thread APIrunOnUiThread 写法runOnUiThread(Runable action) 不管在什么位置，里面运行的语句都运行在 UI 线程上。 123456789new Thread() { public void run() { // ... runOnUiThread(new Runnable() { public void run() { tv.setText(\"HHH\"); } }); // ...} } Handler API延迟线程 new Handler().postDelayed(Runnable r, int delayMillis); 效果等同于 Sleep() 这个方法执行在 UI 线程里，可更新 UI 1234567891011public void f() { // 2秒后执行 run 方法 new Handler().postDelayed( new Runnable(){ @Override public run() { // ...code... } }, 2000);} 定时器 TimerTimer.schedule(TimerTask task, long delay); 延迟后执行 Timer.schedule(TimerTask task, long delay, long period); 指定的延迟后进行重复的固定延迟执行 还有其它重载的 schedule 函数 相当于子线程，不能用来更新 UI。可以用 runOnUiThread 来执行 UI 操作 1234567891011121314public void click() { Timer timer = new Timer(); TimerTask task = new TimerTask() { @Override public void run() { // ... code... // 这相当于子线程，不能更新 UI } } timer.schedule(task, 5000);} Timer.cancel(); Task.cancel(); 销毁一个执行 123456// 当 Activity 销毁时 会执行这个方法protected void onDestroy() { timer.cancel(); task.cancel(); super.onDestroy();} 网络基础网络图片 SmartImageView123&lt;com.loopj.android.image.SmartImageView android:id=\"@+id/siv\" ... /&gt; 12345678imageUrl = \"...\";view = View.inflate(...);SmartImageView svi = (SmartImageView) view.findViewById(R.id.siv);siv.setImageUrl(imageUrl); // 设置加载网络图片siv.setImageUrl(String imageUrl, Integer fallbackResource); // 参数2为加载失败的内容 R.drawable.xxxsiv.setImageView(String imageUrl, Integer OnCompleteListener completeListener); // 结束后回调事件siv.setImageView(String imageUrl, Integer fallbackResource, OnCompleteListener completeListener);siv.setImageView(String imageUrl, Integer fallbackResource, Integer loadingResource, OnCompleteListener completeListener); GitHub 开源项目网址：github.com 导入开源项目：下载 zip 后，把解压出来后的 com 文件夹（源码包）复制到项目的 src 中 源码：在 com 文件夹内，.java 后缀名的 布局：用的时候，需要用开源项目的完整包名 HttpURLConnextion联网的基类。 如果连接要求不是很高，只是用来发发数据的话，可以用下面的开源项目。 封装 toast 方法通用方法，获取数据后立即弹出提示 12345678public void showToast(final String content) { runOnUiThread(enw Runnable() { @Override public void run() { Toast.makeText(getApplicationContext(), content, 1).show(); } })} GET 和 POST 的区别 URL路径不同：GET 拼接 网址 和 数据 POST 通过请求体（流）的形式把数据发送给服务器 POST 比 GET 多了两个头信息：content-length 和 content-type 使用 POST1234567891011121314151617181920String path = \"http://xxx\";String data = \"name=\" + name + \"&amp;pass=\" + pass;URL url = new URL(path);HttpURLConnextion conn = (HttpURLConnection) url.openConnection();conn.setRequestMethond(\"POST\");conn.setConnextTimeout(5000);//比GET方式多的两个头信息conn.setRequestProperty(\"Content-Type\", \"application/x-www-form-url\");conn.setRequestProperty(\"Content-Length\", data.length()+\"\"); // 参数二要求字符串，故 数字+空字符串//以流的形式提交数据con.setDoOutput(true); // 设置一个标记，允许输出conn.getOutputStream().write(data.getBytes());//判断结果int code = conn.getReponseCode();if (code == 200) { // 获取返回的数据流 -&gt; 转化成字符串 -&gt; 操作字符串数据 InputStream inputStream = conn.getInputStream(); String content = StreamTools.readStream(inputStream); showToast(content);} 乱码问题Android 编码：UTF-8 服务器编码：本地服务器的编码，一般为 iso-859-1 （类似 GBK） 改变服务器编码（Java）：返回中文乱码 System.out.prrintln(\"ans : \" + new String(ans.getBytes(\"utf-8\"))); 发送中文乱码：先以 iso-8859-1 编码，再以 UTF-8 解码 `System.out.prrintln(\"ans : \" + new String(ans.getBytes(\"iso-8859-1\"), \"utf-8\"));`改变 Android 编码123456789101112131415161718public class StreamTools{ //把输入流转换成字符串 public static String readStream(InputStream in) throws Exception { //定义一个内存输出流 ByteArrayOutputStream baos = new ByteArrayOutStream(); int len = -1; byte[] buffer = new byte[1024]; // 1 kb while ( (len = in.read(buffer)) != -1 ) { baos.write(buffer, 0, len); } in.close(); String content = new String(baos.toByteArray(), \"gbk\"); // 指定 GBK 编码 return content; }} URLEncode 类encode方法： URLEncode.encode(String s, String charseName); path = path + \"?username=\" + URLEncode(name, \"utf-8\") + \"&amp;password=\" + URLEncode(pass, \"utf-8\"); HttpClient 方式提交数据HttpClient 是一个接口，而不是类。（没有人用这个，了解） GET123456789101112131415161718192021222324252627new Thread(){ public void run() { try { String path = \"http://xxx?id=\" + URLEncoder.encode(id); // 获取 httpclient 实例 DefaultHttpClient client = new DefaultHttpClient(); // 准备 get 请求，定义一个 httpget 实现 HttpGet get = new HttpGet(path); // 执行一个 get 请求 HttpResponse response = client.execute(get); // 获取服务器返回的状态码 int code = response.getStatusLine().getStatusCode(); if (code == 200) { // 获取服务器返回的数据，以流的形式 InputStream inputstream = response.getEntity().getContent(); // 把流转换成字符串 String content = StreamTools.readStream(inputStream); showToast(content); } } }} .start(); POSTEntity、BasicNameValuePair 等也都是接口 1234567891011121314151617181920212223242526String name = \"...\", pwd = \"...\";String path = \"...\";DefaultHttpClient client = new DefaulthttpClient();HttpPost post = new HttpPost(path);// 准备 parameters 集合List&lt;NameValuePair&gt; lists = new ArrayList&lt;NameValuePair&gt;();// 准备 NameValuePair，键值对数据BasicNameValuePair nameValuePair = new BasicNameValuePair(\"username\", name);BasicNameValuePair pwdValuePair = new BasicNameValuePair(\"password\", pwd);// 把 name 和 pwd 加入到集合中lists.add(nameValuePair);lists.add(pwdValuePair);// 准备 entityUrlEncodeFormEntity entity = new UrlEncodeFormEntity(parameters);// 准备 post，以实体 Entity 的形式post.setEntity(entity);HttpResponse response = client.execute(post);int code = response.getStatusLine().getStatusCode();if (code == 200) { InputStream inputStream = response.getEntity().getContent(); String content = StreamTools.readStream(inputStream); showToast(content);} asyncHttpClient 开源项目GitHub 上下载，把 com 包复制到 src 中。 GET12345678910111213141516171819202122232425String path = \"...\";AsyncHttpClient client = new AsyncHttpClient();client.get(path, new AcynchttpResponseHandler(){ // 请求成功的回调方法0 /*@Override public void onSuccess(String response) { showToast(response); }*/ // 请求成功的回调方法 @Override public onSuccess(int statusCode, Header[] headers, byte[] responseBody) { showToast(new String(responseBody, \"gbk\")); } // 请求失败的回调方法 @Override public void onFailure(int statusCode, Header[] headers, byte[] responseBody, Throwable error) { // ...code... }}); POST1234567891011121314151617181920212223242526String path = \"...\";AsyncHttpClient client = new AsyncHttpClient();// 准备请求体的内容RequestParams params = new RequestParams();params.put(\"username\", \"admin\");params.put(\"password\", \"123\");params.put(\"email\", \"my@email.com\");params.put(\"profile_picture\", new FIle(\"pic.jpg\")); // 上传文件params.put(\"profile_picture2\", someInputStream); // 上传输入流params.put(\"profile_picture\", new ByteArrayInputStream(someBytes)); // 上传字节集client.post(path, params, new AcynchttpResponseHandler() { // 请求成功的回调方法 @Override public onSuccess(int statusCode, Header[] headers, byte[] responseBody) { showToast(new String(responseBody, \"gbk\")); } // 请求失败的回调方法 @Override public void onFailure(int statusCode, Header[] headers, byte[] responseBody, Throwable error){ // ...code... }}); 多线程下载原理分段下载 服务器没有限速的话，线程并不是越多越好 获取一部分文件，返回的状态码是206，而不是200。 RandomAccessFile 类随机读取和写入文件，使用见下方代码 代码test.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import java.io.*;import java.net.*;class test{ private static String path = \"http://download.dcloud.net.cn/HBuilder.9.0.1.windows.zip\"; private static int threadCount = 3; // 线程数 public static void main(String[] args) { try { URL url = new URL(path); HttpURLConnection conn = (HttpURLConnection) url.openConnection(); conn.setRequestMethod(\"GET\"); conn.setConnectTimeout(5000); int code = conn.getResponseCode(); if (code == 200) { // 获取服务器文件的大小(B) int length = conn.getContentLength(); // 创建一个和下载文件一样大的文件，提前申请空间 RandomAccessFile raf = new RandomAccessFile(getFileName(path), \"rw\"); raf.setLength(length); // 算出每个线程下载的大小 int blockSize = length / threadCount; // 计算每个线程开始位置和结束位置 for (int i = 0; i &lt; threadCount; i++) { int startIndex = i * blockSize; // 开始位置 int endIndex = (i + 1) * blockSize - 1; if (i == threadCount - 1) // 最后一个线程 { endIndex = length - 1; } // 开启线程去下载 DownLoadThread dlt = new DownLoadThread(path, startIndex, endIndex, i); dlt.start(); } } } catch (Exception e) { e.printStackTrace(); } } public static String getFileName(String path) { int start = path.lastIndexOf(\"/\") + 1; return path.substring(start); }} DownLoadThread.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566import java.io.*;import java.net.*;// 定义下载文件的线程public class DownLoadThread extends Thread{ private String path; private int startIndex; private int endIndex; private int threadId; DownLoadThread(String path, int startIndex, int endIndex, int threadId) { this.path = path; this.startIndex = startIndex; this.endIndex = endIndex; this.threadId = threadId; } @Override public void run() { try { URL url = new URL(path); HttpURLConnection conn = (HttpURLConnection) url.openConnection(); conn.setRequestMethod(\"GET\"); conn.setConnectTimeout(5000); // 设置一个请求头Range，获取每个线程下载的开始位置和结束位置 conn.setRequestProperty(\"Range\", \"bytes=\" + startIndex + \"-\" + endIndex); int code = conn.getResponseCode(); // 状态码 206 表示请求部分资源成功（一部分文件） if (code == 206) { // 创建随机读写文件对象 RandomAccessFile raf = new RandomAccessFile(getFileName(path), \"rw\"); // 每个线程从自己的位置开始写 raf.seek(startIndex); InputStream in = conn.getInputStream(); int len = -1; byte[] buffer = new byte[1024]; while ((len = in.read()) != -1) { raf.write(buffer, 0, len); } System.out.println(\"下载完毕\"); raf.close(); } } catch (Exception e) { e.printStackTrace(); } } // 获取文件名 public static String getFileName(String path) { int start = path.lastIndexOf(\"/\")+1; return path.substring(start); }} 断点续传下载过程中保存每个线程的下载位置到文件 保存的间隔越短（缓冲区越小）则越卡顿 12// 正在运行的线程数runningThread = threadCount; 下载类： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/*...code...*/// 读取上次断开的位置继续下载File file = new File(threadId + \".txt\");if (file.exists() &amp;&amp; file.length() &gt; 0){ FileInputStream fis = new FileInputStream(file); BufferedReader bufr = new BufferedReader(new InputStream(fis)); String lastPositions = bufr.readLine(); // 读出来的是上次下载的位置 int lastPosition = Integer.parseInt(lastPositions); // 改变一下 startIndex 的位置 startIndex = lastPosition; fis.close();}if (code == 206){ // 创建随机读写文件对象 RandomAccessFile raf = new RandomAccessFile(\"file.exe\", \"rw\"); // 每个线程从自己的位置开始写 raf.seek(startIndex); InputStream in = conn.getInputStream(); int len = -1; byte[] buffer = new byte[1024 * 1024]; // 缓冲区每 1M 保存一次文件 int total = 0; // 当前线程已下载的大小 while ((len = in.read) != -1) { raf.write(buffer, 0, len); // 保存下载位置到文件 total += len; int currentThreadPosition = startIndex + total; RandomAccessFile raff = new RandomAccessFile(threadId + \".txt\", \"rwd\"); // rwd 同步写入到底层文件中 raff.write(String.valueOf(currentThreadPosition).getBytes()); raff.close(); } raf.close(); System.out.println(\"下载完毕\"); // 下载完毕后判断并删除保存下载位置的文件 synchronized (DownLoadThread.class) // 加锁？ { runningThread--; if (runningThread == 0) // 全部下载完毕 { for (int i = 0; i &lt; threadCount; i++) { File file = new File(threadId + \".txt\") file.delete(); // 删除文件 } } }} 安卓动态添加进度条进度条布局 12345&lt;progressBar xmlns:android=\"http://schemas.android.com/apk/res/android\" android:id=\"@+id/progressBar1\" style=\"?android:attr/progressBarStyleHorizontal android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" /&gt; 动态添加进度条 1234567891011121314List&lt;ProgressBar&gt; pbLists = new ArrayList&lt;ProgressBar&gt;(); // 进度条集合，用来取对象barLayout = (LinearLayout) findViewById(R.id.barLayout); // 进度条线性布局barLayout.removeAllViews(); // 先移除上次的进度条pbLists.clear(); // 清除上次的进度条实例// 添加线程数量的进度条int threadCount = Integer.parseInt(threadCount);for (int i = 0; i &lt; threadCount; i++){ View pbView = View.inflate(getApplicationContext(), R.id.barItem, null) pbLists.add(pbView); barLayout.addView(pbView);} 安卓多线程下载与进度相关的控件都可以在子线程更新UI 123456789101112131415161718192021222324252627282930private int PbMax; // 线程下载的最大值private int pbPos; // 当前线程的进度pbMax = endIndex - startIndex;pbPos = 0; // 进度条当前进度，如果中断过，则要从上次的位置开始// 每个线程设置对应进度条的进度if (code == 206){ // 创建随机读写文件对象 RandomAccessFile raf = new RandomAccessFile(getFileName(path), \"rw\"); // 每个线程从自己的位置开始写 raf.seek(startIndex); InputStream in = conn.getInputStream(); int len = -1; byte[] buffer = new byte[1024]; while ((len = in.read()) != -1) { raf.write(buffer, 0, len); } System.out.println(\"下载完毕\"); raf.close(); // 设置进度条进度（注：进度条可以直接在子线程中更新UI） pbLists.get(threadId).setMax(pbMax); pbLists.get(threadId).setProgress(pbPos);} 多线程下载开源项目xUtils 123456789101112131415161718192021222324252627282930// 点击按钮开始下载public void click(View v){ String path = \"...\"; HttpUtils http = new HttpUtils(); //下载路径, 目标路径, 是否支持断点续传, 回调); http.download(path, \"/mnt/sdcard/haha.exe\", true, new RequstCallBack&lt;File&gt;() { // 下载成功 @Override public void onSucess(RequestInfo&lt;File&gt; responseInfo) { Toast.makeText(getApplicationContext(), \"下载成功\", 1).show(); } // 下载失败 public void onFailure(HttpException error, String msg) { ; } // 下载进度 @Override public void onLoading(long total, long current, boolean isUploading) { pb.setMax((int) total); pb.setProgress((int) current); } })} Android 四大组件Activity创建新的 Activity创建新的 Class 继承 Activity 新的 Activity 12345678910public class TestActivity extends Activity{ @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); // 加载布局 setContentView(R.layout.activity_test) }} 清单文件 AndroidManifest 12345678910111213141516171819202122232425262728293031&lt;!-- 代表当前应用 --&gt;&lt;!-- 两个 Activity 入口 --&gt;&lt;application ... &gt; &lt;activity android:name=\"com.包名.MainActivity\" android:label=\"第一个页面\" android:icon=\"@drawable/icon1\" /&gt; &lt;!-- main 主入口 --&gt; &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.MAIN\" /&gt; &lt;category android:name=\"android.intent.category.LAUNCHER\" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;!-- 配置入口 --&gt; &lt;activity android:name=\"com.包名.TestActivity\" /&gt; android:label=\"第二个页面\" android:icon=\"@drawable/icon2\" /&gt; &lt;!-- main 主入口 --&gt; &lt;intent-filter&gt; &lt;!-- 第二个入口（要 .MAIN 和 .LAUNCHER） --&gt; &lt;action android:name=\"android.intent.action.MAIN\" /&gt; &lt;!-- 如果是 .category.DEFAULT 则不会有入口 --&gt; &lt;category android:name=\"android.intent.category.LAUNCHER\" /&gt; &lt;/intent-filter&gt; &lt;/activity&gt;&lt;/application&gt; Android 四大组件都要在清单文件里面配置 如果要多个入口（启动图标），则 intent-filter 必须要 .MAIN 和 .LAUNCHER。（一般就一个启动图标） Activity 下的 label 和 icon 属性可以和 Application 节点的属性不一样默认使用 Application 节点下的属性。 隐式意图12345678// 创建 意图对象Intent intent = new Intent();// 设置 跳转的动作intent.setAction(\"com.包名.活动名\");// 设置 categoryintent.addCategory(\"android.intent.category.DEFALT\");// 开启 ActivitystartActivity(intent); 意图过滤器12345&lt;intent-filter&gt; &lt;!-- 传递的数据 、 约束 --&gt; &lt;data android:mimetype=\"audio/mp4\" android:scheme=\"wxy\"/&gt;&lt;/intent-filter&gt; 可以配置多个 filter，只要匹配到完整的一个（setData 和 .setType）就行mimetype 和 scheme 都可以不写 mimetypeJava 代码中设置 Date 也为 wxy（只要和约束相同就行）intent.setData(Uri.parse(\"wxy:\" + 110));不设置约束，其实效果相同。 scheme设置 setType 会自动把 setData 方法的数据清除。反之亦然……intent.setType(\"audio/mp4\");谷歌自定义了很多数据类型，开发者也可以用自己定义的例如aa/bb。 两个要一起使用时，可以用下面的方法：intent.setDataAndType(data, type);例如：intent.setDataAndType(Uri.parse(\"wxy:\" + 110), \"audio/mp4\"); ####显式意图 通过制定具体的包名和类名来切换窗口 1234567public void click(View v){ Intent intent = new Intent(); //参数：packageName 包名, className 类名 intent.setClassName(\"com.wxy.hello\", \"com.wxy.hello.HelloActivity2\"); startActivity(intent);} 12// 更简洁的 切换窗口startActivity(new Intent(this, HelloActivity.class)); 开启自己应用的界面用显示意图，开启其他应用用隐式意图。 显式意图更加安全一些（仅自己能调用） ####传递数据切换 Activity 时传递数据 获取传递过来的数据 Uri getIntent(); 1Uri data = intent.getData(); // 例如 wxy:110 Intent.putExtra(name, value); value 支持Android八大类型的数据 存入数据 123Intent intent = new Intent(this, SecondActivity.class);intent.putExtra(\"name\", \"hhh\");intent.putExtra(\"sex\", 0); 取出数据 1234Intent intent = getIntent(); // 获取开启此Activity放入意图对象String name = intent.getStringExtra(\"name\");int sex = intent.getIntExtra(\"sex\", 0); // 参数二为默认值，可省textView.setTex(name); ####人品计算器 12345678910111213byte[] bytes = NULL;int total = 0;if (sex == 1) bytes = name.getBytes(\"GBK\");else bytes = name.getBytes(\"UTF-8\");for (byte b : bytes) { // 有多少个1 int number = b &amp; 0xff; // 1111 1111 total += number;}int score = Math.abs(total) % 100;if (score &gt; 90) { toast(\"您的人品爆棚！\"); break;} #####RadioGroup 12345&lt;RadioGroup ... &gt; &lt;Radio ... /&gt; &lt;Radio android:checked=\"checked\" /&gt;&lt;/RadioGroup&gt; 123RadioGroup rg = (RadioGroup) findViewByUd(R.id.rg);int res = rg.getCheckedRadioButtonId(); // 获取选中的单选框ID(可不选)if (res == NULL) { ; } 短信发送器制作一个能够发送短信模板的小应用。 ####简单的 ListView 1234String msgs[] = {\"短信1\", \"短信2\", \"短信3\", ...};ListView lv = (ListView) findViewById(R.id.lv);ArrayAdapter&lt;String&gt; adapter = new ArrayAdapter&lt;String&gt;(this, R.layout.item, msg); // layout/item 里面就只有一个 TextViewlv.setAdapter(adapter); ####设置 ListView 事件 12345678910111213141516171819// 给 ListView 设置事件lv.setonItemClickListener(new onItemClickListener(){ // 点击列表发送短信 // 参数一：&lt;?&gt;ListView；参数二：每个条目（这里是TextView） @Override public void onItemClickListener(AdapterView&lt;?&gt; parent, View view, int position, long id) { // 条目内容 String content = msgs[position]; // 跳转到短信发送页面 Intent intent = new Intent(); intent.setAction(\"android.intent.action.SEND\"); intent.addCategory(\"android.intent.category.DEFAULT\"); intent.setType(\"text/plain\"); intent.putExtra(\"sms_body\", content); // 设置短信内容 startActivity(intent); } }); ####请求码和结果码 自定义短信模板页面并插入 123456789101112131415161718192021222324252627// 跳转到发送短信模板页面public void addTemplate(View v){ Intent intent = new Intent(this, SmsActivity.class); startActivityForResult(intent, 1); // 请求码 = 2}// 当开启的 Activity 页面关闭的时候，调用这个方法@Overrideprotected void onActivityResult(int requestCode, int resultCode, Intent data){ if (requestCode == 1) // 请求码 { ; // 代表请求的是哪个页面的数据 } if (resultCode == 10) // 结果码 { // 说明数据是从短信模板页面返回的 String msg = data.getStringExtra(\"msg\"); edit_num.setText(\"msg\"); } super.onActivityResult(requestCode, resultCode, data);} 选择模板页面 12345678910111213lv.setOnItemClickListener(newOnItemClickListener(){ @Overridepublic void onItemClickListener(AdapterView&lt;?&gt; parent, View view, int position, long id) { String msg = msgs.get(position).getPhone(); Intent intent - new Intent(); intent.putExtra(\"msg\", msg); setResult(10, intent); // 返回的结果码 = 10 // 关闭当前页面 finish(); }}) ####发送短信 SmsManager 类添加权限 android.permission.SEND_SMS 1234String number, content;SmsManager sm = SmsManager.getDefault(); // 静态方法// 参数二：服务中心号码，NULL 则使用默认；参数四：广播(成功失败的结果)sm.sendTextMessage(number, null, content, NULL); 注：这个API有限制，英文70字符，中文140。太多不会发送，需要划分成多个片段。 ###Activity 生命周期 onCreate​ onResuart​ onStart 变成可视界面时​ onResume 允许获取焦点（按钮能点击等）​ onPause 不允许获取焦点​ onStop 界面不可见时onDestroy 打开其他 Activity：onPause onStart返回当前 Activity：onRestart onStart onResume ####设置横屏横竖屏切换时，会Destroy再Create。竖屏：portrait横屏：landscape&lt;activity android:screenOrientation=\"portrait\"&gt; ###任务栈 任务栈和 Activity 有关 进栈：打开一个 Activity出栈：关闭一个 Activity操作的 Activity 永远是栈顶的 任务栈是用来维护操作体验的 应用程序退出完是任务栈清空了 一般情况一个应用程序对应一个任务栈 ###Activity 的四种启动模式 &lt;activity android:launchMode=\"stander\" ... &gt; stander 每创建一次 Activity 就一个任务栈 singletop 若Activity在栈顶则复用原Activity，否则创建Activity singletask 一个 Activity 单一任务栈。浏览器。 singleinstance 有专属的任务栈，仅一个实例，不会重复创建。任务栈和任务栈之间再形成顺序。来电页面。 广播广播接收类名一般是 xxReceiver 格式退出程序后，进程还在，广播接受器还能收到广播 IP拨号器（加特定前缀能省话费） 权限：android.permission.OUTGONG_CALL 清单文件配置 123456789&lt;application&gt; ...... &lt;receiver android:name=\"com.包名.OutGoingCallReceiver\"&gt; &lt;intent-filter&gt; &lt;!-- 要接受的广播频道 --&gt; &lt;action android:name=\"android.intent.action.NEW_OUTGONG_CALL\" /&gt; &lt;/intent-filter&gt; &lt;/receiver&gt;&lt;/application&gt; 定义广播接受者（java类）若没有界面的话，可以不用编辑 MainActivity 1234567891011121314151617181920import android.content.BroadcastReceiver;public class OutGoingCallReceiver extends BroadcastReceiver { // 当进行外拨电话的时候调用 @Override public void onReceiver(Context context, Intent intent) { // 使用参数里的上下文来读取设置 SharedPreferences sp = context.getSharedPreferences(\"config\", 0); String IPnumber = sp.getString(\"IPnumber\", \"\"); // 获取当前拨打的电话号码 String number = getResultData(); // 判断当前号码是否是长途，在当前的号码前面加上前缀 if (currentNumber.startsWith(\"0\")) { setResultData(IPnumber + number); // 一般是能变更的前缀 } }} 主函数 设置用户手动输入的 IPnumber 1234567public void click(View v) { EditText et = (EditText) findViewById(R.id.et); String IPnumber = et.getText().toString().trim(); // 用户编辑的前缀好吗 SharedPreferences sp = getSharedPreferences(\"cinfig\", 0); sp.edit().putString(\"IPnumber\", IPnumber).commit(); Toast.makeText(getApplicationContext, \"保存成功\", 1).show();} SD卡状态的监听12345678&lt;receiver android:name=\"包名.AdcardStateReceiver\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.MEDIA_MOUNTED\" /&gt; &lt;action android:name=\"android.intent.action.MEDIA_UNMOUNTED\" /&gt; &lt;!-- 必须指定一个叫 file 的约束，否则不生效 --&gt; &lt;data android:scheme=\"file\" /&gt; &lt;/intent-filter&gt;&lt;/receiver&gt; 小细节：SD卡里面存的数据类型是 file，所以需要 file 约束。另一个要配置data的广播事件是 安装应用 12345678910111213141516import android.content.BroadcastReceiver;public class SdcardStateReceiver extends BroadcastReceiver { @Override public void onReceive(Context context, Intent intent) { // 获取当前广播的事件类型 Strning action = intent.getAction(); if (\"android.intent.action.MEDIA_MOUNTED\".equals(action)) { // SD卡挂在 } else if (\"android.intent-filter.action.MEDIA_UNMOUNTED\".equals(action)) { // SD卡卸载 } }} 短信监听器权限：android.permission.RECEIVE_SMS 1&lt;action android:name=\"android.provider.Telephony.SMS_RECEIVED\" /&gt; 123456789101112@Overridepublic void onReceive(Context context, Intent intent) { // 获取发送的号码和内容 Object[] objects = (Objectp[]) intent.getExtras().get(\"pdus\"); for (Object obj : objects) { // 获取 smsmessage 实例：这是调用静态方法而不是 new 出来的 SmsMessage smsMessage = SmsMessage.createFromPdu((byte[]) boj); // 获取短信内容 String messageBody = smsMessage.getMessageBody(); String address = smsMessage.getOriginatingAddress(); }} 卸载安装实例这个也要配置 data 1234&lt;action android:name=\"android.intent.action.PACKAGE_INSTALL\" /&gt;&lt;action android:name=\"android.intent.action.PACKAGE_ADDED\" /&gt;&lt;action android:name=\"android.intent.action.PACKAGE_REMOVED\" /&gt;&lt;data android.scheme=\"package\" /&gt; 1234567891011121314public void onReceive(Context context, Intent intent) { String action = intent.getAction(); if (\"android.intent.action.PACKAGE_INSTALL\".equals(action)) { // 应用安装（预留的字符串，并没有什么用） } else if (\"android.intent.action.PACKAGE_ADDED\".equals(action)) { // 应用安装了 String packageName = intent.getData(); // 应用包名 } else if (\"android.intent.action.PACKAGE_REMOVED\".equals(action)) { // 应用卸载了 }} 手机重启实例不能在广播接收者里面开启 activity需要添加一个任务栈的标记 权限：anroid.permission.RECEIVE_BOOT_COMPLETED 1&lt;action android:name=\"android.intent.action.BOOT_COMPLETED\" /&gt; 12345678910111213public class BootReceiver extends BroadcastReceiver { // 当手机重新启动的时候调用 @Override public void onReceive(Context context, Intent intent) { // 在这个方法里面开启 activity Intent intent2 = new Intent(context, MainActivity.class); intent2.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK); // 开启 activity context.startActivity(intent2); }} 12345// Activity 里屏蔽返回键@Overridepublic void onBackPressed() { ; // 覆盖父类返回方法} 广播类型有序广播：按照一定的优先级进行接收，在接收的过程中可以被修改或者终止 无序广播：不可以被修改或者终止 特殊广播：不能在清单文件中注册，需要动态注册 无序广播发送无序广播 123456789public void click(View v) { Intent intent = new Intent(); intent.setAction(\"com.HHH\"); intent.putExtra(\"name\", \"HHH\"); sendBroadcast(intent); // 发送无序广播} 接收无序广播 1&lt;action name=\"com.HHH\" /&gt; 1234// 当接收到自定义广播public onReceive(Context context, Intent intent) { String context = intent.getStringExtra(\"name\"); // 广播内容} 有序广播发送有序广播 12// 参数：Intent, 权限，最终的receiver，scheduler，初始码，初始化数据，额外的数据sendOrderedBroadcast(intent, null, null, null, 1, \"这是广播\", null); 123456789101112131415161718192021222324&lt;application ... &gt; &lt;activity&gt; ... &lt;/activity&gt; &lt;!-- 配置广播接受优先级 范围 -1000~1000 --&gt; &lt;receiver android:name=\"包名.FirstReceiver\"&gt; &lt;intent-filter android:priority=\"1000\"&gt; &lt;action android:name=\"myReceiver\" /&gt; &lt;/intent-filter&gt; &lt;/receiver&gt; &lt;receiver android:name=\"包名.SecondReceiver\"&gt; &lt;intent-filter android:priority=\"0\"&gt; &lt;action android:name=\"myReceiver\" /&gt; &lt;/intent-filter&gt; &lt;/receiver&gt; &lt;receiver android:name=\"包名.LastReceiver\"&gt; &lt;intent-filter android:priority=\"-200\"&gt; &lt;action android:name=\"myReceiver\" /&gt; &lt;/intent-filter&gt; &lt;/receiver&gt;&lt;/application&gt; 按顺序接收广播 123456789101112131415161718192021public class FirstReceiver extends BroadcastReceiver { @Override public onReceive(Context context, Intent intent) { String content = getResultData(); setResultData(\"哈哈哈\"); // 修改广播内容，后面接收到的就是这个内容 }}public class SecondReceiver extends BroadcastReceiver { @Override public onReceive(Context context, Intent intent) { abortBroadcast(); // 直接终止广播，下面接收不到了 }}public class LastReceiver extends BroadcastReceiver { @Override public onReceive(Context context, Intent intent) { }} 特殊广播接收者操作特别频繁的广播事件，比如 屏幕的锁屏和解锁、电池电量的变化，这种事件的广播在清单文件里面是注册无效的，可以动态注册广播 注册广播接受者的两种方式： 在清单文件通过 receiver tag 节点 动态注册：代码方式（即清单方式注册无效，并且无需注册） 类似于android.intent.action.SCREEN_ON 或 android.intent.action.SCREEN_OFF 这种，注册是无效的 12345678910111213141516171819202122232425262728293031323334public class MainActivity extends Activity { // 动态的去注册广播接收者，设为全局方便销毁 ScreenReceiver screenreceiver = new ScreenReceiver(); @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); // 创建 Intent-Filter 对象 IntentFilter filter = new IntentFilter(); // 动态注册广播（可以添加多个） filter.addAction(\"android.intent.action.SCREEN_OFF\"); filter.addAction(\"android.intent.action.SCREEN_ON\"); registerReceiver(screenReceiver, filter); } @Override protected void onDestory() { // activity 销毁时要取消注册广播 unregisterReceiver(screenreceiver); }}public class ScreenReceiver extends BroadcastReceiver { @Override public onReceive(Context context, Intent intent) { } 样式和主题样式样式一般作用在控件上 style 文件 12345&lt;style name=\"myStyle\"&gt; &lt;item name=\"android:layout_height\"&gt;match_parent&lt;/item&gt; &lt;item name=\"android:textSize\"&gt;20SP&lt;/item&gt; &lt;item name=\"android:textColor\"&gt;#ff000&lt;/item&gt;&lt;/style&gt; layout 文件 123&lt;TextView style=\"@style/mystyle\" android:text=\"哈哈哈\" /&gt; 主题样式一般作用在 Activity 或 Application 节点下 style 文件 123&lt;style name=\"myStyle\"&gt; &lt;item name=\"android:background\"&gt;#ff0000&lt;/item&gt;&lt;/style&gt; manifest 文件 12&lt;application android:theme=\"@style/mystyle\"&gt; 区别两者定义的方式是一样的。 样式的作用范围比较窄，主题比较大。 不一定要在 style.xml 上定义，其他类似 txt 上也行。 Android 国际化国际化：i18n 类似于android:text=\"你好世界\"这种硬编码的字符串，一般都是放到string.xml里面 多国语言文件：res目录下的values-语言代码文件夹里面的string.xml （固定写法）语言代码：en英语，zh中文简体，zh-Hant中文繁体……例如：/res/values-zh/string.xml 表示中文资源 对话框常见对话框 Toast 普通对话框 单选对话框 多选对话框 进度条对话框 普通对话框1234567891011121314151617// 通过 builder 构建器来构造AlertDialog.Builder builder = new Builder(this); // 不能用 getApplicationContext()builder.setTitle(\"提示\");builder.setMessage(\"这里是提示内容\");builder.setPositiveButton(\"确定\", new OnClickListener() { @Override public void onClick(DialogInterface dialog, int which) { System.out.println(\"点击了确定按钮\"); } });builder.setNegativeButton(\"取消\", new OnClickListener() { @Override public void onClick(DialogInterface dialog, int which) { System.out.println(\"点击了取消按钮\"); } });builder.show(); // 一定要 show 出来 如果报错，则把new OnClickListener(){} 改成new DialogInterface.OnClickListener(){} 两种上下文的区别 this （即：类名.this） getApplicationContext() 返回的是 Context 对象 getApplicationContext() 获取的是整个应用上下文，this 是其子类，子类有的父类不一定有。 this 多了token（令牌）。 就对话框来说，必须要用 this，否则会报错。 单选对话框12345678910111213AlertDialog.Builder builder = new Builder(this);builder.setTitle(\"请选择\");String items[] = { \"item1\", \"item2\"};// 参数二：checked 选中索引，-1 为没有选中builder.setSingleChoiceItems(items, -1, new OnClickListener() { @Override public void onClick(DialogInterface dialog, int which) { System.out.println(\"您选择了\" + items[which]); // 关闭对话框：点一下就关掉，不需要确定按钮 dialog.dismiss(); } }); builder.show(); 多选对话框注意：listener 是OnMultiChoiceClickListener 1234567891011121314151617181920212223242526272829AlertDialog.Builder builder = new Builder(this);String items[] = {\"item1\", \"item2\", \"item3\"};Boolean[] checkedItems = {true, false, true};builder.setMultiChoiceItems(items, checkedItems, new OnMultiChoiceClickListener() { @Override public void onClick(DialogInterface dialog, int which, boolean isChecked) { System.out.println(\"您点击了\" + items[which]); // 关闭对话框：点一下就关掉，不需要确定按钮 dialog.dismiss(); } });builder.setPositiveButton(\"确定\", new OnClickListener() { @Override public void onClick(DialogInterface dialog, int which) { // 把选中的条目数据取出来 StringBuffer sb = new StringBuffer(); for (int i = 0; i &lt; checkedItems.length; i++) { if (checkedItems[i]) { sb.append(items[i] + \" \"); } } Toast.makeText(getApplicationContext(), sb.toString(), 1).show(); // 关闭对话框 dialog.dismiss(); } });builder.show(); 进度条对话框12345ProgressDialog dialog = new ProgressDialog(this);dialog.setTitle(\"正在加载中\");// 设置进度条样式dialog.setProgressStyle(style);dialog.show(); style 属性有： ProgressDialog.STYLE_HORIZONTAL 横向进度条，0% 和进度相关的控件，都能在子线程中更新UI 1234567891011121314151617181920212223242526ProgressDialog dialog = new ProgressDialog(this);dialog.setTitle(\"正在加载中\");// 设置进度条样式dialog.setProgressStyle(ProgressDialog.STYLE_HORIZONTAL);dialog.show();// 创建一个子线程new Thread() { public void run() { // 设置最大值 dialog.setMax(100); // 耗时操作，设置进度 for (int i = 0; i &lt; 100; i++) { // 睡眠 50 ms SystemClock.sleep(50); // 设置当前进度 dialog.setProgress(i); } // 关闭对话框 dialog.dismiss(); }}.start(); 帧动画Android 中动画 帧动画 View 动画（补间动画） 属性动画 帧动画：加载一系列的图片资源 xml 文件在res/drawable/directory目录下，标签是&lt;animation-list&gt; res/drawable/myanim.xml 文件 1234567891011121314151617&lt;animation-list xmlns:android=\"...\" androidLoneshot=\"true\"&gt; &lt;!-- true 表示只执行一次，false 循环播放 --&gt; &lt;item android:drawable=\"@drawable/pic_1\" android:duration=\"200\" /&gt; &lt;item android:drawable=\"@drawable/pic_2\" android:duration=\"200\" /&gt; &lt;item android:drawable=\"@drawable/pic_3\" android:duration=\"200\" /&gt; &lt;item android:drawable=\"@drawable/pic_4\" android:duration=\"200\" /&gt;&lt;/animation-list&gt; java文件 12345678910ImageView rocketImage = (ImageView) findViewById(R.id.rocketImage);// 设置背景资源rocketImage.setBackgroundResource(R.drawable.myanim);// 获取 AnimationDrawable 类型AnimationDrawable rocketAnimation = (AnimationDrawable) rocketImage.getBackground();// 开启动画rocketAnimation.start(); 兼容低版本 2.3 因为数据并未准备好，这个 API 是 2.3 之后出的 1234567891011121314151617ImageView rocketImage = (ImageView) findViewById(R.id.rocketImage);// 设置背景资源rocketImage.setBackgroundResource(R.drawable.myanim);// 兼容低版本的写法new Thread(){ public void run() { SystemClock.sleep(100); // 获取 AnimationDrawable 类型 AnimationDrawable rocketAnimation = (AnimationDrawable) rocketImage.getBackground(); // 开启动画 rocketAnimation.start(); }}.start(); 服务服务在后台运行，没有界面 Service extends CpntextWrapper implements ... 进程 前台进程 可视进程 服务进程 后台进程 空进程 start方式开启服务清单文件 1234&lt;application ...&gt; &lt;activity ...&gt; ... &lt;/activity&gt; &lt;service android:name=\"包名.服务名\"&gt;&lt;/service&gt;&lt;/application&gt; MyService.java 12345678910111213141516171819202122232425public class MyService extends Service { @Override public Ibinder onBind(Intent intent) { return null; } // 服务第一次创建的时候调用 @Override public void onCreate() { super.onCreate(); } // 服务运行 @Override public int onStartCommand(Intent intent, int flags, int startId) { return super.StartCommand(intent, flags, startId); } // 服务销毁 @Override public void onDestroy() { super.onDestroy; }} MainActivity.java 12345// 开启服务，一直后台运行直到用户手动关闭startService(new Intent(this, MyService.class));// 结束服务stopService(new Intent(this, MyService.class)); start方式开启服务的特点 定义四大组件的方式是一样的 定义一个类继承Service 第一次开启服务，会执行 onCreate 和 onStart 方案 第二次开启服务，会执行 onStart 方法 服务一定开启，就会长期后台运行，直到用户手动停止 电话监听器 定义一个服务，开启服务。（记得在清单文件中配置服务） 在服务的 onCreate 里面获取 TelephonyManager 注册电话的监听 定义一个类用来判断电话的状态 TelephoneManager 监视电话的状态的改变 权限：&lt;uses-permission android:name=\"android.permission.READ_PHONE_STATE\" /&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445public class PhoneService extends Service { @Override Ibinder onBind(Intent intent) { return null; } @Override public void onCreate() { // 获取 telephonemanager 的实例 TelephonyManager tm = (TelephonyManager)getSystemService(TELEPHONY_SERVICE); // 注册电话的监听 tm.listen(new MyPhoneStateListener(), PhoneStateListener.LISTEN_CALL_STAT) super.onCreate(); } @Override public void onDestroy() { super.onDestroy(); } private class MyPhoneStateListener extends PhoneStateListener { // 当电话设备状态发生改变的时候调用 @Override public void onCallStateChanged(int state, String incomingNumber) { // 具体判断一下电话的状态 switch (state) { case TelephonyManager.CALL_STATE_IDLE: // 空闲 // 停止录音 break; case TelephonyManager.CALL_STATE_OFFHOOK: // 接听 // 开始录音 break; case TelephonyManager.CALL_STATE_RINGING: // 响铃 // 准备一个录音机 break; } } } {}} 录音机录音需要权限：&lt;uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\" /&gt;&lt;uses-permission android:name=\"android.permission.RECORD_AUDIO\" /&gt; 1234567891011121314151617181920212223242526272829// 创建实例，全局MediaRecorder recorder = new MediaRecorder();// 设置音频来源（麦克风MIC、外置声音VOICE_CALL)recorder.setAudioSource(MediaRecorder.AudioSource.MIC); // 外国违法// 设置输出格式 3GP(THREE_GPP)、MPEG_4 等recorder.setOutputFormat(MediaRecorder.OutputFormat.THREE_GPP);// 设置音频编码方式recorder.setAudioEncoder(MediaRecorder.AudioEncoder.AMR_NB);// 设置存放路径recorder.setOutputFile(\"/mnt/sdcard/luyin.3gp\");// 准备录try { recorder.prepare();}// 开始录recorder.start();// 停止录if (recorder != null){ recorder.stop(); recorder.reset(); recorder.release();} 使用服务注册特殊的广播接收者 定义广播接收者 写个服务用来注册广播接收者 在MainActivity里面开启服务 一定要记得配置服务 MainActivity.java 1234onCreate() { Intent intent = newe Intent(this, ScreenService.class); startService(intent);} ScreenService.java 1234567891011121314151617181920// 动态注册和销毁广播private ScreenReceiver receiver = new ScreenReceiver();public void onCreate() { // 服务创建时注册广播接收者 IntentFilter filter = new IntentFilter(); filter.addAction(\"android.intent.action.SCREEN_OFF\"); filter.addAction(\"android.intent.action.SCREEN_ON\"); registerReceiver(receiver, filter) super.onCreate();}onDestroy() { // 服务销毁的时候取消广播接收者 unregisterReceiver(receiver); super.onDestroy();} ScreenReceiver.java 12345678910111213public class ScreenReceiver extends BroadcastReceiver{ @Override public void onReceive(Context context, Intent intent) { // 获取当前的事件类型 String acation = intent.getAction(); if (\"android.intent.action.SCREEN_OFF\".equals(action)) ; // 锁屏 else if (\"android.intent.action.SCREEN_ON\".equals(action)) ; // 解锁 }} bind 方式开启服务bindService(service, conn, flags); 点击按钮绑定服务 MainActivity.java 1234567891011121314151617181920212223242526272829303132MyConn conn;public void click(View v){ // 或者放到 onCreate 方法里面 Intent intent = new Intent(this, MyService.class); conn = new MyConn(); bindService(intent, conn, BIND_AUTI_CREATE);// 只能绑定一次}// 定义一个类，用来监视服务的状态private void MyConn extends ServiceConnection{ // 当服务连接成功 @Override public void onServiceConnected(ComponentName name, IBinder serviec) { ; } // 失去连接 @Override public void onServiceDisconnected(ComponentName name) { ; }}// 服务和活动绑定，销毁的时候必须手动解绑（同样不可以多次解绑）protected void onDestroy() { unbindService(conn); super.onDestroy();} MyService.java 123456// 当绑定服务的时候public IBinder onBinder(Intent intent) { // 当这个方法返回值为null的时候，onServiceConnected方法一不执行的 // return null;} bind方法开启服务的特点 点击按钮（或执行操作）后，会此项服务的onCreate方法和onBind方法 当onBind方法返回null的时候，onServiceConnected方法是不执行的 第二次点击按钮，服务没有响应 activity和service之间，不求同时生，但求同时死…… 服务多次解绑会报异常 设置页面里面不能找到bind方式开启的服务，相当于隐形的服务 为什么要引入 bindService在 Activity 里面调用 Service 的方法 Binder 是一个接口。 MyService.java 12345678910111213141516@Overridepublic IBinder onbind(Intent intent) { return new MyBinder;}// 要调用的方法public void f() { ;}public class MyBinder extends Binder() { public void callF() { // 调用 f 的方法 f(); }} MainActivity.java 123456789101112131415161718192021222324252627282930313233343536MyConn conn;private MyBinder myBinder; // （中间对象）public void onCreate(...){ Intent intent = new Intent(this, MyService.class); conn = new MyConn(); bindService(intent, conn, BIND_AUTI_CREATE);// 只能绑定一次}// 定义一个类，用来监视服务的状态private void MyConn extends ServiceConnection{ // 当服务连接成功 @Override public void onServiceConnected(ComponentName name, IBinder serviec) { myBinder = (MyBinder) service; // 拿到中间对象，从而可以调用服务里的某个方法 } // 失去连接 @Override public void onServiceDisconnected(ComponentName name) { ; }}public void click() { myBinder.callF(); // 间接调用服务的方法}// 服务和活动绑定，销毁的时候必须手动解绑（同样不可以多次解绑）protected void onDestroy() { unbindService(conn); super.onDestroy();} 通过接口调用服务里面的方法接口可以隐藏代码内部的细节，让程序员只暴露自己想暴露的方法 把想暴露的方法都定义在接口里面 Binder对象实现我们定义的方法 把获取到的IBinder对象转换成暴露部分方法的接口 Iservice.java （I 开头表示是一个接口） 1234public interface Iservice { // 只暴露一个 f1，没有 f2 public void callF1();} MyService.java 12345678910public void f1() { }public void f2() { }// 把 public 改成 privateprivate class MyBinder extends Binder implements Iservice { public void callF1() { } public void callF2() { }} MainActivity.java 12345678910111213141516private MyConn conn;private Iservice myBinder; // 中间对象private calss MyConn implements ServiceConnection { @Override public void onServiceConnected(ComponentName name, IBinder service) { // 类型转换成 Iservice myBinder = (Iservice) service; }}public void click(View v) { myBinder.callF1(); // 可以 // myBinder.callF2(); // 不可以} 混合方式开启服务既能在后台长期运行，又能调用服务里面的方法 start 方法开启服务 调用 bindService 获取中间对象 调用 unbindService 解绑服务 彻底退出时 stopService 百度音乐盒框架123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129/* ==== MainActivity.java ==== */public void MainActivity extends Activity { private MyConn conn; private Iservice iservice; // 定义的 Binder 对象 @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentVIew(R.layout.activity_main); // 混合方式开启服务 Intent intent = new Intent(this, MusicService.class); startService(intent); conn = new MyConn(); bindService(intent, conn, BIND_AUTO_CREATE); } // 监听服务状态 private class MyConn { @Override public void onServiceConnected(ComponentName name, IBinder service) { // 获取定义的 Binder 对象 iservice = (Iservice) service; } } public void playButton(View v) { // 播放音乐 iservice.callPlayMusic(); } public void pauseButton(View v) { // 暂停音乐 iservice.callPauseMusic(); } public void rePlayButton(View v) { // 继续播放音乐 iservice.callRePlayMusic(); } @Override protected void onDestroy() { unbindService(conn); super.onDestroy(); }}/* ==== MusicService.java ==== */public class MusicService extends Service { @Override public Ibinder onBind(Intent intent) { return null; } // 服务第一次创建的时候调用 @Override public void onCreate() { super.onCreate(); } // 服务运行 @Override public int onStartCommand(Intent intent, int flags, int startId) { return super.StartCommand(intent, flags, startId); } // 服务销毁 @Override public void onDestroy() { super.onDestroy; } // 播放音乐 public void playMusic() { ; } // 暂停音乐 @Override public void pauseMusic() { ; } // 继续播放 @Override public void rePlayMusic() { ; } // 在服务内部定义一个 IBinder 类的实现 private class MyBinder extends Binder implements Iservice{ @Override public void callPlayMusic() { playMusic(); } @Override public void callPauseMusic() { pauseMusic(); } @Override public void callRePlayMusic() { rePlayMusic(); } }}/* ==== Iservice.java ==== */public interface Iservice { // 想暴露的方法 public void callPlayMusic(); public void callPauseMusic(); public void callRePlayMusic();} AIDL 介绍 本地服务：运行在自己应用里面的服务 远程服务：运行在其他应用里面的服务 实现进程间通讯（IPC） AIDL：安卓接口定义语言，专门用来解决进程间通讯 每个应用都要配置服务。其中一个定义 IBinder 把 Iservice.java 文件重命名为 Iservice.aidl。 aidl 不认识 public，所以这个关键词要去掉 会自动生成Iservice.java，里面有个类叫 Stub MyBinder 直接继承 Stub 两个应用的 aidl 文件包名相同 Stub.asInterface(service); 1234567891011121314151617181920Iservice iservice;onCreate() { Intent intent = new Intent(); Intent.setAction(\"目标应用的包名\"); MyConn conn = new MyConn(); bindService(intent, conn, BIND_QUTO_CREATE);}private class MyConn implements ServiceConnection { @Override public void onServiceConnected(ComponentName name, IBinder service) { iservice = Stub.asInterface(service); }}public void click(View v) { iservice.callF();} 1234567private class MyBinder extends Stub { // ... public void callF() { f(); }} Iservice.aidl 123interface Iservice { void f();} AIDL 的应用场景类似调用支付宝进行支付 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109import android.os.Bundle;public class MainActivity extends Activity { private MyCon conn; private Iservice iservice; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Intent intent = new Intent(); intent.setAction(\"com.test.pay\"); conn = new MyConn(); bindService(intent, conn, BIND_AUTO_CREATE); } public void payClick() { try { boolean result = iservice.callPay(\"abc\", \"123\", 1000); if (result) { Toast.makeText(getApplicationContext(), \"支付成功\", 1).show(); } else { Toast.makeText(getApplicationContext(), \"支付失败\", 1).show(); } } catch (RemoteException e) { e.printStackTrace(); } } private class MyConn implements ServiceConnection { @Override public void onServiceConnected(ComponentName name, IBinder service) { iservice = Stub.asInterface(service); } @Override public void onServiceDisconnected(ComponentName name) { ; } } @Override protected void onDestroy() { unbinderService(conn); super.onDestroy() }}// =================PayService.java===================import android.app.Service;public class PayService extends Service { @Override publci IBinder onBind(Intent intent) { return new MyBinder(); } // 支付的方法 publci void pay(String username, String pwd, int money) { // 检查账号密码安全性等 if (\"abc\" . equals(username) &amp;&amp; \"123\" . equals(pwd) &amp;&amp; money &lt;= 5000) { return true; } else { return false; } }}private class MyBinder extends Stub /*Binder implements Iservice*/ { @Override public boolean callPay(String username, String pwd, int money) { return pay(username, pwd, money); }}// ==============Iservice.aidl===================// 用来支付的应用也要 Iservice.aidl/*public*/ interface Iservice { /*public*/ boolean callPay(String username, String pwd, int money) { pay(); }}// ====================Manifest==================&lt;service android:name=\"com.test.pay.PayService\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"com.test.pay\" /&gt; &lt;/intent-filter&gt;&lt;/service&gt; 内容提供者(contentProvider)作用：在app2中读取app1的数据库(暴露私有的数据库) 使用： 建一个类，继承 contentProvider。 在清单文件中配置 添加静态代码块 暴露你想暴露的方法（增删改查） 其他应用就能用内容解析者去操作数据库 暴露方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import android.content.ContentProvider;public class MyProvider extends ContentProvider { // 定义一个 UriMather 路径匹配器 private static final UriMather sURIMather = new UriMather(UriMather.NO_MATH); private static final int QUERYSUCCESS = 0; private MyOpenHelper myOpenHelper; // 定义静态代码块，添加匹配规则 static { // sURIMather.addURI(authority/*清单文件里的自定义字符串*/, path, code/*int常量*/) // URI 路径：content://mystr/query sURIMather.addURI(\"mystr\", \"query\", QUERYSUCCESS); } @Override public boolean onCreate() { myOpenHelper = new MyOpenHelper(getContext()); return false; } @Override public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder) { int code = sURIMather.math(uri); if (code == QUERYSUCCESS) { // 路径匹配成功。不成功返回-1 // 对数据库进行查询的操作 SQLiteDatabase db = myOpenHelper.getReadableDatabase(); // db.query(table, columns/*别人能访问的列*/, selection, selectionArgs, groupBy, having, orderBy) Cursor cursor = db.query(\"info\", projection, selection, selectionArgs, null, null. sortOrder); // 注意：cursor 不能管 return cursor; } else { // 路径不匹配 throw new IlleagalArgumentException(\"路径不匹配\"); } } @Override public String getType(Uri uri) { return null; } @Override public Uri insert(Uri uri, ContentValues values) { return null; }} 123&lt;provider android:name=\"com.app1.MyProvider\" android:authorities=\"mystr\"&gt;&lt;/provider&gt; app2读取app1的数据库由于app1里面的私有数据库已经通过内容提供者的方式暴露出来了，所以app2可以直接通过内容的解析这进行访问 12345678910111213// 拿到内容的解析者// getContentResolver().query(uri, projection, selection, selectionArgs, sortOrder)Uri uri = Uri.parse(\"content://mystr/query\"); // 和app1定义的路径一样// Cursor cursor = db.query(\"info\", null, null, null, null, null, null, null);Cursor cursor = getContentResolver().query(uri, null, null, null, null);if (cursor != null &amp;&amp; cursor.getCount() &gt; 0) { while (cursor.moveToNext()) { String name = sursor.getString(1); String phone = cursor.getString(2); System.out.println(\"app2 name:\"+name+\";phone:\"+phone); }} 暴露增删改查app1 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596import android.content.ContentProvider;public class MyProvider extends ContentProvider { // 定义一个 UriMather 路径匹配器 private static final UriMather sURIMather = new UriMather(UriMather.NO_MATH); private static final int QUERYSUCCESS = 0; private static final int INSERTSUCCESS = 1; private static final int UPDATESUCCESS = 2; private static final int DELETESUCCESS = 3; private MyOpenHelper myOpenHelper; // 定义静态代码块，添加匹配规则 static { // sURIMather.addURI(authority/*清单文件里的自定义字符串*/, path, code/*int常量*/) // URI 路径：content://mystr/query sURIMather.addURI(\"mystr\", \"query\", QUERYSUCCESS); sURIMather.addURI(\"mystr\", \"insert\", INSERTSUCCESS); sURIMather.addURI(\"mystr\", \"update\", UPDATESUCCESS); sURIMather.addURI(\"mystr\", \"delete\", DELETESUCCESS); } @Override public boolean onCreate() { myOpenHelper = new MyOpenHelper(getContext()); return false; } @Override public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder) { int code = sURIMather.math(uri); if (code == QUERYSUCCESS) { // 路径匹配成功。不成功返回-1 // 对数据库进行查询的操作 SQLiteDatabase db = myOpenHelper.getReadableDatabase(); // db.query(table, columns/*别人能访问的列*/, selection, selectionArgs, groupBy, having, orderBy) Cursor cursor = db.query(\"info\", projection, selection, selectionArgs, null, null. sortOrder); // 注意：cursor 不能管 return cursor; } else { // 路径不匹配 throw new IlleagalArgumentException(\"路径不匹配\"); } } @Override public String getType(Uri uri) { return null; } @Override public Uri insert(Uri uri, ContentValues values) { int code = sURIMather.match(uri); if (code == INSERTSUCCESS) { // 路径匹配成功，操作数据库 SQLiteDatabase db = myOpenHelper.getReadableDatabase(); long ins = db.insert(\"info\"/*表名*/, null, values/*map&lt;String, String&gt;类型*/); // 返回插入的行数ID Uri uri2 = Uri.parse(\"插入的行号：\" + ins); return uri2; } else { // 路径不匹配 throw new IlleagalArgumentException(\"路径不匹配\"); } return null; } @Override public int delete(Uri uri, String selection, String[] selectionArgs) { int code = sURIMather.match(uri); if (code == DELETESUCCESS) { // 路径匹配成功，操作数据库 SQLiteDatabase db = myOpenHelper.getReadableDatabase(); int del = db.delete(\"info\", selection, selectionArgs); // 返回删除的行数 return del; // 返回的类型就是 int } else { // 路径不匹配 throw new IlleagalArgumentException(\"路径不匹配\"); } return null; } @Override public int delete(Uri uri, ContentValues values, String selection, String[] selectionArgs) { int code = sURIMather.match(uri); if (code == DELETESUCCESS) { // 路径匹配成功，操作数据库 SQLiteDatabase db = myOpenHelper.getReadableDatabase(); int upd = db.delete(\"info\", values, selection, selectionArgs); // 返回影响的行数 return upd; // 返回的类型就是 int } else { // 路径不匹配 throw new IlleagalArgumentException(\"路径不匹配\"); } return null; }} app2 12345678910111213141516171819202122public void toInsert() { Uri uri = Uri.parse(\"cintent://mystr/insert\"); ContentValues values = new ContentValues(); values.put(\"name\", \"123\"); values.put(\"money\", \"100\"); Uri ins = getContentResolver().insert(uri, values); System.out.println(\"insert:\"+ins);}public void toDelete() { Uri uri = Uri.parse(\"cintent://mystr/delete\"); int del = getContentResolver().insert(uri, \"name=?\", new String[]{\"asd\"}); Toast.makeText(getApplicationContext(), \"delete:\"+del, 1).show();}public void toUpdate() { Uri uri = Uri.parse(\"cintent://mystr/insert\"); ContentValues values = new ContentValues(); values.put(\"money\", \"100\"); int upd = getContentResolver().update(uri, values, \"nname=?\", new String[]{\"asd\"}); Toast.makeText(getApplicationContext(), \"update:\"+upd, 1).show();} 备份短信权限：WRITE_SMS READ_SMS READ_EXTERNAL_STORAGE 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// 短信数据库已经通过内容提供者暴露出来了public sms_backup() { // 获取 xml 序列化实例 XmlSerializer serializer = Xml.newSerializer(); // 设置序列化参数 File file = new File(Environment.getExternalStorageDirectory().getPath(), \"smsBackup.xml\"); FileOutputStream fos = new FileOutputStream（file); serializer.setOutput(fos, \"utf-8\"); // 开始写 xml 文档的开头 serializer.startDocument(\"utf-8\", true); { // 开始写根节点 serializer.startTag(null, \"smss\"); { Uri uri = Uri.parse(\"content://sms/\") // 不写后面的参数表示查询所有 Cursor cursor = getContentResolver().query(uri, new String[]{\"address\", \"date\", \"body\"}, null, null, null); while (cursor.moveToNext()) { String address = cursor.getString(0); String date = cursor.getString(1); String body = cursor.getString(2); // 写 sms 节点 serializer.startTag(null, \"sms\"); { // 写 address 节点 serializer.startTag(null, \"address\"); serializer.text(address); serializer.endTag(null, \"address\"); // 写 body 节点 serializer.startTag(null, \"body\"); serializer.text(body); serializer.endTag(null, \"body\"); // 写 date 节点 serializer.startTag(null, \"date\"); serializer.text(date); serializer.endTag(null, \"date\"); } serializer.endTag(null, \"sms\"); } } serializer.endTag(null, \"smss\"); } serializer.endDocument();} 插入短信通过内容提供者在短信的私有数据库中插入一条短信 权限：WRITE_SMS READ_SMS 123456Uri uri = Uri.parse(\"content://sms\");ContentValues values = new ContentValues();values.put(\"address\", \"110\");values.put(\"body\", \"报警\");values.put(\"date\", System.currentTimeMillis());getContentResolver().insert(uri, values); document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Android","slug":"Android","permalink":"http://blog.iwxyi.com/tags/Android/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://blog.iwxyi.com/tags/学习笔记/"}]},{"title":"Android使用高德地图","date":"2018-12-15T03:22:00.000Z","path":"2018/12/15/Android使用高德地图/","text":"1、要实现高德地图的定位，首先要下载高德地图的SDK 下载地址：http://lbs.amap.com/api/android-location-sdk/download/ 然后在高德地图官网上登录你注册的账号并且去控制台—–&gt;应用管理—–&gt;添加新key获取到自己的key值获取key的具体方法的官网地址 ：http://lbs.amap.com/ 2、通过解压得到.Jar文件并放到libs文件中，手动添加到依赖库中（右键Add—-） 3、如果你的地图SDK是3D的需要在main中创建 jniLibs 文件夹并把你解压出来的其他文件放到此处 4、开发环境已经配置好了，接下来就是敲代码了 导入高德SDK：https://lbs.amap.com/api/android-sdk/guide/create-project/android-studio-create-project 先下载所需要的SDK，然后把 jar 放进去。（只有 3D 地图才需要 so 库，其余不用放） 在工程的“ AndroidManifest.xml ”清单文件中添加key和Service 123&lt;meta-data android:name=\"com.amap.api.v2.apikey\"android:value=\"你申请的key\" /&gt;&lt;service android:name=\"com.amap.api.location.APSService\"&gt;&lt;/service&gt; 添加权限 1234567891011121314151617181920212223242526272829303132&lt;!--允许程序打开网络套接字--&gt; &lt;uses-permission android:name=\"android.permission.INTERNET\" /&gt; &lt;!--允许程序设置内置sd卡的写权限--&gt; &lt;uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\" /&gt; &lt;!--允许程序获取网络状态--&gt; &lt;uses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\" /&gt; &lt;!--允许程序访问WiFi网络信息--&gt; &lt;uses-permission android:name=\"android.permission.ACCESS_WIFI_STATE\" /&gt; &lt;!--允许程序读写手机状态和身份--&gt; &lt;uses-permission android:name=\"android.permission.READ_PHONE_STATE\" /&gt; &lt;!--用于进行网络定位--&gt; &lt;uses-permission android:name=\"android.permission.ACCESS_COARSE_LOCATION\"&gt;&lt;/uses-permission&gt; &lt;!--用于访问GPS定位--&gt; &lt;uses-permission android:name=\"android.permission.ACCESS_FINE_LOCATION\"&gt;&lt;/uses-permission&gt; &lt;!--用于获取wifi的获取权限，wifi信息会用来进行网络定位--&gt; &lt;uses-permission android:name=\"android.permission.CHANGE_WIFI_STATE\"&gt;&lt;/uses-permission&gt; &lt;!--用于读取手机当前的状态--&gt; &lt;uses-permission android:name=\"android.permission.READ_PHONE_STATE\"&gt;&lt;/uses-permission&gt; &lt;!--用于申请调用A-GPS模块--&gt; &lt;uses-permission android:name=\"android.permission.ACCESS_LOCATION_EXTRA_COMMANDS\"/&gt; &lt;!--获取运营商信息，用于支持提供运营商信息相关的接口--&gt; &lt;uses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\" /&gt; &lt;!--用于访问wifi网络信息，wifi信息会用于进行网络定位--&gt; &lt;uses-permission android:name=\"android.permission.ACCESS_WIFI_STATE\" /&gt; &lt;!--这个权限用于获取wifi的获取权限，wifi信息会用来进行网络定位--&gt; &lt;uses-permission android:name=\"android.permission.CHANGE_WIFI_STATE\" /&gt; &lt;!--用于访问网络，网络定位需要上网--&gt; &lt;uses-permission android:name=\"android.permission.INTERNET\" /&gt; &lt;!--用于读取手机当前的状态--&gt; &lt;uses-permission android:name=\"android.permission.READ_PHONE_STATE\" /&gt; &lt;!--写入扩展存储，向扩展卡写入数据，用于写入缓存定位数据--&gt; &lt;uses-permission android:name=\"android.permission.WRITE_EXTERNAL_STORAGE\" /&gt; acticity_main.xml布局文件 1234&lt;com.amap.api.maps.MapView android:id=\"@+id/map\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt;&lt;/com.amap.api.maps.MapView&gt; MainActivity代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176import android.os.Bundle;import android.support.v7.app.AppCompatActivity;import android.util.Log;import android.widget.Toast; import com.amap.api.location.AMapLocation;import com.amap.api.location.AMapLocationClient;import com.amap.api.location.AMapLocationClientOption;import com.amap.api.location.AMapLocationListener;import com.amap.api.maps.AMap;import com.amap.api.maps.CameraUpdateFactory;import com.amap.api.maps.LocationSource;import com.amap.api.maps.MapView;import com.amap.api.maps.UiSettings;import com.amap.api.maps.model.LatLng; import java.text.SimpleDateFormat;import java.util.Date; public class MainActivity extends AppCompatActivity implements LocationSource, AMapLocationListener { //AMap是地图对象 private AMap aMap; private MapView mapView; //声明AMapLocationClient类对象，定位发起端 private AMapLocationClient mLocationClient = null; //声明mLocationOption对象，定位参数 public AMapLocationClientOption mLocationOption = null; //声明mListener对象，定位监听器 private OnLocationChangedListener mListener = null; //标识，用于判断是否只显示一次定位信息和用户重新定位 private boolean isFirstLoc = true; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); //获取地图控件引用 mapView = (MapView) findViewById(R.id.map); //在activity执行onCreate时执行mMapView.onCreate(savedInstanceState)，实现地图生命周期管理 mapView.onCreate(savedInstanceState); if (aMap == null) { aMap = mapView.getMap(); //设置显示定位按钮 并且可以点击 UiSettings settings = aMap.getUiSettings(); aMap.setLocationSource(this);//设置了定位的监听 // 是否显示定位按钮 settings.setMyLocationButtonEnabled(true); aMap.setMyLocationEnabled(true);//显示定位层并且可以触发定位,默认是flase } //开始定位 location(); } private void location() { //初始化定位 mLocationClient = new AMapLocationClient(getApplicationContext()); //设置定位回调监听 mLocationClient.setLocationListener(this); //初始化定位参数 mLocationOption = new AMapLocationClientOption(); //设置定位模式为Hight_Accuracy高精度模式，Battery_Saving为低功耗模式，Device_Sensors是仅设备模式 mLocationOption.setLocationMode(AMapLocationClientOption.AMapLocationMode.Hight_Accuracy); //设置是否返回地址信息（默认返回地址信息） mLocationOption.setNeedAddress(true); //设置是否只定位一次,默认为false mLocationOption.setOnceLocation(false); //设置是否强制刷新WIFI，默认为强制刷新 mLocationOption.setWifiActiveScan(true); //设置是否允许模拟位置,默认为false，不允许模拟位置 mLocationOption.setMockEnable(false); //设置定位间隔,单位毫秒,默认为2000ms mLocationOption.setInterval(2000); //给定位客户端对象设置定位参数 mLocationClient.setLocationOption(mLocationOption); //启动定位 mLocationClient.startLocation(); } @Override protected void onDestroy() { super.onDestroy(); //在activity执行onDestroy时执行mMapView.onDestroy()，实现地图生命周期管理 mapView.onDestroy(); mLocationClient.stopLocation();//停止定位 mLocationClient.onDestroy();//销毁定位客户端。 } @Override protected void onResume() { super.onResume(); //在activity执行onResume时执行mMapView.onResume ()，实现地图生命周期管理 mapView.onResume(); } @Override protected void onPause() { super.onPause(); //在activity执行onPause时执行mMapView.onPause ()，实现地图生命周期管理 mapView.onPause(); } @Override protected void onSaveInstanceState(Bundle outState) { super.onSaveInstanceState(outState); //在activity执行onSaveInstanceState时执行mMapView.onSaveInstanceState (outState)，实现地图生命周期管理 mapView.onSaveInstanceState(outState); } @Override public void onLocationChanged(AMapLocation aMapLocation) { if (aMapLocation != null) { if (aMapLocation.getErrorCode() == 0) { //定位成功回调信息，设置相关消息 aMapLocation.getLocationType();//获取当前定位结果来源，如网络定位结果，详见官方定位类型表 aMapLocation.getLatitude();//获取纬度 aMapLocation.getLongitude();//获取经度 aMapLocation.getAccuracy();//获取精度信息 SimpleDateFormat df = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\"); Date date = new Date(aMapLocation.getTime()); df.format(date);//定位时间 aMapLocation.getAddress();//地址，如果option中设置isNeedAddress为false，则没有此结果，网络定位结果中会有地址信息，GPS定位不返回地址信息。 aMapLocation.getCountry();//国家信息 aMapLocation.getProvince();//省信息 aMapLocation.getCity();//城市信息 aMapLocation.getDistrict();//城区信息 aMapLocation.getStreet();//街道信息 aMapLocation.getStreetNum();//街道门牌号信息 aMapLocation.getCityCode();//城市编码 aMapLocation.getAdCode();//地区编码 // 如果不设置标志位，此时再拖动地图时，它会不断将地图移动到当前的位置 if (isFirstLoc) { //设置缩放级别 aMap.moveCamera(CameraUpdateFactory.zoomTo(17)); //将地图移动到定位点 aMap.moveCamera(CameraUpdateFactory.changeLatLng(new LatLng(aMapLocation.getLatitude(), aMapLocation.getLongitude()))); //点击定位按钮 能够将地图的中心移动到定位点 mListener.onLocationChanged(aMapLocation); //添加图钉 // aMap.addMarker(getMarkerOptions(amapLocation)); //获取定位信息 StringBuffer buffer = new StringBuffer(); buffer.append(aMapLocation.getCountry() + \"\" + aMapLocation.getProvince() + \"\" + aMapLocation.getCity() + \"\" + aMapLocation.getProvince() + \"\" + aMapLocation.getDistrict() + \"\" + aMapLocation.getStreet() + \"\" + aMapLocation.getStreetNum()); Toast.makeText(getApplicationContext(), buffer.toString(), Toast.LENGTH_LONG).show(); isFirstLoc = false; } } else { //显示错误信息ErrCode是错误码，errInfo是错误信息，详见错误码表。 Log.e(\"AmapError\", \"location Error, ErrCode:\" + aMapLocation.getErrorCode() + \", errInfo:\" + aMapLocation.getErrorInfo()); Toast.makeText(getApplicationContext(), \"定位失败\", Toast.LENGTH_LONG).show(); } } } @Override public void activate(OnLocationChangedListener onLocationChangedListener) { mListener = onLocationChangedListener; } @Override public void deactivate() { mListener = null; }} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Android","slug":"Android","permalink":"http://blog.iwxyi.com/tags/Android/"}]},{"title":"Android取时间戳","date":"2018-12-14T03:21:00.000Z","path":"2018/12/14/Android取时间戳/","text":"取13位时间戳都是毫秒级的（13位），用long存 123456//方法 一System.currentTimeMillis();//方法 二（速度最慢）Calendar.getInstance().getTimeInMillis();//方法 三new Date().getTime(); 取当前时间12SimpleDateFormat df = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");//设置日期格式String date = df.format(new Date());// new Date()为获取当前系统时间，也可使用当前时间戳 date类型转换为String类型12345// formatType格式为yyyy-MM-dd HH:mm:ss//yyyy年MM月dd日 HH时mm分ss秒// data Date类型的时间public static String dateToString(Date data, String formatType) { return new SimpleDateFormat(formatType).format(data);} long类型转换为String类型12345678// currentTime要转换的long类型的时间// formatType要转换的string类型的时间格式public static String longToString(long currentTime, String formatType) throws ParseException { Date date = longToDate(currentTime, formatType); // long类型转成Date类型 String strTime = dateToString(date, formatType); // date类型转成String return strTime;} string类型转换为date类型12345678910// strTime要转换的string类型的时间，formatType要转换的格式yyyy-MM-dd HH:mm:ss//yyyy年MM月dd日 // HH时mm分ss秒， // strTime的时间格式必须要与formatType的时间格式相同 public static Date stringToDate(String strTime, String formatType) throws ParseException { SimpleDateFormat formatter = new SimpleDateFormat(formatType); Date date = null; date = formatter.parse(strTime); return date; } long转换为Date类型123456789// currentTime要转换的long类型的时间 // formatType要转换的时间格式yyyy-MM-dd HH:mm:ss//yyyy年MM月dd日 HH时mm分ss秒 public static Date longToDate(long currentTime, String formatType) throws ParseException { Date dateOld = new Date(currentTime); // 根据long类型的毫秒数生命一个date类型的时间 String sDateTime = dateToString(dateOld, formatType); // 把date类型的时间转换为string Date date = stringToDate(sDateTime, formatType); // 把String类型转换为Date类型 return date; } String类型转换为long类型12345678910111213// strTime要转换的String类型的时间// formatType时间格式// strTime的时间格式和formatType的时间格式必须相同public static long stringToLong(String strTime, String formatType) throws ParseException { Date date = stringToDate(strTime, formatType); // String类型转成date类型 if (date == null) { return 0; } else { long currentTime = dateToLong(date); // date类型转成long类型 return currentTime; }} date类型转换为long类型1234// date要转换的date类型的时间public static long dateToLong(Date date) { return date.getTime();} 获取日期时间数值123456789101112131415public static void main(String[] args) { Calendar c = Calendar.getInstance();// mYear = c.get(Calendar.YEAR); // 获取当前年份 mMonth = c.get(Calendar.MONTH) + 1; // 获取当前月份 mDay = c.get(Calendar.DAY_OF_MONTH); // 获取当日期 mWay = c.get(Calendar.DAY_OF_WEEK); // 获取当前日期的星期 mHour = c.get(Calendar.HOUR_OF_DAY); //时 mMinute = c.get(Calendar.MINUTE); //分 System.out.println(mYear); System.out.println(mMonth); System.out.println(mDay); System.out.println(mWay); System.out.println(mHour); System.out.println(mMinute);} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Android","slug":"Android","permalink":"http://blog.iwxyi.com/tags/Android/"}]},{"title":"Markdown-讲解","date":"2018-12-07T13:05:00.000Z","path":"2018/12/07/正则表达式-讲解/","text":"Markdown 简介Markdown 是一种轻量级的「标记语言」，通常为程序员群体所用，适用于泡技术论坛、写博客日志、技术文稿、记录代码片段、起草邮件等场景。 可以通过简单、易读易写的文本格式生成结构化的 HTML 网页，以及 Word 和 pdf 文档。目前 知乎、简书、github、Stackoverflow、以及绝大多数博客论坛 均支持这种格式。 为什么要学 Markdown？因为简单；因为好用；因为这篇教程就是用 Markdown 写的。 让“码字的归码字，排版的归排版”，专注写作，效率快速提升； 除此之外基础的任务管理、项目管理、逻辑梳理、公式协作等等，都可以用基本的Markdown来完成…… 优点：简单符号排版，15 分钟上手。 纯键盘操作，写作时少调用鼠标，效率能提升很多。 使用 Markdown 的 h1、h2、h3 标题，列表、分列表，结构和逻辑都很清晰。排版成同样的效果，md 与 word 比起来简直毫不费力气。另外，还有插入图片、链接、粗体、斜体等功能。 纯文本编辑，轻量级。纯文本有很多好处，例如占用空间小、移植方便快捷、可以用 git 比较版本、编辑时不需要软件支持等。 目前支持将 md 转换为多种格式，包括 html、tex、pdf 等。 缺点： 语法不是很统一，不同的编辑器语法有区别 不能对文档进行精细调整，或者个性化调整。 据说过于程序员友好。 对话式红楼梦曹雪芹写的效果如下：贾芸听声音像是熟人，仔细一看，原来是紧邻倪二。这倪二是个泼皮，专放重利债，在赌博场吃饭，专爱喝酒打架。此时正从欠钱人家索债归来，已在醉乡，不料贾芸碰了他，就要动手。贾芸叫道：“老二！住手！是我冲撞了你。”倪二一听他的语音，将醉眼睁开一看，见是贾芸，忙松了手，趔趄著笑道：“原来是贾二爷。这会子那里去？”贾芸道：“告诉不得你，平白的又讨了个没趣儿！”倪二道：“不妨。有什么不平的事，告诉我，我替你出气。这三街六巷，凭他是谁，若得罪了我醉金刚倪二的街坊，管叫他人离家散！”贾芸道：“老二，你别生气，听我告诉你这缘故。”便把卜世仁一段事告诉了倪二。倪二听了，大怒道：“要不是二爷的亲戚，我就骂出来，真真把人气死！－－也罢，你也不必愁，我这里现有几两银子，你要用只管拿去。我们好街坊，这银子是不要利钱的。”一头说，一头从搭包内掏出一包银子来。 Markdown 的效果 用Markdown简单处理一下的话，这段的排版就变了： 贾芸听声音像是熟人，仔细一看，原来是紧邻倪二。这倪二是个泼皮，专放重利债，在赌博场吃饭，专爱喝酒打架。此时正从欠钱人家索债归来，已在醉乡，不料贾芸碰了他，就要动手。贾芸叫道： “老二！住手！是我冲撞了你。” 倪二一听他的语音，将醉眼睁开一看，见是贾芸，忙松了手，趔趄著笑道： “原来是贾二爷。这会子那里去？” 贾芸道： “告诉不得你，平白的又讨了个没趣儿！” 倪二道： “不妨。有什么不平的事，告诉我，我替你出气。这三街六巷，凭他是谁，若得罪了我醉金刚倪二的街坊，管叫他人离家散！” 贾芸道： “老二，你别生气，听我告诉你这缘故。” 便把卜世仁一段事告诉了倪二。倪二听了，大怒道： “要不是二爷的亲戚，我就骂出来，真真把人气死！－－也罢，你也不必愁，我这里现有几两银子，你要用只管拿去。我们好街坊，这银子是不要利钱的。” 一头说，一头从搭包内掏出一包银子来。 开始撰写 Markdown标题Markdown 支持两种标题的语法，类 Setext 和类 atx 形式。（部分编辑器不支持） 类 Setext 形式是用底线的形式，利用 = （最高阶标题）和 - （第二阶标题），例如： 12345This is an H1=============This is an H2------------- 类 Atx 形式则是在行首插入 1 到 6 个 # ，对应到标题 1 到 6 阶，例如： 12345# 这是 H1## 这是 H2###### 这是 H6 你可以选择性地「闭合」类 atx 样式的标题，这纯粹只是美观用的，若是觉得这样看起来比较舒适，你就可以在行尾加上 #，而行尾的 # 数量也不用和开头一样（行首的井字符数量决定标题的阶数）： 12345# 这是 H1 ### 这是 H2 ##### 这是 H3 ###### 区块引用BlockquotesMarkdown 标记区块引用是使用类似 email 中用 &gt; 的引用方式。如果你还熟悉在 email 信件中的引言部分，你就知道怎么在 Markdown 文件中建立一个区块引用，那会看起来像是你自己先断好行，然后在每行的最前面加上 &gt; ： 123456&gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,&gt; consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.&gt; Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.&gt; &gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse&gt; id sem consectetuer libero luctus adipiscing. Markdown 也允许你偷懒只在整个段落的第一行最前面加上 &gt; ： 123456&gt; This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.&gt; Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisseid sem consectetuer libero luctus adipiscing. 区块引用可以嵌套（例如：引用内的引用），只要根据层次加上不同数量的 &gt; ： 12345 This is the first level of quoting.&gt;&gt; &gt; This is nested blockquote.&gt;&gt; Back to the first level. 引用的区块内也可以使用其他的 Markdown 语法，包括标题、列表、代码区块等： 12345678&gt; ## 这是一个标题。&gt; &gt; 1. 这是第一行列表项。&gt; 2. 这是第二行列表项。&gt; &gt; 给出一些例子代码：&gt; &gt; return shell_exec(\"echo $input | $markdown_script\"); 任何像样的文本编辑器都能轻松地建立 email 型的引用。例如在 BBEdit 中，你可以选取文字后然后从选单中选择增加引用阶层。 列表Markdown 支持有序列表和无序列表。 无序列表使用星号、加号或是减号作为列表标记： 123* Red* Green* Blue 等同于： 123+ Red+ Green+ Blue 也等同于： 123- Red- Green- Blue 有序列表则使用数字接着一个英文句点（word里面也是这样）： 1231. Bird2. McHale3. Parish 列表项目标记通常是放在最左边，但是其实也可以缩进，最多 3 个空格，项目标记后面则一定要接着至少一个空格或制表符。 要让列表看起来更漂亮，你可以把内容用固定的缩进整理好： 12345* Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.* Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse id sem consectetuer libero luctus adipiscing. 但是如果你懒，那也行： 12345* Lorem ipsum dolor sit amet, consectetuer adipiscing elit.Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi,viverra nec, fringilla in, laoreet vitae, risus.* Donec sit amet nisl. Aliquam semper ipsum sit amet velit.Suspendisse id sem consectetuer libero luctus adipiscing. 列表项目可以包含多个段落，每个项目下的段落都必须缩进 4 个空格或是 1 个制表符： 1234567891. This is a list item with two paragraphs. Lorem ipsum dolor sit amet, consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus. Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus. Donec sit amet nisl. Aliquam semper ipsum sit amet velit.2. Suspendisse id sem consectetuer libero luctus adipiscing. 如果你每行都有缩进，看起来会看好很多，当然，再次地，如果你很懒惰，Markdown 也允许： 1234567* This is a list item with two paragraphs. This is the second paragraph in the list item. You'reonly required to indent the first line. Lorem ipsum dolorsit amet, consectetuer adipiscing elit.* Another item in the same list. 如果要在列表项目内放进引用，那 &gt; 就需要缩进： 1234* A list item with a blockquote: &gt; This is a blockquote &gt; inside a list item. 如果要放代码区块的话，该区块就需要缩进两次，也就是 8 个空格或是 2 个制表符：（有些编辑器不支持） 123* 一列表项包含一个列表区块： &lt;代码写在这&gt; 当然，项目列表很可能会不小心产生，像是下面这样的写法 11986. What a great season. 换句话说，也就是在行首出现数字-句点-空白，要避免这样的状况，你可以在句点前面加上反斜杠。 11986\\. What a great season. 待办事项用 - [ ] 来表示一个待办事项列表（注意有三个空格） 12- [ ] 未完成列表- [x] 已完成列表 代码区块和程序相关的写作或是标签语言原始码通常会有已经排版好的代码区块，通常这些区块我们并不希望它以一般段落文件的方式去排版，而是照原来的样子显示，Markdown 会用 &lt;pre&gt; 和 &lt;code&gt; 标签来把代码区块包起来。 要在 Markdown 中建立代码区块很简单，只要用一对12345~~~C++```C++ for (int i = 0; i &lt; 10; i++) printf(\"%d\\n\", i); ~ 上面的123456### 分隔线你可以在一行中用三个以上的短横杠来建立一个分隔线，行内不能有其他东西。 123456### 链接链接文字用 [方括号] 来标记，要建立一个行内的链接，只要在方块括号后面紧接着圆括号并插入网址链接即可，例如： This is an example inline link. This link has no title attribute. 12如果你是要链接到同样主机的资源，你可以使用相对路径： See my About page for details. 123456### 强调Markdown 使用星号（*）和底线（_）作为标记强调字词的符号 。一对是斜体，两对是粗体。 single asterisks single underscores double asterisks double underscores 123456789101112*single asterisks*_single underscores_**double asterisks**__double underscores__你可以随便用你喜欢的样式，唯一的限制是，你用什么符号开启标签，就要用什么符号结束。强调也可以直接插在文字中间： unfriggingbelievable 1234但是**如果你的 \\* 和 _ 两边都有空白的话，它们就只会被当成普通的符号。**如果要在文字前后直接插入普通的星号或底线，你可以用反斜线： *this text is surrounded by literal asterisks* 123456### 删除线使用两对波浪线 ~~ 来给文字加上~~删除线~~。注意波浪线和文字之间不能有空格。 删除线 123456### 代码如果要标记一小段行内代码，你可以用反引号把它包起来（`），例如： Use the printf() function. 12如果要在代码区段内插入反引号，你可以用多个反引号来开启和结束代码区段： There is a literal backtick (`) here. 12345678910### 图片很明显地，要在纯文字应用中设计一个「自然」的语法来插入图片是有一定难度的。Markdown 使用一种和链接很相似的语法来标记图片，同样也允许两种样式： 行内式和参考式。行内式的图片语法看起来像是： Alt text 1234567891011121314详细叙述如下：- 一个惊叹号 !- 接着一个方括号，里面放上图片的替代文字- 接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上 选择性的 'title' 文字。到目前为止， Markdown 还没有办法指定图片的宽高，如果你需要的话，你可以使用普通的 `&lt;img&gt;` 标签。### 反斜杠Markdown 可以利用反斜杠来插入一些在语法中有其它意义的符号，例如：如果你想要用星号加在文字旁边的方式来做出强调效果，你可以在星号的前面加上反斜杠： *literal asterisks* 12Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号： \\ 反斜线` 反引号 星号_ 底线{} 花括号[] 方括号() 括弧井字号 加号 减号. 英文句点! 惊叹号123456### 自动链接Markdown 支持以比较简短的自动链接形式来处理网址和电子邮件信箱，只要是用方括号包起来， Markdown 就会自动把它转成链接。一般网址的链接文字就和链接地址一样，例如： http://example.com/ 12邮址的自动链接也很类似，只是 Markdown 会先做一个编码转换的过程，把文字字符转成 16 进位码的 HTML 实体，这样的格式可以糊弄一些不好的邮址收集机器人，例如： address@example.com 123456### 表格表格是Markdown语法中比较复杂的一个，其语法如下： 表头 条目一 条目二 项目 项目一 项目二 ``` 以上标记显示效果如下： 表头 条目一 条目二 项目 项目一 项目二 注：三个短斜杠左右的冒号用于控制对齐方式，只放置左边冒号表示文字居左，只放置右边冒号表示文字居右，如果两边都放置冒号表示文字居中。不加冒号默认左对齐。 文字上色使用Markdown的同学最郁闷的地方恐怕就是不能给文字添加颜色了。事实上，Markdown的最初目标就是为纯写作而生的。因此，它并没有考虑文字颜色这一点。所以，单纯使用Markdown设置文字颜色已经做不到了。但你可以这样做： 先用Markdown编辑完成 导出为html，在需要上色的部分手动添加标签&lt;font color='#ff0000'&gt; &lt;/font&gt;保存即可。 Latex数学公式1.行内公式：使用两个”$”符号引用公式: $公式$ 2.行间公式：使用两对“$$”符号引用公式： $$公式$$ 输例如$\\sqrt{x^{2}}$ 上标下标在$ $ 公式中，用 ^p 表示上标。若有多个，用 { } 括起来。 下标符号为 _，用法同上标。 Typora 的扩展语法中，可以用^上标^与~下标~来表示（需要先到设置中开启） 结语在文档中，内容远远比工具和格式重要。但适当的格式和工具也会增强文字的渲染力。 Markdown 是纯文本和富文本之间最恰当的选择。 博客来源：整理，网络，主要是 http://www.markdown.cn/ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"语法","slug":"语法","permalink":"http://blog.iwxyi.com/tags/语法/"},{"name":"讲解","slug":"讲解","permalink":"http://blog.iwxyi.com/tags/讲解/"}]},{"title":"栈与队列-讲解","date":"2018-12-07T12:50:00.000Z","path":"2018/12/07/栈与队列-讲解/","text":"介绍栈栈是一种特殊的线性表。其特殊性在于限定插入和删除数据元素的操作只能在线性表的一端进行。如下所示： 结论：先进后出 &amp;&amp; 后进先出（Last In First Out），简称为LIFO线性表。 例子：手机任务的返回栈、食堂餐盘从下到上叠起来，送给洗盘子的人，从上到下洗 队列队列(Queue)也是一种运算受限的线性表，它的运算限制与栈不同，是两头都有限制，插入只能在表的一端进行(只进不出)，而删除只能在表的另一端进行(只出不进)，允许删除的一端称为队尾(rear)，允许插入的一端称为队头 (Front),如图所示： 结论：队列的操作原则是先进先出的，所以队列又称作FIFO表(First In First Out) 例子：各种排队 纯 C 用法（函数）栈123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;stdio.h&gt;#define MAX_SIZE 1000int _data[MAX_SIZE], _size = 0;bool empty() { return _size != 0;}void push(int x) { if (_size &lt; MAX_SIZE-1) { _data[_size++] = x; }}void pop() { if (_size) { _data[--_size] = 0; }}int size() { return _size;}int front() { return _size ? _data[0] : 0;}int back() { return _size ? _data[_size-1] : 0;}int main(){ push(100); printf(\"%d\\n\", back()); push(20); printf(\"%d\\n\", back());} 数组转指针： _data\\[([^M].*)\\]替换*(_data + \\1) 纯C用法（结构体）栈12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667#include &lt;stdio.h&gt;struct Stack { int _data[1000]; int _size; Stack() { // 初始化 _size = 0; } Stack(Stack&amp; q) { // 拷贝（引用） _size = q.size(); for (int i = 0; i &lt; _size; i++) _data[i] = q.at(i); } bool empty() { // 是否为空 return !_size; } int size() { // 尺寸 return _size; } int at(int x) { // 数据 return (x&gt;=0 &amp;&amp; x &lt; _size) ? _data[x] : 0; } void push(int x) { // 放入一个 if (_size &lt; 1000) _data[_size++] = x; } void pop() { // 取出一个 if (_size) { for (int i = 0; i &lt; _size-1; i++) _data[i] = _data[i+1]; --_size; } } int front() { // 获取最新进入的 return _size?_data[0] : 0; } int back() { // 获取最后进入的 return _size?_data[_size-1] : 0; } void clear() { _size = 0; }};int main(){ Stack s; s.push(100); printf(\"%d\\n\", s.back()); s.push(20); printf(\"%d\\n\", s.back()); Stack s2(s); printf(\"%d\\n\", s.back()); s2.clear();} C++ 用法头文件12#include &lt;queue&gt;#include &lt;stack&gt; 定义方式12queue&lt;int&gt; q;statck&lt;int&gt; q; 常用操作栈12345s.empty() //如果栈为空返回true，否则返回false s.size() //返回栈中元素的个数 s.pop() //删除栈顶元素但不返回其值 s.top() //返回栈顶的元素，但不删除该元素 s.push(x) //在栈顶压入新元素 ，参数X为要压入的元素 队列123456q.empty() // 如果队列为空返回true，否则返回false q.size() // 返回队列中元素的个数 q.pop() //删除队列首元素但不返回其值 q.front() // 返回队首元素的值，但不删除该元素 q.push(x) //在队尾压入新元素 ，X为要压入的元素q.back() //返回队列尾元素的值，但不删除该元素 智能指针迭代器 iterator 123stack&lt;int&gt;::iterator i;for (i = s.begin(); i != s.end(); ++i) cout &lt;&lt; *i &lt;&lt; endl; 例子12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;queue&gt;#include &lt;stack&gt;#include &lt;vector&gt;using namespace std;int main(){ queue&lt;int&gt; q; stack&lt;char&gt; s; char a = 'a', b = 'b'; q.push(1); cout &lt;&lt; \"push 1\" &lt;&lt; endl; cout &lt;&lt; \"empty:\" &lt;&lt; q.empty() &lt;&lt; endl; cout &lt;&lt; \"push 2\" &lt;&lt; endl; q.push(2); cout &lt;&lt; \"front:\" &lt;&lt; q.front() &lt;&lt; endl; q.pop(); cout &lt;&lt; \"pop\" &lt;&lt; endl; cout &lt;&lt; \"front:\" &lt;&lt; q.front() &lt;&lt; endl; q.pop(); cout &lt;&lt; \"pop\" &lt;&lt; endl; cout &lt;&lt; \"empty:\" &lt;&lt; q.empty() &lt;&lt;endl; cout &lt;&lt; \"-----\" &lt;&lt; endl; s.push(a); cout &lt;&lt; \"push \" &lt;&lt; a &lt;&lt; endl; cout &lt;&lt; \"size:\" &lt;&lt; s.size() &lt;&lt; endl; cout &lt;&lt; \"top:\" &lt;&lt; s.top() &lt;&lt; endl; s.push(b); cout &lt;&lt; \"push \" &lt;&lt; b &lt;&lt; endl; cout &lt;&lt; \"top:\" &lt;&lt; s.top() &lt;&lt; endl; s.pop(); cout &lt;&lt; \"pop\" &lt;&lt; endl; cout &lt;&lt; \"top:\" &lt;&lt; s.top() &lt;&lt; endl;} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"算法","slug":"算法","permalink":"http://blog.iwxyi.com/tags/算法/"},{"name":"讲解","slug":"讲解","permalink":"http://blog.iwxyi.com/tags/讲解/"}]},{"title":"正则表达式-讲解","date":"2018-12-06T12:56:00.000Z","path":"2018/12/06/正则表达式教程/","text":"介绍正则表达式(Regular Expression，简称 RegExp)是一种文本模式，包括普通字符（例如，a 到 z 之间的字母）和特殊字符（称为”元字符”）。它使用单个字符串来描述、匹配一系列匹配某个句法规则的字符串。 为什么使用正则表达式？典型的搜索和替换操作要求您提供与预期的搜索结果匹配的确切文本。虽然这种技术对于对静态文本执行简单搜索和替换任务可能已经足够了，但它缺乏灵活性，若采用这种方法搜索动态文本，即使不是不可能，至少也会变得很困难。 例1：文件匹配data(\\w)?\\.dat 匹配下列所有文件 12345data.datdata1.datdata2.datdatax.datdataN.dat 使用 * 字符代替 ? 字符扩大了找到的文件的数量。data.*\\.dat 匹配下列所有文件： 123456data.datdata1.datdata2.datdata12.datdatax.datdataXYZ.dat 例2：colou?r同时匹配 color与colour 例3：特定格式^[0-9]+abc$ ^ 为匹配输入字符串的开始位置 [0-9]+匹配多个数字， [0-9] 匹配单个数字，+ 匹配一个或者多个。 abc$匹配字母 abc 并以 abc 结尾，$ 为匹配输入字符串的结束位置。 我们在写用户注册表单时，只允许用户名包含字符、数字、下划线和连接字符(-)，并设置用户名的长度，我们就可以使用这一类正则表达式来设定。 ()() 标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用 \\( 和 \\)。 特殊字符所谓特殊字符，就是一些有特殊含义的字符。 许多元字符要求在试图匹配它们时特别对待。若要匹配这些特殊字符，必须首先使字符”转义”，即，将反斜杠字符\\ 放在它们前面。下表列出了正则表达式中的特殊字符： 特别字符 描述 $ 匹配输入字符串的结尾位置。如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹配 ‘\\n’ 或 ‘\\r’。要匹配 $ 字符本身，请使用 \\$。 ( ) 标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用 ( 和 )。 * 匹配前面的子表达式零次或多次。要匹配 * 字符，请使用 *。 + 匹配前面的子表达式一次或多次。要匹配 + 字符，请使用 +。 . 匹配除换行符 \\n 之外的任何单字符。要匹配 . ，请使用 . 。 [ 标记一个中括号表达式的开始。要匹配 [，请使用 [。 ? 匹配前面的子表达式零次或一次，或指明一个非贪婪限定符。要匹配 ? 字符，请使用 ?。 \\ 将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， ‘n’ 匹配字符 ‘n’。’\\n’ 匹配换行符。序列 ‘\\‘ 匹配 “\"，而 ‘(‘ 则匹配 “(“。 ^ 匹配输入字符串的开始位置，除非在方括号表达式中使用，此时它表示不接受该字符集合。要匹配 ^ 字符本身，请使用 ^。 { 标记限定符表达式的开始。要匹配 {，请使用 {。 | 指明两项之间的一个选择。要匹配 |，请使用 |。 限定符限定符用来指定正则表达式的一个给定组件必须要出现多少次才能满足匹配。有 * 或 + 或 ? 或 {n} 或 {n,} 或 {n,m} 共6种。 正则表达式的限定符有： 字符 描述 * 匹配前面的子表达式零次或多次。例如，zo* 能匹配 “z” 以及 “zoo”。* 等价于{0,}。 + 匹配前面的子表达式一次或多次。例如，’zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,}。 ? 匹配前面的子表达式零次或一次。例如，”do(es)?” 可以匹配 “do” 、 “does” 中的 “does” 、 “doxy” 中的 “do” 。? 等价于 {0,1}。 {n} n 是一个非负整数。匹配确定的 n 次。例如，’o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。 {n,} n 是一个非负整数。至少匹配n 次。例如，’o{2,}’ 不能匹配 “Bob” 中的 ‘o’，但能匹配 “foooood” 中的所有 o。’o{1,}’ 等价于 ‘o+’。’o{0,}’ 则等价于 ‘o*’。 {n,m} m 和 n 均为非负整数，其中n &lt;= m。最少匹配 n 次且最多匹配 m 次。例如，”o{1,3}” 将匹配 “fooooood” 中的前三个 o。’o{0,1}’ 等价于 ‘o?’。请注意在逗号和两个数之间不能有空格。 定位符定位符使您能够将正则表达式固定到行首或行尾。它们还使您能够创建这样的正则表达式，这些正则表达式出现在一个单词内、在一个单词的开头或者一个单词的结尾。 定位符用来描述字符串或单词的边界，^ 和 $ 分别指字符串的开始与结束，\\b 描述单词的前或后边界，\\B 表示非单词边界。 正则表达式的定位符有： 字符 描述 ^ 匹配输入字符串开始的位置。如果设置了 RegExp 对象的 Multiline 属性，^ 还会与 \\n 或 \\r 之后的位置匹配。 $ 匹配输入字符串结尾的位置。如果设置了 RegExp 对象的 Multiline 属性，$ 还会与 \\n 或 \\r 之前的位置匹配。 \\b 匹配一个单词边界，即字与空格间的位置。 \\B 非单词边界匹配。 注意：不能将限定符与定位符一起使用。 选择用圆括号将所有选择项括起来，相邻的选择项之间用|分隔。但用圆括号会有一个副作用，使相关的匹配会被缓存，此时可用?:放在第一个选项前来消除这种副作用。 其中 ?: 是非捕获元之一，还有两个非捕获元是 ?= 和 ?!，这两个还有更多的含义，前者为正向预查，在任何开始匹配圆括号内的正则表达式模式的位置来匹配搜索字符串，后者为负向预查，在任何开始不匹配该正则表达式模式的位置来匹配搜索字符串。 反向引用对一个正则表达式模式或部分模式两边添加圆括号将导致相关匹配存储到一个临时缓冲区中，所捕获的每个子匹配都按照在正则表达式模式中从左到右出现的顺序存储。缓冲区编号从 1 开始，最多可存储 99 个捕获的子表达式。每个缓冲区都可以使用 \\n 访问，其中 n 为一个标识特定缓冲区的一位或两位十进制数。 可以使用非捕获元字符 ?:、?= 或 ?! 来重写捕获，忽略对相关匹配的保存。 反向引用的最简单的、最有用的应用之一，是提供查找文本中两个相同的相邻单词的匹配项的能力。 例如：(asd)\\1能匹配asdasd 所有元字符 字符 描述 \\ 将下一个字符标记为一个特殊字符、或一个原义字符、或一个 向后引用、或一个八进制转义符。例如，’n’ 匹配字符 “n”。’\\n’ 匹配一个换行符。序列 ‘\\‘ 匹配 “\" 而 “(“ 则匹配 “(“。 ^ 匹配输入字符串的开始位置。如果设置了 RegExp 对象的 Multiline 属性，^ 也匹配 ‘\\n’ 或 ‘\\r’ 之后的位置。 $ 匹配输入字符串的结束位置。如果设置了RegExp 对象的 Multiline 属性，$ 也匹配 ‘\\n’ 或 ‘\\r’ 之前的位置。 * 匹配前面的子表达式零次或多次。例如，zo* 能匹配 “z” 以及 “zoo”。* 等价于{0,}。 + 匹配前面的子表达式一次或多次。例如，’zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,}。 ? 匹配前面的子表达式零次或一次。例如，”do(es)?” 可以匹配 “do” 或 “does” 。? 等价于 {0,1}。 {n} n 是一个非负整数。匹配确定的 n 次。例如，’o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。 {n,} n 是一个非负整数。至少匹配n 次。例如，’o{2,}’ 不能匹配 “Bob” 中的 ‘o’，但能匹配 “foooood” 中的所有 o。’o{1,}’ 等价于 ‘o+’。’o{0,}’ 则等价于 ‘o*’。 {n,m} m 和 n 均为非负整数，其中n &lt;= m。最少匹配 n 次且最多匹配 m 次。例如，”o{1,3}” 将匹配 “fooooood” 中的前三个 o。’o{0,1}’ 等价于 ‘o?’。请注意在逗号和两个数之间不能有空格。 ? 当该字符紧跟在任何一个其他限制符 (*, +, ?, {n}, {n,}, {n,m}) 后面时，匹配模式是非贪婪的。非贪婪模式尽可能少的匹配所搜索的字符串，而默认的贪婪模式则尽可能多的匹配所搜索的字符串。例如，对于字符串 “oooo”，’o+?’ 将匹配单个 “o”，而 ‘o+’ 将匹配所有 ‘o’。 . 匹配除换行符（\\n、\\r）之外的任何单个字符。要匹配包括 ‘\\n’ 在内的任何字符，请使用像”(.|\\n)“的模式。 (pattern) 匹配 pattern 并获取这一匹配。所获取的匹配可以从产生的 Matches 集合得到，在VBScript 中使用 SubMatches 集合，在JScript 中则使用 $0…$9 属性。要匹配圆括号字符，请使用 ‘(‘ 或 ‘)‘。 (?:pattern) 匹配 pattern 但不获取匹配结果，也就是说这是一个非获取匹配，不进行存储供以后使用。这在使用 “或” 字符 (|) 来组合一个模式的各个部分是很有用。例如， ‘industr(?:y|ies) 就是一个比 ‘industry|industries’ 更简略的表达式。 (?=pattern) 正向肯定预查（look ahead positive assert），在任何匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如，”Windows(?=95|98|NT|2000)”能匹配”Windows2000”中的”Windows”，但不能匹配”Windows3.1”中的”Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。 (?!pattern) 正向否定预查(negative assert)，在任何不匹配pattern的字符串开始处匹配查找字符串。这是一个非获取匹配，也就是说，该匹配不需要获取供以后使用。例如”Windows(?!95|98|NT|2000)”能匹配”Windows3.1”中的”Windows”，但不能匹配”Windows2000”中的”Windows”。预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。 (?&lt;=pattern) 反向(look behind)肯定预查，与正向肯定预查类似，只是方向相反。例如，”`(?&lt;=95 (?&lt;!pattern) 反向否定预查，与正向否定预查类似，只是方向相反。例如”`(?&lt;!95 x|y 匹配 x 或 y。例如，’z|food’ 能匹配 “z” 或 “food”。’(z|f)ood’ 则匹配 “zood” 或 “food”。 [xyz] 字符集合。匹配所包含的任意一个字符。例如， ‘[abc]’ 可以匹配 “plain” 中的 ‘a’。 [^xyz] 负值字符集合。匹配未包含的任意字符。例如， '[^abc]' 可以匹配 “plain” 中的’p’、’l’、’i’、’n’。 [a-z] 字符范围。匹配指定范围内的任意字符。例如，’[a-z]’ 可以匹配 ‘a’ 到 ‘z’ 范围内的任意小写字母字符。 [^a-z] 负值字符范围。匹配任何不在指定范围内的任意字符。例如，’[^a-z]’ 可以匹配任何不在 ‘a’ 到 ‘z’ 范围内的任意字符。 \\b 匹配一个单词边界，也就是指单词和空格间的位置。例如， ‘er\\b’ 可以匹配”never” 中的 ‘er’，但不能匹配 “verb” 中的 ‘er’。 \\B 匹配非单词边界。’er\\B’ 能匹配 “verb” 中的 ‘er’，但不能匹配 “never” 中的 ‘er’。 \\cx 匹配由 x 指明的控制字符。例如， \\cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 ‘c’ 字符。 \\d 匹配一个数字字符。等价于 [0-9]。 \\D 匹配一个非数字字符。等价于 [^0-9]。 \\f 匹配一个换页符。等价于 \\x0c 和 \\cL。 \\n 匹配一个换行符。等价于 \\x0a 和 \\cJ。 \\r 匹配一个回车符。等价于 \\x0d 和 \\cM。 \\s 匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \\f\\n\\r\\t\\v]。 \\S 匹配任何非空白字符。等价于 [^ \\f\\n\\r\\t\\v]。 \\t 匹配一个制表符。等价于 \\x09 和 \\cI。 \\v 匹配一个垂直制表符。等价于 \\x0b 和 \\cK。 \\w 匹配字母、数字、下划线。等价于’[A-Za-z0-9_]’。 \\W 匹配非字母、数字、下划线。等价于 ‘[^A-Za-z0-9_]’。 \\xn 匹配 n，其中 n 为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，’\\x41’ 匹配 “A”。’\\x041’ 则等价于 ‘\\x04’ &amp; “1”。正则表达式中可以使用 ASCII 编码。 \\num 匹配 num，其中 num 是一个正整数。对所获取的匹配的引用。例如，’(.)\\1’ 匹配两个连续的相同字符。 \\n 标识一个八进制转义值或一个向后引用。如果 \\n 之前至少 n 个获取的子表达式，则 n 为向后引用。否则，如果 n 为八进制数字 (0-7)，则 n 为一个八进制转义值。 \\nm 标识一个八进制转义值或一个向后引用。如果 \\nm 之前至少有 nm 个获得子表达式，则 nm 为向后引用。如果 \\nm 之前至少有 n 个获取，则 n 为一个后跟文字 m 的向后引用。如果前面的条件都不满足，若 n 和 m 均为八进制数字 (0-7)，则 \\nm 将匹配八进制转义值 nm。 \\nml 如果 n 为八进制数字 (0-3)，且 m 和 l 均为八进制数字 (0-7)，则匹配八进制转义值 nml。 \\un 匹配 n，其中 n 是一个用四个十六进制数字表示的 Unicode 字符。例如， \\u00A9 匹配版权符号 (?)。 等价字符?, *, +, \\d, \\w 都是等价字符?等价于匹配长度{0,1}*等价于匹配长度{0,}+等价于匹配长度{1,}\\d等价于[0-9]\\w等价于[A-Za-z_0-9] 常用运算符与表达式^ 开始() 域段[] 包含,默认是一个字符长度[^] 不包含,默认是一个字符长度{n,m} 匹配长度. 任何单个字符(. 字符点)| 或\\ 转义$ 结尾[A-Z] 26个大写字母[a-z] 26个小写字母[0-9] 0至9数字[A-Za-z0-9] 26个大写字母、26个小写字母和0至9数字 贪婪模式*、+限定符都是贪婪的，因为它们会尽可能多的匹配文字，只有在它们的后面加上一个?就可以实现非贪婪或最小匹配。 字符簇略吧，目前作用不大 实例应用 验证用户名和密码：（”^[a-zA-Z]\\w{5,15}$“）正确格式：”[A-Z][a-z]_[0-9]“组成,并且第一个字必须为字母6~16位； 验证电话号码：（”^(\\\\d{3,4}-)\\\\d{7,8}$“）正确格式：xxx/xxxx-xxxxxxx/xxxxxxxx； 验证手机号码：”^1[3|4|5|7|8][0-9]\\\\d{8}$“； 验证身份证号（15位或18位数字）：”\\\\d{14}[[0-9],0-9xX]“； 验证Email地址：(“^\\\\w+([-+.]\\\\w+)*@\\\\w+([-.]\\\\w+)*\\.\\\\w+([-.]\\\\w+)*$“)； 只能输入由数字和26个英文字母组成的字符串：(“^[A-Za-z0-9]+$“) ; 整数或者小数：^[0-9]+([.]{0,1}[0-9]+){0,1}$ 只能输入数字：”^[0-9]*$“。 只能输入n位的数字：”^\\\\d{n}$“。 只能输入至少n位的数字：”^\\\\d{n,}$“。 只能输入m~n位的数字：”^\\\\d{m,n}$“。 只能输入零和非零开头的数字：”^(0|[1-9][0-9]*)$“。 只能输入有两位小数的正实数：”^[0-9]+(.[0-9]{2})?$“。 只能输入有1~3位小数的正实数：”^[0-9]+(\\.[0-9]{1,3})?$“。 只能输入非零的正整数：\"^\\+?[1-9][0-9]*$\"。 只能输入非零的负整数：\"^\\-[1-9][0-9]*$\"。 只能输入长度为3的字符：”^.{3}$“。 只能输入由26个英文字母组成的字符串：”^[A-Za-z]+$“。 只能输入由26个大写英文字母组成的字符串：”^[A-Z]+$“。 只能输入由26个小写英文字母组成的字符串：”^[a-z]+$“。 验证是否含有^%&amp;',;=?$\\\"等字符：\"[^%&amp;',;=?$\\x22]+\"。 只能输入汉字：”^[\\u4e00-\\u9fa5]{0,}$“。 验证URL：”^http://([\\\\w-]+\\.)+[\\\\w-]+(/[\\\\w-./?%&amp;=]*)?$“。 验证一年的12个月：”^(0?[1-9]|1[0-2])$“正确格式为：”01”～”09”和”10”～”12”。 验证一个月的31天：”^((0?[1-9])|((1|2)[0-9])|30|31)$“正确格式为；”01”～”09”、”10”～”29”和“30”~“31”。 获取日期正则表达式：\\d{4}[年|\\-|\\.]\\d{1-12}[月|\\-|\\.]\\d{1-31}日? 评注：可用来匹配大多数年月日信息。 匹配双字节字符(包括汉字在内)：[^\\x00-\\xff] 评注：可以用来计算字符串的长度（一个双字节字符长度计2，ASCII字符计1） 匹配空白行的正则表达式：\\n\\s*\\r 评注：可以用来删除空白行 匹配HTML标记的正则表达式：&lt;(\\S*?)[^&gt;]*&gt;.*?&lt;/&gt;|&lt;.*? /&gt; 评注：网上流传的版本太糟糕，上面这个也仅仅能匹配部分，对于复杂的嵌套标记依旧无能为力 匹配首尾空白字符的正则表达式：^\\s*|\\s*$ 评注：可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式 匹配网址URL的正则表达式：[a-zA-z]+://[^\\s]* 评注：网上流传的版本功能很有限，上面这个基本可以满足需求 匹配帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$ 评注：表单验证时很实用 匹配腾讯QQ号：[1-9][0-9]\\{4,\\} 评注：腾讯QQ号从10 000 开始 匹配中国邮政编码：[1-9]\\\\d{5}(?!\\d) 评注：中国邮政编码为6位数字 匹配ip地址：((2[0-4]\\\\d|25[0-5]|[01]?\\\\d\\\\d?)\\.){3}(2[0-4]\\\\d|25[0-5]|[01]?\\\\d\\\\d?)。 C++示例1234567891011121314151617181920212223242526#include &lt;stdio.h&gt;#include &lt;sys/types.h&gt;#include &lt;regex.h&gt; int main(int argc,char** argv){ int status ,i; int cflags = REG_EXTENDED; regmatch_t pmatch[1]; const size_t nmatch = 1; regex_t reg; const char * pattern = \"^\\\\w+([-+.]\\\\w+)*@\\\\w+([-.]\\\\w+)*.\\\\w+([-.]\\\\w+)*$\"; char * buf = \"chenjiayi@126.com\"; regcomp(&amp;reg,pattern,cflags);//编译正则模式 status = regexec(&amp;reg,buf,nmatch,0);//执行正则表达式和缓存的比较 if(status == REG_NOMATCH) printf(\"No match\\n\"); else if (0 == status) { printf(\"比较成功:\"); for(i = pmatch[0].rm_so;i&lt;pmatch[0].rm_eo;++i)putchar(buf[i]); printf(\"\\n\"); } regfree(&amp;reg); return 0;} 博客来源：https://blog.csdn.net/chenjiayi_yun/article/details/43375201 菜鸟教程：http://www.runoob.com/regexp/regexp-tutorial.html document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"讲解","slug":"讲解","permalink":"http://blog.iwxyi.com/tags/讲解/"},{"name":"RegExp","slug":"RegExp","permalink":"http://blog.iwxyi.com/tags/RegExp/"}]},{"title":"Android小知识","date":"2018-12-01T02:28:00.000Z","path":"2018/12/01/Android小知识/","text":"1234&lt;EditText &lt;!-- 设置密码框 --&gt; android:password=\"true\"&lt;/EditText&gt; 12CheckBox cb;if (cb.isChecked()) { ... } 12//获取文本((EditText)findViewById(R.id.editText2)).getText().toString() 123456789101112131415//设置按钮事件b1=(Button)findViewById(R.id.button);b1.setOnClickListener( new View.OnClickListener() { @Override public void onClick(View v) { // 用浏览器打开网址 Intent i = new Intent(android.content.Intent.ACTION_VIEW, Uri.parse(\"http://www.uprogrammer.cn\")); // 拨号 //Intent i = new Intent(android.content.Intent.ACTION_VIEW,Uri.parse(\"tel:9510300000\")); startActivity(i); }}); 1234567&lt;!-- 通过Launch或者Intent调用 --&gt;&lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.VIEW\" /&gt; &lt;action android:name=\"com.example.MyApplication.LAUNCH\" /&gt; &lt;category android:name=\"android.intent.category.DEFAULT\" /&gt; &lt;data android:scheme=\"http\" /&gt;&lt;/intent-filter&gt; 12345678910 &lt;!-- 监听网址的打开（Manifest） --&gt;&lt;activity android:name=\"cn.uprogrammer.intentfilter.CustomActivity\" android:label=\"@string/app_name\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"android.intent.action.VIEW\" /&gt; &lt;action android:name=\"cn.uprogrammer.intentfilter.LAUNCH\" /&gt; &lt;category android:name=\"android.intent.category.DEFAULT\" /&gt; &lt;data android:scheme=\"http\" /&gt; &lt;/intent-filter&gt;&lt;/activity&gt; 123456789101112// 监听打开网址后（显示网址）public class CustomActivity extends Activity { @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.custom_view); TextView label = (TextView) findViewById(R.id.show_data); Uri url = getIntent().getData(); label.setText(url.toString()); }} 文本框属性详解 http://www.runoob.com/w3cnote/android-tutorial-textview.html 1Drawable drawable = MainActivity.this.getResources().getDrawable(R.drawable.picture1); 1234// 格式化文本，\"常量%1常量\"textView.setText(getString(R.string.section_format, 123));&lt;string name=\"section_format\"&gt;Hello World %1$d&lt;/string&gt; 12// 规定ImageView最大值无效，需要加上下面这句：android:adjustViewBounds 12// 判断版本号if (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.M) 1234567891011121314151617181920212223242526272829303132// 是否拥有联系人权限，没有就尝试获取private boolean mayRequestContacts() { if (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.M) { return true; } if (checkSelfPermission(READ_CONTACTS) == PackageManager.PERMISSION_GRANTED) { return true; } if (shouldShowRequestPermissionRationale(READ_CONTACTS)) { Snackbar.make(mEmailView, R.string.permission_rationale, Snackbar.LENGTH_INDEFINITE) .setAction(android.R.string.ok, new View.OnClickListener() { @Override @TargetApi(Build.VERSION_CODES.M) public void onClick(View v) { requestPermissions(new String[]{READ_CONTACTS}, REQUEST_READ_CONTACTS); } }); } else { requestPermissions(new String[]{READ_CONTACTS}, REQUEST_READ_CONTACTS); } return false;}@Overridepublic void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) { if (requestCode == REQUEST_READ_CONTACTS) { if (grantResults.length == 1 &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED) { populateAutoComplete(); } }} 123456789// 设置 Spinner 下拉菜单String[] ctype = new String[]{\"全部\", \"游戏\", \"电影\", \"娱乐\", \"图书\"};//创建一个数组适配器ArrayAdapter&lt;String&gt; adapter = new ArrayAdapter&lt;String&gt;(this, android.R.layout.simple_spinner_item, ctype);//设置下拉列表框的下拉选项样式adapter.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);Spinner spinner = super.findViewById(R.id.spinner);spinner.setAdapter(adapter); document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Android","slug":"Android","permalink":"http://blog.iwxyi.com/tags/Android/"},{"name":"整理","slug":"整理","permalink":"http://blog.iwxyi.com/tags/整理/"}]},{"title":"Android Fragment回退栈","date":"2018-11-27T02:43:00.000Z","path":"2018/11/27/Android-Fragment回退栈/","text":"导语: Fragment作为Android最基本，最重要的基础概念之一，在开发中经常会和他打交道。本文从为什么出现Fragment开始，介绍了Fragment相关的方方面面，包括Fragment的基本定义及使用、回退栈的内部实现、Fragment通信、DialogFragment、ViewPager+Fragment的使用、嵌套Fragment、懒加载等。 基本概念 Fragment，简称碎片，是Android 3.0（API 11）提出的，为了兼容低版本，support-v4库中也开发了一套Fragment API，最低兼容Android 1.6。 过去support-v4库是一个jar包，24.2.0版本开始，将support-v4库模块化为多个jar包，包含：support-fragment, support-ui, support-media-compat等，这么做是为了减少APK包大小，你需要用哪个模块就引入哪个模块。 如果想引入整个support-v4库，则compile 'com.android.support:support-v4:24.2.1'，如果只想引入support-fragment库，则com.android.support:support-fragment:24.2.1。 因为support库是不断更新的，因此建议使用support库中的android.support.v4.app.Fragment，而不要用系统自带的android.app.Fragment。而如果要使用support库的Fragment，Activity必须要继承FragmentActivity（AppCompatActivity是FragmentActivity的子类）。 Fragment是依赖于Activity的，不能独立存在的。 一个Activity里可以有多个Fragment。 一个Fragment可以被多个Activity重用。 Fragment有自己的生命周期，并能接收输入事件。 我们能在Activity运行时动态地添加或删除Fragment。 Fragment的优势有以下几点： 模块化（Modularity）：我们不必把所有代码全部写在Activity中，而是把代码写在各自的Fragment中。 可重用（Reusability）：多个Activity可以重用一个Fragment。 可适配（Adaptability）：根据硬件的屏幕尺寸、屏幕方向，能够方便地实现不同的布局，这样用户体验更好。 基本使用 这里给出Fragment最基本的使用方式。首先，创建继承Fragment的类，名为Fragment1： 12345678910111213141516171819202122public class Fragment1 extends Fragment{ private static String ARG_PARAM = \"param_key\"; private String mParam; private Activity mActivity; public void onAttach(Context context) { mActivity = (Activity) context; mParam = getArguments().getString(ARG_PARAM); //获取参数 } public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) { View root = inflater.inflate(R.layout.fragment_1, container, false); TextView view = root.findViewById(R.id.text); view.setText(mParam); return root; } public static Fragment1 newInstance(String str) { Fragment1 frag = new Fragment1(); Bundle bundle = new Bundle(); bundle.putString(ARG_PARAM, str); fragment.setArguments(bundle); //设置参数 return fragment; }} Fragment有很多可以复写的方法，其中最常用的就是onCreateView()，该方法返回Fragment的UI布局，需要注意的是inflate()的第三个参数是false，因为在Fragment内部实现中，会把该布局添加到container中，如果设为true，那么就会重复做两次添加，则会抛如下异常： 1Caused by: java.lang.IllegalStateException: The specified child already has a parent. You must call removeView() on the child's parent first. 如果在创建Fragment时要传入参数，必须要通过setArguments(Bundle bundle)方式添加，而不建议通过为Fragment添加带参数的构造函数，因为通过setArguments()方式添加，在由于内存紧张导致Fragment被系统杀掉并恢复（re-instantiate）时能保留这些数据。官方建议如下： 1It is strongly recommended that subclasses do not have other constructors with parameters, since these constructors will not be called when the fragment is re-instantiated. 我们可以在Fragment的onAttach()中通过getArguments()获得传进来的参数，并在之后使用这些参数。如果要获取Activity对象，不建议调用getActivity()，而是在onAttach()中将Context对象强转为Activity对象。 创建完Fragment后，接下来就是把Fragment添加到Activity中。在Activity中添加Fragment的方式有两种： 静态添加：通过xml的方式添加，缺点是一旦添加就不能在运行时删除。 动态添加：运行时添加，这种方式比较灵活，因此建议使用这种方式。虽然Fragment能在XML中添加，但是这只是一个语法糖而已，Fragment并不是一个View，而是和Activity同一层次的。 这里只给出动态添加的方式。首先Activity需要有一个容器存放Fragment，一般是FrameLayout，因此在Activity的布局文件中加入FrameLayout： 1234&lt;FrameLayout android:id=\"@+id/container\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"/&gt; 然后在onCreate()中，通过以下代码将Fragment添加进Activity中。 12345if (bundle == null) { getSupportFragmentManager().beginTransaction() .add(R.id.container, Fragment1.newInstance(\"hello world\"), \"f1\") //.addToBackStack(\"fname\") .commit();} 这里需要注意几点： 因为我们使用了support库的Fragment，因此需要使用getSupportFragmentManager()获取FragmentManager。 add()是对Fragment众多操作中的一种，还有remove(), replace()等，第一个参数是根容器的id（FrameLayout的id，即”@id/container”），第二个参数是Fragment对象，第三个参数是fragment的tag名，指定tag的好处是后续我们可以通过Fragment1 frag = getSupportFragmentManager().findFragmentByTag(\"f1\")从FragmentManager中查找Fragment对象。 在一次事务中，可以做多个操作，比如同时做add().remove().replace()。 commit()操作是异步的，内部通过mManager.enqueueAction()加入处理队列。对应的同步方法为commitNow()，commit()内部会有checkStateLoss()操作，如果开发人员使用不当（比如commit()操作在onSaveInstanceState()之后），可能会抛出异常，而commitAllowingStateLoss()方法则是不会抛出异常版本的commit()方法，但是尽量使用commit()，而不要使用commitAllowingStateLoss()。 addToBackStack(\"fname\")是可选的。FragmentManager拥有回退栈（BackStack），类似于Activity的任务栈，如果添加了该语句，就把该事务加入回退栈，当用户点击返回按钮，会回退该事务（回退指的是如果事务是add(frag1)，那么回退操作就是remove(frag1)）；如果没添加该语句，用户点击返回按钮会直接销毁Activity。 Fragment有一个常见的问题，即Fragment重叠问题，这是由于Fragment被系统杀掉，并重新初始化时再次将fragment加入activity，因此通过在外围加if语句能判断此时是否是被系统杀掉并重新初始化的情况。 Fragment有个常见的异常：12345java.lang.IllegalStateException: Can not perform this action after onSaveInstanceState at android.support.v4.app.FragmentManagerImpl.checkStateLoss(FragmentManager.java:1341) at android.support.v4.app.FragmentManagerImpl.enqueueAction(FragmentManager.java:1352) at android.support.v4.app.BackStackRecord.commitInternal(BackStackRecord.java:595) at android.support.v4.app.BackStackRecord.commit(BackStackRecord.java:574) 该异常出现的原因是：commit()在onSaveInstanceState()后调用。首先，onSaveInstanceState()在onPause()之后，onStop()之前调用。onRestoreInstanceState()在onStart()之后，onResume()之前。 因此避免出现该异常的方案有： 不要把Fragment事务放在异步线程的回调中，比如不要把Fragment事务放在AsyncTask的onPostExecute()，因此onPostExecute()可能会在onSaveInstanceState()之后执行。 逼不得已时使用commitAllowingStateLoss()。 生命周期 Fragment的生命周期和Activity类似，但比Activity的生命周期复杂一些，基本的生命周期方法如下图： 生命周期 解释如下： onAttach()：Fragment和Activity相关联时调用。可以通过该方法获取Activity引用，还可以通过getArguments()获取参数。 onCreate()：Fragment被创建时调用。 onCreateView()：创建Fragment的布局。 onActivityCreated()：当Activity完成onCreate()时调用。 onStart()：当Fragment可见时调用。 onResume()：当Fragment可见且可交互时调用。 onPause()：当Fragment不可交互但可见时调用。 onStop()：当Fragment不可见时调用。 onDestroyView()：当Fragment的UI从视图结构中移除时调用。 onDestroy()：销毁Fragment时调用。 onDetach()：当Fragment和Activity解除关联时调用。 上面的方法中，只有onCreateView()在重写时不用写super方法，其他都需要。 因为Fragment是依赖Activity的，因此为了讲解Fragment的生命周期，需要和Activity的生命周期方法一起讲，即Fragment的各个生命周期方法和Activity的各个生命周期方法的关系和顺序，如图： LifeCycle 我们这里举个例子来理解Fragment生命周期方法。功能如下：共有两个Fragment：F1和F2，F1在初始化时就加入Activity，点击F1中的按钮调用replace替换为F2。 当F1在Activity的onCreate()中被添加时，日志如下： 123456789101112131415161718192021222324252627BasicActivity: [onCreate] BEGINBasicActivity: [onCreate] ENDBasicActivity: [onStart] BEGINFragment1: [onAttach] BEGIN Fragment1: [onAttach] ENDBasicActivity: [onAttachFragment] BEGINBasicActivity: [onAttachFragment] ENDFragment1: [onCreate] BEGINFragment1: [onCreate] ENDFragment1: [onCreateView]Fragment1: [onViewCreated] BEGINFragment1: [onViewCreated] ENDFragment1: [onActivityCreated] BEGINFragment1: [onActivityCreated] ENDFragment1: [onStart] BEGINFragment1: [onStart] ENDBasicActivity: [onStart] ENDBasicActivity: [onPostCreate] BEGINBasicActivity: [onPostCreate] ENDBasicActivity: [onResume] BEGINBasicActivity: [onResume] ENDBasicActivity: [onPostResume] BEGINFragment1: [onResume] BEGINFragment1: [onResume] ENDBasicActivity: [onPostResume] ENDBasicActivity: [onAttachedToWindow] BEGINBasicActivity: [onAttachedToWindow] END 可以看出： Fragment的onAttach()-&gt;onCreate()-&gt;onCreateView()-&gt;onActivityCreated()-&gt;onStart()都是在Activity的onStart()中调用的。 Fragment的onResume()在Activity的onResume()之后调用。 接下去分两种情况，分别是不加addToBackStack()和加addToBackStack()。 1、当点击F1的按钮，调用replace()替换为F2，且不加addToBackStack()时，日志如下： 12345678910111213141516171819202122232425Fragment2: [onAttach] BEGINFragment2: [onAttach] ENDBasicActivity: [onAttachFragment] BEGINBasicActivity: [onAttachFragment] ENDFragment2: [onCreate] BEGINFragment2: [onCreate] ENDFragment1: [onPause] BEGINFragment1: [onPause] ENDFragment1: [onStop] BEGINFragment1: [onStop] ENDFragment1: [onDestroyView] BEGINFragment1: [onDestroyView] ENDFragment1: [onDestroy] BEGINFragment1: [onDestroy] ENDFragment1: [onDetach] BEGINFragment1: [onDetach] ENDFragment2: [onCreateView]Fragment2: [onViewCreated] BEGINFragment2: [onViewCreated] ENDFragment2: [onActivityCreated] BEGINFragment2: [onActivityCreated] ENDFragment2: [onStart] BEGINFragment2: [onStart] ENDFragment2: [onResume] BEGINFragment2: [onResume] END 可以看到，F1最后调用了onDestroy()和onDetach()。 2、当点击F1的按钮，调用replace()替换为F2，且加addToBackStack()时，日志如下： 123456789101112131415161718192021Fragment2: [onAttach] BEGINFragment2: [onAttach] ENDBasicActivity: [onAttachFragment] BEGINBasicActivity: [onAttachFragment] ENDFragment2: [onCreate] BEGINFragment2: [onCreate] ENDFragment1: [onPause] BEGINFragment1: [onPause] ENDFragment1: [onStop] BEGINFragment1: [onStop] ENDFragment1: [onDestroyView] BEGINFragment1: [onDestroyView] ENDFragment2: [onCreateView]Fragment2: [onViewCreated] BEGINFragment2: [onViewCreated] ENDFragment2: [onActivityCreated] BEGINFragment2: [onActivityCreated] ENDFragment2: [onStart] BEGINFragment2: [onStart] ENDFragment2: [onResume] BEGINFragment2: [onResume] END 可以看到，F1被替换时，最后只调到了onDestroyView()，并没有调用onDestroy()和onDetach()。当用户点返回按钮回退事务时，F1会调onCreateView()-&gt;onStart()-&gt;onResume()，因此在Fragment事务中加不加addToBackStack()会影响Fragment的生命周期。 FragmentTransaction有一些基本方法，下面给出调用这些方法时，Fragment生命周期的变化： add(): onAttach()-&gt;…-&gt;onResume()。 remove(): onPause()-&gt;…-&gt;onDetach()。 replace(): 相当于旧Fragment调用remove()，新Fragment调用add()。 show(): 不调用任何生命周期方法，调用该方法的前提是要显示的 Fragment已经被添加到容器，只是纯粹把Fragment UI的setVisibility为true。 hide(): 不调用任何生命周期方法，调用该方法的前提是要显示的Fragment已经被添加到容器，只是纯粹把Fragment UI的setVisibility为false。 detach(): onPause()-&gt;onStop()-&gt;onDestroyView()。UI从布局中移除，但是仍然被FragmentManager管理。 attach(): onCreateView()-&gt;onStart()-&gt;onResume()。 Fragment实现原理和Back Stack 我们知道Activity有任务栈，用户通过startActivity将Activity加入栈，点击返回按钮将Activity出栈。Fragment也有类似的栈，称为回退栈（Back Stack），回退栈是由FragmentManager管理的。默认情况下，Fragment事务是不会加入回退栈的，如果想将Fragment事务加入回退栈，则可以加入addToBackStack(\"\")。如果没有加入回退栈，则用户点击返回按钮会直接将Activity出栈；如果加入了回退栈，则用户点击返回按钮会回滚Fragment事务。 我们将通过最常见的Fragment用法，讲解Back Stack的实现原理： 1234getSupportFragmentManager().beginTransaction() .add(R.id.container, f1, \"f1\") .addToBackStack(\"\") .commit(); 上面这个代码的功能就是将Fragment加入Activity中，内部实现为：创建一个BackStackRecord对象，该对象记录了这个事务的全部操作轨迹（这里只做了一次add操作，并且加入回退栈），随后将该对象提交到FragmentManager的执行队列中，等待执行。 BackStackRecord类的定义如下 1class BackStackRecord extends FragmentTransaction implements FragmentManager.BackStackEntry, Runnable {} 从定义可以看出，BackStackRecord有三重含义： 继承了FragmentTransaction，即是事务，保存了整个事务的全部操作轨迹。 实现了BackStackEntry，作为回退栈的元素，正是因为该类拥有事务全部的操作轨迹，因此在popBackStack()时能回退整个事务。 继承了Runnable，即被放入FragmentManager执行队列，等待被执行。 先看第一层含义，getSupportFragmentManager.beginTransaction()返回的就是BackStackRecord对象，代码如下： 123public FragmentTransaction beginTransaction() { return new BackStackRecord(this);} BackStackRecord类包含了一次事务的整个操作轨迹，是以链表形式存在的，链表的元素是Op类，表示其中某个操作，定义如下： 123456static final class Op { Op next; //链表后一个节点 Op prev; //链表前一个节点 int cmd; //操作是add或remove或replace或hide或show等 Fragment fragment; //对哪个Fragment对象做操作} 我们来看下具体场景下这些类是怎么被使用的，比如我们的事务做add操作。add函数的定义： 1234public FragmentTransaction add(int containerViewId, Fragment fragment, String tag) { doAddOp(containerViewId, fragment, tag, OP_ADD); return this;} doAddOp()方法就是创建Op对象，并加入链表，定义如下： 12345678private void doAddOp(int containerViewId, Fragment fragment, String tag, int opcmd) { fragment.mTag = tag; //设置fragment的tag fragment.mContainerId = fragment.mFragmentId = containerViewId; //设置fragment的容器id Op op = new Op(); op.cmd = opcmd; op.fragment = fragment; addOp(op);} addOp()是将创建好的Op对象加入链表，定义如下： 12345678910void addOp(Op op) { if (mHead == null) { mHead = mTail = op; } else { op.prev = mTail; mTail.next = op; mTail = op; } mNumOp++;} addToBackStack(“”)是将mAddToBackStack变量记为true，在commit()中会用到该变量。commit()是异步的，即不是立即生效的，但是后面会看到整个过程还是在主线程完成，只是把事务的执行扔给主线程的Handler，commit()内部是commitInternal()，实现如下： 12345678910int commitInternal(boolean allowStateLoss) { mCommitted = true; if (mAddToBackStack) { mIndex = mManager.allocBackStackIndex(this); } else { mIndex = -1; } mManager.enqueueAction(this, allowStateLoss); //将事务添加进待执行队列中 return mIndex;} 如果mAddToBackStack为true，则调用allocBackStackIndex(this)将事务添加进回退栈，FragmentManager类的变量ArrayListmBackStackIndices;就是回退栈。实现如下： 12345678public int allocBackStackIndex(BackStackRecord bse) { if (mBackStackIndices == null) { mBackStackIndices = new ArrayList&lt;BackStackRecord&gt;(); } int index = mBackStackIndices.size(); mBackStackIndices.add(bse); return index;} 在commitInternal()中，mManager.enqueueAction(this, allowStateLoss);是将BackStackRecord加入待执行队列中，定义如下： 12345678910public void enqueueAction(Runnable action, boolean allowStateLoss) { if (mPendingActions == null) { mPendingActions = new ArrayList&lt;Runnable&gt;(); } mPendingActions.add(action); if (mPendingActions.size() == 1) { mHost.getHandler().removeCallbacks(mExecCommit); mHost.getHandler().post(mExecCommit); //调用execPendingActions()执行待执行队列的事务 }} mPendingActions就是前面说的待执行队列，mHost.getHandler()就是主线程的Handler，因此Runnable是在主线程执行的，mExecCommit的内部就是调用了execPendingActions()，即把mPendingActions中所有积压的没被执行的事务全部执行。执行队列中的事务会怎样被执行呢？就是调用BackStackRecord的run()方法，run()方法就是执行Fragment的生命周期函数，还有将视图添加进container中。 与addToBackStack()对应的是popBackStack()，有以下几种变种： popBackStack()：将回退栈的栈顶弹出，并回退该事务。 popBackStack(String name, int flag)：name为addToBackStack(String name)的参数，通过name能找到回退栈的特定元素，flag可以为0或者FragmentManager.POP_BACK_STACK_INCLUSIVE，0表示只弹出该元素以上的所有元素，POP_BACK_STACK_INCLUSIVE表示弹出包含该元素及以上的所有元素。这里说的弹出所有元素包含回退这些事务。 popBackStack()是异步执行的，是丢到主线程的MessageQueue执行，popBackStackImmediate()是同步版本。 我们通过讲解Demo来更清晰地了解回退栈的使用。功能如下：共有三个Fragment：F1, F2, F3，F1在初始化时就加入Activity，点击F1中的按钮跳转到F2，点击F2的按钮跳转到F3，点击F3的按钮回退到F1。 在Activity的onCreate()中，将F1加入Activity中： 1234getSupportFragmentManager().beginTransaction() .add(R.id.container, f1, \"f1\") .addToBackStack(Fragment1.class.getSimpleName()) .commit(); F1按钮的onClick()内容如下： 1234getFragmentManager().beginTransaction() .replace(R.id.container, f2, \"f2\") .addToBackStack(Fragment2.class.getSimpleName()) .commit(); F2按钮的onClick()如下： 1234getFragmentManager().beginTransaction() .replace(R.id.container, f3, \"f3\") .addToBackStack(Fragment3.class.getSimpleName()) .commit(); F3按钮的onClick()如下： 12getFragmentManager().popBackStack(Fragment2.class.getSimpleName(), FragmentManager.POP_BACK_STACK_INCLUSIVE); 这样就完成了整个界面的跳转逻辑。 这里补充一个点getSupportFragmentManager().findFragmentByTag()是经常用到的方法，他是FragmentManager的方法，FragmentManager是抽象类，FragmentManagerImpl是继承FragmentManager的实现类，他的内部实现是： 1234567891011121314151617181920212223class FragmentManagerImpl extends FragmentManager { ArrayList&lt;Fragment&gt; mActive; ArrayList&lt;Fragment&gt; mAdded; public Fragment findFragmentByTag(String tag) { if (mAdded != null &amp;&amp; tag != null) { for (int i=mAdded.size()-1; i&gt;=0; i--) { Fragment f = mAdded.get(i); if (f != null &amp;&amp; tag.equals(f.mTag)) { return f; } } } if (mActive != null &amp;&amp; tag != null) { for (int i=mActive.size()-1; i&gt;=0; i--) { Fragment f = mActive.get(i); if (f != null &amp;&amp; tag.equals(f.mTag)) { return f; } } } return null; }} 从上面看到，先从mAdded中查找是否有该Fragment，如果没找到，再从mActive中查找是否有该Fragment。mAdded是已经添加到Activity的Fragment的集合，mActive不仅包含mAdded，还包含虽然不在Activity中，但还在回退栈中的Fragment。 Fragment通信 Fragment向Activity传递数据首先，在Fragment中定义接口，并让Activity实现该接口（具体实现省略）： 1public interface OnFragmentInteractionListener { void onItemClick(String str); //将str从Fragment传递给Activity} 在Fragment的onAttach()中，将参数Context强转为OnFragmentInteractionListener对象： 123456789public void onAttach(Context context) { super.onAttach(context); if (context instanceof OnFragmentInteractionListener) { mListener = (OnFragmentInteractionListener) context; } else { throw new RuntimeException(context.toString() + \" must implement OnFragmentInteractionListener\"); }} 并在Fragment合适的地方调用mListener.onItemClick(\"hello\")将”hello”从Fragment传递给Activity。 FABridge由于通过接口的方式从Fragment向Activity进行数据传递比较麻烦，需要在Fragment中定义interface，并让Activity实现该interface，FABridge(https://github.com/hongyangAndroid/FABridge)通过注解的形式免去了这些定义。 在build.gradle中添加依赖： 1annotationProcessor 'com.zhy.fabridge:fabridge-compiler:1.0.0'compile 'com.zhy.fabridge:fabridge-api:1.0.0' 首先定义方法ID，这里为FAB_ITEM_CLICK，接着在Activity中定义接口： 123@FCallbackId(id = FAB_ITEM_CLICK)public void onItemClick(String str) { //方法名任意 Toast.makeText(this, str, Toast.LENGTH_SHORT).show();} 最后，在Fragment中，通过以下形式调用”ID=FAB_ITEM_CLICK”的方法（该方法可能在Activity中，也可能在任何类中）： 1Fabridge.call(mActivity,FAB_ITEM_CLICK,\"data\"); //调用ID对应的方法，\"data\"为参数值 Activity向Fragment传递数据Activity向Fragment传递数据比较简单，获取Fragment对象，并调用Fragment的方法即可，比如要将一个字符串传递给Fragment，则在Fragment中定义方法： 123public void setString(String str) { this.str = str;} 并在Activity中调用fragment.setString(\"hello\")即可。 Fragment之间通信由于Fragment之间是没有任何依赖关系的，因此如果要进行Fragment之间的通信，建议通过Activity作为中介，不要Fragment之间直接通信。 DialogFragmentDialogFragment是Android 3.0提出的，代替了Dialog，用于实现对话框。他的优点是：即使旋转屏幕，也能保留对话框状态。 如果要自定义对话框样式，只需要继承DialogFragment，并重写onCreateView()，该方法返回对话框UI。这里我们举个例子，实现进度条样式的圆角对话框。 12345678910111213public class ProgressDialogFragment extends DialogFragment { @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) { getDialog().requestWindowFeature(Window.FEATURE_NO_TITLE); //消除Title区域 getDialog().getWindow().setBackgroundDrawable(new ColorDrawable(Color.TRANSPARENT)); //将背景变为透明 setCancelable(false); //点击外部不可取消 View root = inflater.inflate(R.layout.fragment_progress_dialog, container); return root; } public static ProgressDialogFragment newInstance() { return new ProgressDialogFragment(); }} 进度条动画我们使用Lottie(https://github.com/airbnb/lottie-android)实现，Lottie动画从这里(https://www.lottiefiles.com/)找到。使用非常方便，只需要下载JSON动画文件，然后在XML中写入： 123456&lt;com.airbnb.lottie.LottieAnimationView android:layout_width=\"wrap_content\" //大小根据JSON文件确定 android:layout_height=\"wrap_content\" app:lottie_fileName=\"loader_ring.json\" //JSON文件 app:lottie_loop=\"true\" //循环播放 app:lottie_autoPlay=\"true\" /&gt; //自动播放 然后通过下面代码显示对话框： 12ProgressDialogFragment fragment = ProgressDialogFragment.newInstance();fragment.show(getSupportFragmentManager(), \"tag\");//fragment.dismiss(); 为了实现圆角，除了在onCreateView()中把背景设为透明，还需要对UI加入背景： 12345&lt;shape xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;solid android:color=\"#ffffff\"/&gt; &lt;corners android:radius=\"20dp\"/&gt;&lt;/shape&gt; 转自Bugly 公众号 https://mp.weixin.qq.com/s/dUuGSVhWinAnN9uMiBaXgw 参考：https://www.jianshu.com/p/11c8ced79193 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Android","slug":"Android","permalink":"http://blog.iwxyi.com/tags/Android/"}]},{"title":"汇编MASM-学习笔记","date":"2018-11-19T12:18:00.000Z","path":"2018/11/19/汇编MASM-学习笔记/","text":"运行 DOSBox mount c: d:\\masm C: masm test.asm 回车3次 link test.obj 回车4次 debug test.exe -r 运行 -t 继续 -t 10 运行10条指令 -d 内存 -u 源码 -p 跳过（尤其是库函数） -q 退出 常用指令 assume 声明 mov 复制内存 mov ax, [bx] inc 加一 inc ax dec 减一 jmp 跳转 jmp loop1 cmp 比较大小 cmp ax, bx add 增加某数 add ax, 10 其他指令 ADC 带进位加法 LEA dx, [0000] 相当于MOV字符串 ? 比较大小 cmp cx, 0 比较结果执行下面的语句 ja &gt; above jb &lt; blow jbe &lt;= jae &gt;= jz == （相减为 zero） jnz != 库函数 INT 21 MOV AH 0A 时：接收一个用户输入到 ds[dx] MOV AH 4C 时：退出程序，返回操作系统 寄存器拆开AX = AH + AL只有 AX BX CX DX 这四个可以拆开用 常用代码块声明变量12assume cs:code, ds:data1mov ax, data1 变量加一123mov al, [bx] ; 数据段寄存器DS 到 寄存器inc al ; 增加 1mov [bx], al ; 寄存器 到 DS 循环1for (i = 0; i &lt; 10; i++); 123456mov cx, 0loop1: inc cx cmp cx, 10 jb loop1 while 循环12345i = 10;while (i &gt;= 0) { // P1 i--;} 12345678910mov ax, 10loop1: cmp ax, 0 jb next ;P1 dec ax jmp loop1next: 接收用户输入12345MOV AX, 076AMOV DS, AXMOV DX, 0000MOV AH, 0AINT 21 清屏12345678910111213141516171819 mov ax,cs mov ss,ax mov sp,0x7c00 ;set stack and sp mov ah,0x06 mov al,0 ; 准备清窗口 mov ch,0 ; 左上角的行号 mov cl,0 ; 左上角的列号 mov dh,25 ; 右下角的行号 mov dl,80 ; 右下角的行号 mov bh,0x07; 属性为蓝底白字 int 0x10 ; 执行清空操作@1: jmp @1 times 510-($-$$) db 0 db 0x55,0xaa 画白线123456789101112131415161718 mov al, 0x13 ; VGA320×200×8bit 显示模式 mov ah, 0x00 int 0x10 mov ax, 0x0a000 ; 往显存中放入点数据 mov ds, ax mov dl, 30 mov ax, 0 f: mov bx, ax mov [ds:bx], dl inc ax cmp ax, 50 ja io jmp f io: 画线函数123456789101112131415161718192021org 0x7c00 mov ax, 80 ; y mov bx, 50 ; x1 mov cx, 150 ; x2 call drawline ; 运行画线 ; y:ax, x1:bx, x2:cxdrawline: mov dx, 320 ; 屏幕宽是320 mul dx ; dx *= ax 16位中AX为被乘数，8位中AL为被乘数 sub cx, bx ; cx = x2-x1 线的宽度 add bx, ax ; 横偏移量+横纵偏移量 = 偏移位置 mov dl, 1 ; 色号loop0: mov [ds:bx], dl ; 填充颜色 inc bx ; 偏移位置+1 dec cx ; 循环次数-1 jnz loop0 ; 受到上面的DEC的ZF标志位RET 画竖线123456789101112131415;****************************************; y1-&gt;ax, y2-&gt;cx, x-&gt;bx;****************************************DrawVerticalLine: mov dx, 320 ; w = 320 mov bp, dx sub cx, ax ; y1 = y2-y1 循环次数 mul dx ; ax = w * y1 纵偏移量 add bx, ax ; 横纵偏移量 mov dl, 1x1: mov [ds:bx], dl add bx, bp dec cx jnz x1ret 设置颜色12345678910111213mov al, 1 ; 颜色号mov dx, 0x3c8out dx, almov al, 100 ; R / 4 = 25mov dx, 0x3c9out dx, almov al, 0 ; Gout dx, almov al, 0 ; Bout dx, al 数组123456789;rgb db 100, 0, 0, 0, 100, 0, 0, 0, 100rgb db 100, 0, 0, db 0, 100, 0, db 0, 0, 100mov ax, 0mov ds, axmov si, rgbmov [ds:si], ... ; 偏移地址，si为下标 进栈出栈保存变量123push axmov ax, 0pop ax 定时器每隔18分之一秒运行一次，多个任务的话会被覆盖掉 1mov word [ds:0x20],int_timer0 打印字符函数：在 ex:bx 的位置显示一个 ‘A’ 12345678910int_timer0: mov byte [es:bx],'A' mov byte [es:bx+1],0x0a inc bx ; 自增两次到下次打印的字符 inc bx mov al,0x20 mov dx,0x20 out dx,al ;EOI=0 中断 iret 获取按键输入123456789101112int_key: mov dx, 0x20 ; 下一个键值可以进来了（没有这一段就只能输入一次按键了） mov al, 0x61 out dx, al mov dx, 0x60 ; 读取一次按键 in al, dx cmp al, 0x9e jz func0func0: 显示一个数字12 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://blog.iwxyi.com/tags/学习笔记/"},{"name":"汇编","slug":"汇编","permalink":"http://blog.iwxyi.com/tags/汇编/"}]},{"title":"C简单小知识整理","date":"2018-11-13T00:18:00.000Z","path":"2018/11/13/C简单小知识整理/","text":"C 与 C++相关内容，一部分从网上摘录。个人能力水平有限，不能保证没有错误。 ——王心意，2018.11.13 必知12【必知】整数/整数 = 整数，向下取整。3/5 == 0, 需要改成：3.0/5 == 0.6 1a = 10, a += a *= 4; // 40 + 40 = 80 123a == b &lt; c; // a == (b &lt; c) // 判断a = b &lt; c; // a = (b &lt; c) // 0 或 1b &lt; c == a; // 0 或 1 == a 1for (; ; i++) { /*...*/} 中的 break 不会执行 i++ 语句，continue 会执行 i++ 1字符串复制：while (*p1++ = *p2++); // 谭浩强的书上有 12*p++; /* 地址++ */(*p)++; /* 值++ */ 读入回车解决方案 12345getchar(); // 会读入上一个scanf的回车scanf(\"%c\", &amp;c); // 这是想要的字符while(scanf(\" %c\", &amp;c) != EOF)； // 避免读取回车while(scanf(\"%c%*c\", &amp;c) != EOF); // 强行去掉回车 计算机的浮点值计算有个”不确定尾数“的现象： 120.1+0.2 != 0.3 // 0.300000000000000040.1+0.5 == 0.6 原因看 https://0.30000000000000004.com 123char a[] = \"hello\"; strcpy(a, \"hehe\"); // 正确，字符串常量能当做临时的指针常量char *p = \"hello\"; p[2] = 'a'; // 错误，常量不能改 123int a[5], (*p)[5]; // 指向数组的指针，下标必须明确p = &amp;a;(*p)[i] == a[i]; 1puts(str[2])、strlen(&amp;str[2])、gets(str+2); //都是从第二个位置开始。输入后末尾自动加上 '\\0' （即 ASCII码的 0） 12int a = 3; int &amp;b = a; // 引用类型：对b操作就是对a操作，printf(\"%d\", b)就是3void swap( int &amp;a, int &amp;b); //引用，比指针方便 取 int 或者 long long 变量的某个数字，如：125 / 10 % 10; //倒数第二位 函数 floor( f ) 对浮点数取整，但是因为浮点数误差，一般用：floor( f + 0.5);浮点数陷阱：for (double i = 0; i != 10; i++); // 死循环 升级1printf(\"%d %d %d\", a, a++, a++); //在有些编译器上（实测如VC，不包括VS），从右到左执行，从左到右输出，a=10时会输出：12， 11， 10 1a = b = 3; // 是从右到左开始运算，而非从左到右 不使用临时变量交换两个整数 123a = a + bb = a - ba = a - b 输出”\\r”字符串，光标位置回调到行首，并逐字覆盖这一行的文字（可用于做表格） 1int i1, i2; // 分配空间（例子）：i1:10008，i2:10004 逆序添加 static int m; 可以让其他文件不能调用变量或者函数，作用域只限于本模块头文件不要定义全局变量（多次调用会报告已声明），可以用 extern 很大的数组比如几百亿的，开到全局（main函数外面，太大了也必须全局），会全部自动初始化成 0 (2^32) - 1 = 4294967295，unsigned 的大小-n 的内部表示是：(2 ^ 32) - n; 判断素数： 1234if (n &lt; 2) return 0;for (int i = 2; i * i &lt;= n; i++) if (n % i == 0) return 0;return 1; 也可以素数筛按照倍数打表（多次用到或数字很大时） int q = 0; !q 的值在 0 和 非零 之间变换 1scanf(\"%*s\"); // 可以跳过输入一个字符串，其他类型同理 123char t[] = \"hello\\0world\";sizeof(t) == 12;strlen(t) == 5; 数字转换成字符串：sprintf(str, \"%d\", num);字符串转换成数字：sscanf(str, \"%d\", &amp;num); 清空queue等STL的数据：que.swap( queue&lt;T&gt;() ) ; //消亡值语义 void指针（仅用于代表地址）： 12345678910void zero(void * data, int bytesize){ char * p = (char *)data; for (int i = 0; i &lt; bytesize; i++) *ptr++ = 0;}int nums[30]; zero(nums, sizeof(nums)); //不管什么类型，都能按照字符（字节）来清零，因为字节总长度不变Person p1; zero(p1, sizeof(p1)); //Person 为 struct 结构体，也能用同一个函数来清零 或者 复制数据 strncat、strncpy：比较安全的函数，第三个参数是数量，比如：sizeof(num)/sizeof(int) 指向函数的指针： 123typedef void (* intFunc)(int i);test1(int a) { printf(\"%d\\n\", a); } // intFunc 就是一个指向函数test1的指针了intFunc func = test1; func(3); 1( a * 2 + 1 ) == ( a &lt;&lt; 1 | 1 )； // 位运算速度快很多很多 1std::ios::sync_with_stdio(false); // 禁用 cin 和 stdin 的同步，大大加快C艹的cin速度，与scanf相差无几（约为三倍） 1a / b % m == a % (m * b) / b // 取模 字符串常量[下标]，例如：\"qwerty\"[4] == 'r' C语言只有一维数组，但数组元素可以是另一个数组，仿真出多维数组 16进制用0x开头，八进制用0开头；小数常量默认double，末尾可加f表示为float；整数常量默认int，末尾可加l表示是long；其他格式同理（然而没必要的，有隐式转换） 随机数（例如rand()函数）并不是真的随机（但有些新设备可以实现真随机） 叨唠// C语言的爸爸是B语言没错 // 即使从面向过程的C语言转到面向对象的C++，你也不一定能找到对象。 // 计算机的减法乘法都是通过加法器来实现的（最终都可以分解为与或非逻辑门组合运算） // 大部分程序员不用关注二进制是啥（但考试要考到） // 你写程序的大部分时间不是在写代码 // 看到这句话将会很开心： 0 error,0 warning // 项目中适当的注释往往比代码本身还重要 // 仅用顺序结构，分支结构和循环结果能写出所有的可计算函数。 // 可以用多个不同的编辑器看看这段注释的颜色：/*/zhushi/*/ 偏僻知识点（来自网络）无符号int自动转换12345678910void foo(){ unsigned int a = 6; int b = -20; (a+b &gt; 6)?puts(\"&gt; 6\") : puts(\"&lt;= 6\"); //输出 &gt;6 /* 原因是当表达式中存在有符号类型和无符号类型时所有的操作数都自动转换为无符号类型，因此-20变成了一个非常大的 正整数，所以该表达式计算出的结果大于 6 */} 数组共同体12345678910111213141516union{ int i; char x[2];}a;void fun(){ a.x[0] = 10; a.x[1] = 2; printf(\"%d-%d-%d\\n\",a.i,a.x[0],a.x[1]);//522-10-2 :说明a.x[0]与a.x[1]互无影响，所以它们的地址是不同的。a.i=a.x[0]+a.x[1]*256(2的8次方); a.i=1027; printf(\"%d-%d-%d\\n\",a.i,a.x[0],a.x[1]);//1027-3-4 1027=(4)*256+(3) a.x[0] = 300; a.x[1] = 10; printf(\"%d-%d-%d\\n\",a.i,a.x[0],a.x[1]);//2604-44-10, a.x[0]=300-256=44;a.i=a.x[0]+a.x[1]*256;} union这种类型，就是内部的变量共同使用一块空间，按照size大的分配，int i 占4个字节，char x[2] 占2个，所以一共分配了4个字节。一共4个字节的内存，对应x来说相当于占用了低2个字节，而给x赋值的1，和10，就存在个位和十位上了（十六进制） 公用体公用一个内存区域sizeof(a)为共用体成员中长度最长的成员的size。即i 1234int: (|_|_|_|_|_|_|_|_|)(|_|_|_|_|_|_|_|_|)(|_|_|_|_|_|_|_|_|)(|_|_|_|_|_|_|_|_|)char x[2] : (|_|_|_|_|_|_|_|_|)(|_|_|_|_|_|_|_|_|) ^ ^ 高地址 低地址 分析： 12a.x[0] = 10 ============&gt;(|0|0|0|0|1|0|1|0|)a.x[1] = 2 ============&gt;(|0|0|0|0|0|0|1|0|) 公用体公用sizeof(int)长度即4字节32为，则赋值后共用体内存为 1a: (|0|0|0|0|0|0|0|0|)(|0|0|0|0|0|0|0|0|)(|0|0|0|0|0|0|1|0|)(|0|0|0|0|1|0|1|0|) a.i 为4字节整型，则 i = 2^9 + 2^3 + 2^1 = 256 + 8 + 2 = 522 宏定义运算1234567891011121314#include &lt;iostream&gt;using namespace std;#define SQR(X) X*Xint main(void){ int i=10,j=5,n=10; n*=i+j;//n=n*(i+j) cout&lt;&lt;n&lt;&lt;endl;//150 int a = 10,k = 2, m=1; a /= SQR(k+m)/SQR(k+m); // 等效于 a /= (k+m*k+m/k+m*k+m) cout&lt;&lt;a&lt;&lt;endl;//1 return 0;} 宏定义运算尽量添加小括号 1#define SQR(X) (X*X) sizeof(union)123456789101112#include &lt;iostream&gt;using namespace std;union A {int a_int1;double a_double;int a_int2;};typedef struct{A a1;char y;} B;class C{double c_double;B b1;A a2;};int main(void){ cout&lt;&lt;sizeof(A)&lt;&lt;endl;//8 cout&lt;&lt;sizeof(B)&lt;&lt;endl;//16 cout&lt;&lt;sizeof(C)&lt;&lt;endl;//32 return 0;} 数组内存分配123456789101112char str1[] = \"abc\";char str2[] = \"abc\";const char str3[] = \"abc\";const char str4[] = \"abc\";const char *str5 = \"abc\";const char *str6 = \"abc\";char *str7 = \"abc\";char *str8 = \"abc\";cout &lt;&lt; ( str1 == str2 ) &lt;&lt; endl; // 0cout &lt;&lt; ( str3 == str4 ) &lt;&lt; endl; // 0cout &lt;&lt; ( str5 == str6 ) &lt;&lt; endl; // 1cout &lt;&lt; ( str7 == str8 ) &lt;&lt; endl; // 1 解答：str1,str2,str3,str4是数组变量，它们有各自的内存空间;而str5,str6,str7,str8是指针，它们指向相同的常量区域。 char &lt;==&gt; int应该不算偏僻，ACM刷题经常会用到（刷题之外就用到的不多了） 123456//一位整数 to char char x=5+'0'; //'5'//一位整数的char to int int y='5'-'0'; //5//获取'a'后面的'd' char z='a'+3;//'d' 自增12345678910111213141516171819202122232425void testplusplus(){ { int a=4; a += (a++);//==&gt;&gt; a=a+(a++); cout&lt;&lt;a&lt;&lt;endl;//9 } { int a=4; a += (++a);//==&gt;&gt; a = a+(++a); cout&lt;&lt;a&lt;&lt;endl;//10 } { int a=4; //(a++) += a;//error，\"+=\"左操作数必须为左值 cout&lt;&lt;a&lt;&lt;endl; } { int a=4; (++a) += (a++); //A=(++a); //A=A+(a++) cout&lt;&lt;a&lt;&lt;endl;//11 }} 总结：(a++),在整个表达式执行完后，才+1;(++a),在整个表达式执行前就+1; 连接下一行行尾添加反斜杠 \\ 如果在宏定义中使用，则真正代码也会包括换行。可用来做接口宏。 多行字符串也能用这个来拼接。 数组下标为0数组下标为0时，指针p不分配空间 12345Struct MutableLenArray { int count; char p[0]; }; 任意字符串使用 # 符号 12#define TO_STRING(x) #xconst char *str = TO_STRING( test ); str的内容就是\" test \"，也就是说#会把其后的符号 直接加上双引号。 符号连接##符号会连接两个符号，从而产生新的符号(词法层次)，例如： 12#define SIGN( x ) INT_##xint SIGN( 1 ); 宏被展开后将成为：int INT_1; 变参宏12#define LOG( format, ... ) printf( format, VA_ARGS )LOG( \"%s %d\", str, count ); VA_ARGS是系统预定义宏，被自动替换为参数列表。 宏例外当一个宏参数被放进宏体时，如果宏体（外部的宏）参数有#，则宏体的参数不会展开。若要展开，则需要借助第三个宏 123#define PARAM(x) PARAM1(x)#define PARAM1( x ) #x #define ADDPARAM( x ) INT_##x 函数参数指针与引用函数参数指针和引用的区别：引用必须已经初始化，且不能为空；指针可以 const 引用常量const 引用能引用常量：const double &amp;PI = 3.14 非const不能引用常量 C语言主要关键词基本类型：int, short,long, signed, unsigned,char,float, double,void 控制：if...else, switch...case...default, for , while, do...while,return, break, continue,goto 自定义类型：enum, struct, union, typedef 修饰词：const, static, extern, inline, restrict, volatile 运算符：+, -, *,/, %,++,--,&amp;,| ,~, ^,&amp;&amp;,||,!,&lt;,&gt;,&lt;=,&gt;=,==,!=, &lt;&lt;,&gt;&gt;, ., -&gt;,?:,sizeof及复合运算符 预处理器：#include, #define, #undef, #if/#ifdef/#ifndef...#elif...#else...#endif, defined, #pragma,#error 有极少数关键字有多种语义，例如static、void 掌握上面这些就算入门了。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"C","slug":"C","permalink":"http://blog.iwxyi.com/tags/C/"},{"name":"整理","slug":"整理","permalink":"http://blog.iwxyi.com/tags/整理/"}]},{"title":"C++多个文件共用全局变量","date":"2018-11-06T00:01:00.000Z","path":"2018/11/06/C-多个文件共用全局变量/","text":"示例： 头文件：state.h 源文件：state.cpp其它源文件：t1.cpp t2.cpp t3.cpp, 这些源文件都包含头文件state.h。 需要定义一个全局变量供这些源文件中使用：方法如下 1、在state.h中声明全局变量： extern int a; 2、在state.cpp中定义该全局变量：int a =10; 这样其它源文件就可以使用该变量啦，只需要 include 一下 state.cpp 这里需要的是“声明”，不是“定义”！根据C++标准的规定，一个变量声明必须同时满足两个条件，否则就是定义： (1)声明必须使用extern关键字；(2)不能给变量赋初值 extern int a; //声明 int a; //定义 int a = 0; //定义 extern int a =0; //定义 头文件中应使用extern关键字声明全局变量（不定义），如果这个变量有多个文件用到，可以新建一个cpp，在其中定义，把这个cpp加入工程即可。头文件请不要定义任何变量，那是非常业余的行为…… 定义专用的 .cpp 文件不需要 include 一般在头文件中声明，用extern；在cpp中定义。 如果在头文件中定义，如果这个头文件被多个cpp引用，会造成重复定义的链接错误。 头文件只能申明全局变量（extern），不可定义（不推荐使用）.cpp里，在最外层定义即可（int gi），直接引用 如果在.cpp里使用static定义，则该变量只在当前cpp文件中有效，在别的文件中无效在.h里使用static定义，不会进行编译（.h文件不编译），只会在其每个include的cpp文件中包含编译，相当于在.cpp里使用static定义。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"C++","slug":"C","permalink":"http://blog.iwxyi.com/tags/C/"}]},{"title":"贪心算法-讲解","date":"2018-11-04T12:46:00.000Z","path":"2018/11/04/贪心算法/","text":"ACM 贪心算法贪心算法（又称贪婪算法）是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的是在某种意义上的局部最优解。 例题钱币找零问题假设1元、2元、5元、10元、20元、50元、100元的纸币分别有c0, c1, c2, c3, c4, c5, c6张。现在要用这些钱来支付K元，至少要用多少张纸币？ 代码12345678910111213141516171819202122232425#include &lt;stdio.h&gt;#include &lt;math.h&gt;#include &lt;algorithm&gt;using namespace std;const int N=7;int Count[N]={3,0,2,1,0,3,5};int Value[N]={1,2,5,10,20,50,100};int main(){ int money; scanf(\"%d\", &amp;money); int num = 0; for(int i=N-1;i&gt;=0;i--) { int c=min(money/Value[i],Count[i]); money=money-c*Value[i]; num+=c; } if(num!=-1) printf(\"%d\\n\", num); else printf(\"NO\\n\");} 可分割背包问题有一个背包，背包容量是M，有N个物品，要求尽可能让装入背包中的物品总价值最大，但不能超过总容量，物品可以只取一部分。 输入第一行输入一个正整数n（1&lt;=n&lt;=5）,表示有n组测试数据；随后有n测试数据，每组测试数据的第一行有两个正整数s，m（1&lt;=s&lt;=10）;s表示有s个物品。接下来的s行每行有两个正整数v，w，分别表示物品的单位价值和总质量。输出输出每组测试数据中背包内的物品的价值和，每次输出占一行。样例输入 1234513 155 102 83 9 样例输出 165 代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354#include &lt;stdio.h&gt;#include &lt;algorithm&gt;using namespace std;#define MAXN 10000int main(int argc, char const *argv[]){ int T; scanf(\"%d\", &amp;T); while (T--) { int n, m; int v[MAXN], w[MAXN]; scanf(\"%d%d\", &amp;n, &amp;m); for (int i = 0; i &lt; n; i++) scanf(\"%d%d\", &amp;v[i], &amp;w[i]); for (int i = 0; i &lt; n - 1; i++) for (int j = 0; j &lt; n - i - 1; j++) if (v[j] &lt; v[j + 1]) { int temp = v[j]; v[j] = v[j + 1]; v[j + 1] = temp; temp = w[j]; w[j] = w[j + 1]; w[j + 1] = temp; } int ans = 0; for (int i = 0; i &lt; n; i++) { if (w[i] &gt;= m) { ans += m * v[i]; m = 0; break; } else { ans += w[i] * v[i]; m -= w[i]; } } printf(\"%d\\n\", ans); } return 0;} 排序冒泡排序12345678for (int i = 0; i &lt; len - 1; i++) for (int j = 0; j &lt; len - 1 - i; j++) if (arr[j] &gt; arr[j + 1]) { temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; } 选择排序12345678910for(i = 0; i &lt; n-1; i++){ min = i;//查找最小值 for(j = i+1; j&lt;n; j++) if(A[min] &gt; A[j]) min = j; if(min != i) swap(&amp;A[min], &amp;A[i]);} 其他排序已经帮你们百度好的链接 建议用C++的 algorithm 头文件中的 sort 函数，也是ACM中最常用的排序算法。 缺点贪心算法不是对所有问题都能得到整体最优解，关键是贪心策略的选择，选择的贪心策略必须具备无后效性，即某个状态以前的过程不会影响以后的状态，只与当前状态有关。 ⑴贪心策略：总价值最大反例： W=30物品：A B C重量：28 12 12价值：30 20 20 根据策略，首先选取物品A，接下来就无法再选取了，可是，选取B、C则更好。 ⑵贪心策略：重量最小它的反例与第一种策略的反例差不多。 ⑶贪心策略：单位量价值最大反例： W=30物品：A B C重量：28 20 10价值：28 20 10 根据策略，三种物品单位重量价值一样，程序无法依据现有策略作出判断，如果选择A，则答案错误。 【注意：如果物品可以分割为任意大小，那么策略3可得最优解】 (4)DP问题（动态规划）W=40物品：A B C重量：25 20 15价值：25 20 15 这需要DP。 题目今年暑假不AC（节目表）“今年暑假不AC？”“是的。”“那你干什么呢？”“看世界杯呀，笨蛋！”“@#$%^&amp;*%…” 确实如此，世界杯来了，球迷的节日也来了，估计很多ACMer也会抛开电脑，奔向电视了。作为球迷，一定想看尽量多的完整的比赛，当然，作为新时代的好青年，你一定还会看一些其它的节目，比如新闻联播（永远不要忘记关心国家大事）、非常6+7、超级女生，以及王小丫的《开心辞典》等等，假设你已经知道了所有你喜欢看的电视节目的转播时间表，你会合理安排吗？（目标是能看尽量多的完整节目） Input 输入数据包含多个测试实例，每个测试实例的第一行只有一个整数n(n&lt;=100)，表示你喜欢看的节目的总数，然后是n行数据，每行包括两个数据Ti_s,Ti_e (1&lt;=i&lt;=n)，分别表示第i个节目的开始和结束时间，为了简化问题，每个时间都用一个正整数表示。n=0表示输入结束，不做处理。 Output 对于每个测试实例，输出能完整看到的电视节目的个数，每个测试实例的输出占一行。 Sample Input 123456789101112131412 1 3 3 4 0 7 3 8 15 19 15 20 10 15 8 18 6 12 5 10 4 14 2 9 0 Sample Output 15 代码（HDU 2037）123456789101112131415161718192021222324252627282930313233343536373839404142#include&lt;stdio.h&gt;int main(int argc, const char *argv[]){ int i, n, j, tmp; while (scanf(\"%d\", &amp;n) != EOF &amp;&amp; n != 0) { int count = 1, a[100] = {0}, b[100] = {0}; for (i = 0; i &lt; n; i++) scanf(\"%d %d\", &amp;a[i], &amp;b[i]); for (i = 0; i &lt; (n - 1); i++) { for (j = 0; j &lt; (n - 1 - i); j++) { if (b[j] &gt; b[j + 1]) { tmp = a[j]; a[j] = a[j + 1]; a[j + 1] = tmp; tmp = b[j]; b[j] = b[j + 1]; b[j + 1] = tmp; } } } int time = 0; for (i = 1; i &lt; n; i++) { if (a[i] &gt;= b [time]) { time = i; count++; } } printf(\"%d\\n\", count); } return 0;} 阶乘之和描述给你一个非负数整数n，判断n是不是一些数（这些数不允许重复使用，且为正数）的阶乘之和，如9=1！+2!+3!，如果是，则输出Yes，否则输出No； 输入第一行有一个整数0&lt;m&lt;100,表示有m组测试数据；每组测试数据有一个正整数n&lt;1000000;输出如果符合条件，输出Yes，否则输出No;样例输入 122910 样例输出 12YesNo 喷水装置（一）描述现有一块草坪，长为20米，宽为2米，要在横中心线上放置半径为Ri的喷水装置，每个喷水装置的效果都会让以它为中心的半径为实数Ri(0&lt;Ri&lt;15)的圆被湿润，这有充足的喷水装置i（1&lt;i&lt;600)个，并且一定能把草坪全部湿润，你要做的是：选择尽量少的喷水装置，把整个草坪的全部湿润。 输入第一行m表示有m组测试数据每一组测试数据的第一行有一个整数数n，n表示共有n个喷水装置，随后的一行，有n个实数ri，ri表示该喷水装置能覆盖的圆的半径。 输出输出所用装置的个数 样例输入 12345252 3.2 4 4.5 6 101 2 3 1 2 1.2 3 1.1 1 2 样例输出 1225 &gt; 喷水装置（二）改成二维，输入装置个数n、草坪宽 w、高 h（实数），以及每个喷水装置的横坐标和半径。其余题意同上一题。 过河问题描述在漆黑的夜里，N位旅行者来到了一座狭窄而且没有护栏的桥边。如果不借助手电筒的话，大家是无论如何也不敢过桥去的。不幸的是，N个人一共只带了一只手电筒，而桥窄得只够让两个人同时过。如果各自单独过桥的话，N人所需要的时间已知；而如果两人同时过桥，所需要的时间就是走得比较慢的那个人单独行动时所需的时间。问题是，如何设计一个方案，让这N人尽快过桥。 输入第一行是一个整数T(1&lt;=T&lt;=20)表示测试数据的组数每组测试数据的第一行是一个整数N(1&lt;=N&lt;=1000)表示共有N个人要过河每组测试数据的第二行是N个整数Si,表示此人过河所需要花时间。(0&lt;Si&lt;=100)输出输出所有人都过河需要用的最少时间样例输入 123141 2 5 10 样例输出 117 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"算法","slug":"算法","permalink":"http://blog.iwxyi.com/tags/算法/"},{"name":"讲解","slug":"讲解","permalink":"http://blog.iwxyi.com/tags/讲解/"}]},{"title":"Python解析网络JSON","date":"2018-11-04T05:39:00.000Z","path":"2018/11/04/Python解析网络JSON/","text":"123456789import jsonfrom urllib.request import urlopenurl = \"https://gdata.youtube.com/feeds/api.standardfeeds/top_rated?alt=json\"response = urlopen(url)contents = response.read()text = contents.decode('utf8')data = json.loads(text)for video in data['feed']['entry'][0:6]:print(video['title']['$t']) 第1行：从Python标准库中导入名为json的所有代码。第2行：从Python标准urllib库中导入urlopen函数。第3行：给变量url赋值一个YouTube地址。第4行：连接指定地址处的Web服务器并请求指定的Web服务。第5行：获取响应数据并赋值给变量contents。第6行：把contents解码成一个JSON 格式的文本字符串并赋值给变量text。第7行：把text转换为data——一个存储视频信息的Python数据结构。第8行：每次获取一个视频的信息并赋值给变量video。第8行：使用两层Python字典（data[‘feed’][‘entry’]）和切片操作（[0:6]）。第9行：使用print函数打印出视频标题。 使用第三方Python软件包requests 123456import requestsurl = \"https://gdata.youtube.com/feeds/api.standardfeeds/top_rated?alt=json\"response = requests.get(url)data = response.json()for video in data['feed']['entry'][0:6]:print(video['title']['$t']) document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Python","slug":"Python","permalink":"http://blog.iwxyi.com/tags/Python/"}]},{"title":"Android ViewPage模板","date":"2018-10-29T03:02:00.000Z","path":"2018/10/29/Android-ViewPage模板/","text":"多可左右滑动的分页容器模板 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879import android.support.v7.app.AppCompatActivity;import android.support.v4.app.Fragment;import android.support.v4.app.FragmentManager;import android.support.v4.app.FragmentPagerAdapter;import android.support.v4.view.ViewPager;import android.os.Bundle;import android.view.LayoutInflater;import android.view.View;import android.view.ViewGroup;import android.widget.TextView;public class MainActivity extends AppCompatActivity { private SectionsPagerAdapter mSectionsPagerAdapter; // 适配器 private ViewPager mViewPager; // 容器 @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); // 通过 FragmentManager 创建适配器 mSectionsPagerAdapter = new SectionsPagerAdapter(getSupportFragmentManager()); // 设置 ViewPager 容器 mViewPager = (ViewPager) findViewById(R.id.container); mViewPager.setAdapter(mSectionsPagerAdapter); } /* fragment 类 */ public static class PlaceholderFragment extends Fragment { // 定义一个储存参数的key的常量 private static final String ARG_SECTION_NUMBER = \"section_number\"; public PlaceholderFragment() { } // 创建一个 fragment，好像是工厂模式？（静态） public static PlaceholderFragment newInstance(int sectionNumber) { PlaceholderFragment fragment = new PlaceholderFragment(); Bundle args = new Bundle(); args.putInt(ARG_SECTION_NUMBER, sectionNumber); fragment.setArguments(args); return fragment; } // 返回一个 inflate 的 view，并且读取参数并设置 @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) { View rootView = inflater.inflate(R.layout.fragment_main, container, false); TextView textView = (TextView) rootView.findViewById(R.id.section_label); textView.setText(getString(R.string.section_format, getArguments().getInt(ARG_SECTION_NUMBER))); return rootView; } } /* 适配器 */ public class SectionsPagerAdapter extends FragmentPagerAdapter { public SectionsPagerAdapter(FragmentManager fm) { super(fm); } // 只在第一次的时候才需要 getItem，创建一个fragment @Override public Fragment getItem(int position) { return PlaceholderFragment.newInstance(position + 1); } @Override public int getCount() { return 3; } }} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Android","slug":"Android","permalink":"http://blog.iwxyi.com/tags/Android/"},{"name":"模板","slug":"模板","permalink":"http://blog.iwxyi.com/tags/模板/"}]},{"title":"Android Color类颜色值坑点","date":"2018-10-29T02:39:00.000Z","path":"2018/10/29/Android-Color类颜色值坑点/","text":"Color.alpha 0x00~0xFF 00表示完全透明，FF表示完全不透明 其中有两个方法 Color.argb(int alpha, int red, int green, int blue);//设置颜色，同步设置颜色的透明度 Color.rgb(int red, int green, int blue);//设置颜色，默认透明度为0xFF，完全不透明 在面试的时候，笔试的时候，很多题目会提到颜色相同的rgb和argb有哪些？ 如下是我自己验证过的内容 FFAABB = FFFFAABB != 00FFAABB 上面的比较简单，很容易理解，比较容易误导人的是这样的 FFAB ?= FAB 不等于 FFFAB ?= FAB 等于 FFFAB ?= FFAB 不等于 FFAABB ?= FAB 不等于 得出以下结论：在只有单个字符去表示颜色时:F == 0F, A == 0A…，可以使用这个公式去替换掉上面这些公式，转换之后： FFAB ?= FAB -&gt; 0F 0F 0A 0B ?= FF 0F 0A 0B 明显，不相等 FFFAB ?= FAB -&gt; FF 0F 0A 0B ?= FF 0F 0A 0B 相等 FFFAB ?= FFAB -&gt; FF 0F 0A 0B ?= 0F 0F 0A 0B 不相等 FFAABB ?= FAB -&gt; FF FF AA BB ?= FF 0F 0A 0B 不相等 参考：https://blog.csdn.net/sunhengzhi_212/article/details/73028313 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Android","slug":"Android","permalink":"http://blog.iwxyi.com/tags/Android/"},{"name":"踩坑","slug":"踩坑","permalink":"http://blog.iwxyi.com/tags/踩坑/"}]},{"title":"Android ViewPage","date":"2018-10-27T03:01:00.000Z","path":"2018/10/27/Android-ViewPage/","text":"（注：本篇文章的例子使用的是ConstraintLayout布局方式） ViewPage有两种使用方式，一是直接加载布局文件（使用PagerAdapter），二是加载fragment（使用FragmentPagerAdapter）。 一、直接加载布局文件1. 在主布局中加入ViewPage123456789101112131415161718&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;android.support.constraint.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" tools:context=\"com.example.test.MainActivity\"&gt; &lt;android.support.v4.view.ViewPager android:id=\"@+id/viewPage\" android:layout_width=\"0dp\" android:layout_height=\"0dp\" app:layout_constraintBottom_toBottomOf=\"parent\" app:layout_constraintLeft_toLeftOf=\"parent\" app:layout_constraintRight_toRightOf=\"parent\" app:layout_constraintTop_toTopOf=\"parent\"&gt;&lt;/android.support.v4.view.ViewPager&gt;&lt;/android.support.constraint.ConstraintLayout&gt; 2. 新建三个layout为了方便我们新建三个基本一样的layout。layout1： 1234567891011121314151617181920212223&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;android.support.constraint.ConstraintLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" xmlns:tools=\"http://schemas.android.com/tools\" android:orientation=\"vertical\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;TextView android:layout_width=\"0dp\" android:layout_height=\"0dp\" android:text=\"layout1\" app:layout_constraintBottom_toBottomOf=\"parent\" app:layout_constraintLeft_toLeftOf=\"parent\" app:layout_constraintRight_toRightOf=\"parent\" app:layout_constraintTop_toTopOf=\"parent\" app:layout_constraintVertical_bias=\"0.498\" tools:layout_constraintBottom_creator=\"1\" tools:layout_constraintLeft_creator=\"1\" tools:layout_constraintRight_creator=\"1\" tools:layout_constraintTop_creator=\"1\" android:layout_marginLeft=\"0dp\" /&gt;&lt;/android.support.constraint.ConstraintLayout&gt; 这三个布局是添加到ViewPage中的，里面的内容非常简单，当然我们只是为了测试，你可以在其中加入更多的东西。 3. 适配器PagerAdapter新建ViewPageAdapter继承自PagerAdapter： 123456789101112131415161718192021222324252627282930313233343536373839package com.example.test;import android.support.v4.view.PagerAdapter;import android.view.View;import android.view.ViewGroup;import java.util.List;public class ViewPageAdapter extends PagerAdapter { private List&lt;View&gt; list; public ViewPageAdapter(List&lt;View&gt; list) { this.list = list; } // 返回要滑动的VIew的个数 @Override public int getCount() { return list.size(); } @Override public boolean isViewFromObject(View view, Object object) { return view == object; } // 做了两件事，第一：将当前视图添加到container中，第二：返回当前View @Override public Object instantiateItem(ViewGroup container, int position) { container.addView(list.get(position)); return list.get(position); } // 从当前container中删除指定位置（position）的View @Override public void destroyItem(ViewGroup container, int position, Object object) { container.removeView(list.get(position)); }} 4. 在Activity中配置ViewPage123456789101112131415161718192021222324252627282930313233343536package com.example.test;import android.support.v4.view.ViewPager;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.view.LayoutInflater;import android.view.View;import java.util.ArrayList;import java.util.List;public class MainActivity extends AppCompatActivity { private View view1, view2, view3; private List&lt;View&gt; viewList;//view数组 private ViewPager viewPager; //对应的viewPager @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); viewPager = (ViewPager) findViewById(R.id.viewPage); LayoutInflater inflater=getLayoutInflater(); view1 = inflater.inflate(R.layout.layout1, null); view2 = inflater.inflate(R.layout.layout2,null); view3 = inflater.inflate(R.layout.layout3, null); viewList = new ArrayList&lt;View&gt;();// 将要分页显示的View装入数组中 viewList.add(view1); viewList.add(view2); viewList.add(view3); ViewPageAdapter adapter = new ViewPageAdapter(viewList); viewPager.setAdapter(adapter); }} 上面的代码将layout加载到view中，把view放到数组中并设置到Adapter中，最后给ViewPage设置Adapter。到这里第一种方式实现ViewPage就完成了。 二、加载fragment通过加载fragment设置ViewPage与第一种方式的前两步一样，加载主布局和新建三个layout这里省略直接进行第三步。 3. 新建fragmentfragment1： 12345678910111213141516171819202122232425262728package com.example.test;import android.os.Bundle;import android.support.v4.app.Fragment;import android.view.LayoutInflater;import android.view.View;import android.view.ViewGroup;import android.widget.TextView;/** * A simple {@link Fragment} subclass. */ public class Fragment1 extends Fragment { public Fragment1() { // Required empty public constructor } @Override public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) { View rootView=inflater.inflate(R.layout.layout1, container, false); return rootView; }} 代码很简单，这里新建了三个fragment，分别加载三个layout。 4. 适配器FragmentPagerAdapter新建ViewPageFragmentAdapter继承自FragmentPagerAdapter： 1234567891011121314151617181920212223242526272829303132333435package com.example.test;import android.support.v4.app.Fragment;import android.support.v4.app.FragmentManager;import android.support.v4.app.FragmentPagerAdapter;import java.util.ArrayList;import java.util.List;/** * Created by Administrator on 2017/7/11. */public class ViewPageFragmentAdapter extends FragmentPagerAdapter { private List&lt;Fragment&gt; fragmentList = new ArrayList&lt;&gt;(); public ViewPageFragmentAdapter(FragmentManager fm) { super(fm); } public void addFragment(Fragment fragment) { fragmentList.add(fragment); } @Override public Fragment getItem(int position) { return fragmentList.get(position); } @Override public int getCount() { return fragmentList.size(); }} 除了必须要实现的几个方法外，这里我自定义了一个方法addFragment()，用于将fragment传递进来。 5. 在Activity中配置ViewPage12345678910111213141516171819202122232425262728package com.example.test;import android.support.v4.view.ViewPager;import android.support.v7.app.AppCompatActivity;import android.os.Bundle;import android.view.LayoutInflater;import android.view.View;import java.util.ArrayList;import java.util.List;public class MainActivity extends AppCompatActivity { private ViewPager viewPager; //对应的viewPager @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); viewPager = (ViewPager) findViewById(R.id.viewPage); ViewPageFragmentAdapter adapter = new ViewPageFragmentAdapter(getSupportFragmentManager()); adapter.addFragment(new Fragment1()); adapter.addFragment(new Fragment2()); adapter.addFragment(new Fragment3()); viewPager.setAdapter(adapter); }} 新建适配器，将fragment加入到适配器中并给ViewPage设置适配器。 参考：https://blog.csdn.net/shanshui911587154/article/details/74963447 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Android","slug":"Android","permalink":"http://blog.iwxyi.com/tags/Android/"}]},{"title":"Android Fragment用法","date":"2018-10-23T02:44:00.000Z","path":"2018/10/23/Android-Fragment用法/","text":"Android Fragment 简单实例 这里用的是import android.support.v4.app.FragmentTransaction，而不是import android.app.FragmentTransaction，后者会报错的。 Fragment 在 onCreateView这里初始化控件 12345678910public class MessageFragment extends Fragment{ private TextView tv; public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) { View messageLayout = inflater.inflate(R.layout.message, container, false); tv=(TextView) messageLayout.findViewById(R.id.message); tv.setText(\"哈哈哈哈哈哈\"); return messageLayout; }} Activity 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193public class MainActivity extends Activity implements OnClickListener {/*** 用于展示消息的Fragment*/private MessageFragment messageFragment; /*** 用于展示联系人的Fragment*/private ContactsFragment contactsFragment; /*** 用于展示动态的Fragment*/private NewsFragment newsFragment; /*** 用于展示设置的Fragment*/private SettingFragment settingFragment; /*** 消息界面布局*/private View messageLayout; /*** 联系人界面布局*/private View contactsLayout; /*** 动态界面布局*/private View newsLayout; /*** 设置界面布局*/private View settingLayout;/*** 用于对Fragment进行管理*/private FragmentManager fragmentManager; @Overrideprotected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); initViews(); fragmentManager = getFragmentManager(); // 第一次启动时选中第0个tab setTabSelection(0);} /*** 在这里获取到每个需要用到的控件的实例，并给它们设置好必要的点击事件。*/ private void initViews() { messageLayout = findViewById(R.id.message_layout); contactsLayout = findViewById(R.id.contacts_layout); newsLayout = findViewById(R.id.news_layout); settingLayout = findViewById(R.id.setting_layout); messageLayout.setOnClickListener(this); contactsLayout.setOnClickListener(this); newsLayout.setOnClickListener(this); settingLayout.setOnClickListener(this);} @Overridepublic void onClick(View v) { switch (v.getId()) { case R.id.message_layout: // 当点击了消息tab时，选中第1个tab setTabSelection(0); break; case R.id.contacts_layout: // 当点击了联系人tab时，选中第2个tab setTabSelection(1); break; case R.id.news_layout: // 当点击了动态tab时，选中第3个tab setTabSelection(2); break; case R.id.setting_layout: // 当点击了设置tab时，选中第4个tab setTabSelection(3); break; default: break;} } /*** 根据传入的index参数来设置选中的tab页。** @param index* 每个tab页对应的下标。0表示消息，1表示联系人，2表示动态，3表示设置。*/private void setTabSelection(int index) { // 每次选中之前先清楚掉上次的选中状态 clearSelection(); // 开启一个Fragment事务 FragmentTransaction transaction = fragmentManager.beginTransaction(); // 先隐藏掉所有的Fragment，以防止有多个Fragment显示在界面上的情况 hideFragments(transaction); switch (index) { case 0: messageLayout.setBackgroundColor(0xff0000ff); if (messageFragment == null) { // 如果MessageFragment为空，则创建一个并添加到界面上 messageFragment = new MessageFragment(); transaction.add(R.id.content, messageFragment); } else { // 如果MessageFragment不为空，则直接将它显示出来 transaction.show(messageFragment); } break; case 1: // 当点击了联系人tab时，改变控件的图片和文字颜色 contactsLayout.setBackgroundColor(0xff0000ff); if (contactsFragment == null) { // 如果ContactsFragment为空，则创建一个并添加到界面上 contactsFragment = new ContactsFragment(); transaction.add(R.id.content, contactsFragment); } else { // 如果ContactsFragment不为空，则直接将它显示出来 transaction.show(contactsFragment); } break; case 2: // 当点击了动态tab时，改变控件的图片和文字颜色 newsLayout.setBackgroundColor(0xff0000ff); if (newsFragment == null) { // 如果NewsFragment为空，则创建一个并添加到界面上 newsFragment = new NewsFragment(); transaction.add(R.id.content, newsFragment); } else { // 如果NewsFragment不为空，则直接将它显示出来 transaction.show(newsFragment); } break; case 3: default: // 当点击了设置tab时，改变控件的图片和文字颜色 settingLayout.setBackgroundColor(0xff0000ff); if (settingFragment == null) { // 如果SettingFragment为空，则创建一个并添加到界面上 settingFragment = new SettingFragment(); transaction.add(R.id.content, settingFragment); } else { // 如果SettingFragment不为空，则直接将它显示出来 transaction.show(settingFragment); } break; } transaction.commit();} /*** 将所有的Fragment都置为隐藏状态。** @param transaction* 用于对Fragment执行操作的事务*/private void hideFragments(FragmentTransaction transaction) { if (messageFragment != null) { transaction.hide(messageFragment); } if (contactsFragment != null) { transaction.hide(contactsFragment); } if (newsFragment != null) { transaction.hide(newsFragment); } if (settingFragment != null) { transaction.hide(settingFragment); }} /*** 清除掉所有的选中状态。*/private void clearSelection() { messageLayout.setBackgroundColor(0xffffffff); contactsLayout.setBackgroundColor(0xffffffff); newsLayout.setBackgroundColor(0xffffffff); settingLayout.setBackgroundColor(0xffffffff); }} 参考：https://www.jb51.net/article/138944.htm document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Android","slug":"Android","permalink":"http://blog.iwxyi.com/tags/Android/"}]},{"title":"睡眠排序法Java版","date":"2018-10-16T05:28:00.000Z","path":"2018/10/16/睡眠排序法Java版/","text":"基本思想：根据CPU的调度算法实现，对一组数据进行排序，不能存在负数值。 这个数是多大，那么就在线程里睡眠它的10倍再加10。 不是睡眠和它的数值一样大的原因是，当数值太小时，误差太大，睡眠的时间不比输出的时间少，那么就会存在不正确的输出结果。 1234567891011121314151617181920212223242526272829303132public class SleepSort { public static void main(String[] args) { int[] arr = {1,4,7,3,8,9,2,6,5}; //创建指定长度的线程数组 SortThread[] sortThreads = new SortThread[arr.length]; //指定每个线程数组的值 for (int i = 0; i &lt; sortThreads.length; i++) { sortThreads[i] = new SortThread(arr[i]); } //开启每个线程 for (int i = 0; i &lt; sortThreads.length; i++) { sortThreads[i].start(); } }}class SortThread extends Thread{ int s = 0; public SortThread(int s){ this.s = s; } public void run(){ try { sleep(s*10+10); //睡眠指定的时间 } catch (InterruptedException e) { e.printStackTrace(); } //输出该数 System.out.println(s); }} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Java","slug":"Java","permalink":"http://blog.iwxyi.com/tags/Java/"},{"name":"算法","slug":"算法","permalink":"http://blog.iwxyi.com/tags/算法/"}]},{"title":"Android CardView用法","date":"2018-10-14T02:38:00.000Z","path":"2018/10/14/Android-CardView用法/","text":"今天主要是CardView的用法，CardView是在安卓5.0提出的卡片式控件。首先介绍一下它的配置。在gradle文件下添加依赖库： compile ‘com.android.support:cardview-v7:22.2.1’ 新版建议吧compile改成implementation，注意版本也要改 import android.support.v7.widget.CardView; 其次介绍一下它的基本属性： app:cardBackgroundColor这是设置背景颜色 app:cardCornerRadius这是设置圆角大小 app:cardElevation这是设置z轴的阴影 app:cardMaxElevation这是设置z轴的最大高度值 app:cardUseCompatPadding是否使用CompatPadding app:cardPreventCornerOverlap是否使用PreventCornerOverlap app:contentPadding 设置内容的padding app:contentPaddingLeft 设置内容的左padding app:contentPaddingTop 设置内容的上padding app:contentPaddingRight 设置内容的右padding app:contentPaddingBottom 设置内容的底padding CardView是在布局中使用的： 12345678910111213141516171819202122232425262728&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;FrameLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" android:layout_marginBottom=\"10dp\" android:background=\"@color/gray\"&gt; &lt;android.support.v7.widget.CardView android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:layout_marginLeft=\"10dp\" android:layout_marginRight=\"10dp\" app:cardBackgroundColor=\"@color/blue\" app:cardCornerRadius=\"16dp\" app:cardElevation=\"16dp\"&gt; &lt;TextView android:id=\"@+id/id_num\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_gravity=\"center\" android:layout_margin=\"10dp\" android:gravity=\"center\" android:textColor=\"@color/white\" android:textSize=\"20sp\" /&gt; &lt;/android.support.v7.widget.CardView&gt;&lt;/FrameLayout&gt; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Android","slug":"Android","permalink":"http://blog.iwxyi.com/tags/Android/"}]},{"title":"Ubuntu安装Apache2和PHP","date":"2018-10-11T06:04:00.000Z","path":"2018/10/11/Ubuntu安装Apache2和PHP/","text":"安装Apache2和PHP：安装 Apache2： 1sudo apt-get install apache2 安装PHP模块： 1sudo apt-get install php5 安装Mysql 1sudo apt-get install mysql-server 其他模块安装： 1234sudo apt-get install libapache2-mod-php5sudo apt-get install libapache2-mod-auth-mysqlsudo apt-get install php5-mysqlsudo apt-get install php5-gd 前两个很容易明白，要想apache能够解析PHP，就需要借助这两个模块来找到php engine。第三个在php操作mysql数据库时用到，大多数人都有数据库编程经验，所以这就不用多解释了。第四个GD库。 1.apache根目录 安装完apache2，根目录在/var/www下，可以通过http://localhost/测试一下是否好用。当然也可以在该目录下新建一个文件test.html来试一试http://localhost/test.html。 （好像是在/var/www/html/诶） 2.改变apache2的默认目录到当前的开发目录 apache2的默认目录配置在/etc/apache2/sites-enabled/00default文件中。 找到该文件中的DocumentRoot项，将/var/www改为你的开发目录就OK了。 当然，还有一种方法就是不改变默认目录，只是在var/www下建立一个到你的目录的链接。比如你的目录在/home/username/phptest，那么你只要 1sudo ln -s/home/username/phptest /var/www/phptest 这样你就可以通过http://localhost/phptest访问你的工作目录了。 3、配置中常用命令 重启apache 1sudo /etc/init.d/apache2 restart 错误Apache2启动失败在安装完成后就会显示这错误。 1sudo vim /etc/apache2/apache2.conf 最后加入一句: ServerName localhost:80 找不到PHP7.0Couldn't find any package by regex 'php-7.0' 更新包源： 123sudo apt-add-repository ppa:ondrej/phpsudo apt-get updatesudo apt-get install php7.0 端口被占用Address already in use: AH00072: make_sock: could not bind to address 0.0.0.0:80 用netstat -nlp |grep :80命令看看有什么进程占用了80端口 例如Nginx，用pkill -9 nginx杀死进程 再次启动Apache 启动失败Segmentation fault ``Action ‘start’ failed.` 是因为装了多个PHP……彻底卸载PHP，重装即可。 其他教程搭建sudo apt-get install apache2sudo apt-get install php7.0php -v 查看PHP是否安装成功sudo apt-get install libapache2-mod-php7.0cd /var/www/html 切换到apache项目目录下， 新建文件：sudo vim test.php//vim显示行号：：set nusudo apt-get install mysql-server mysql-client//mysql设置密码 用户名root//mysql -V 查看安装的版本信息安装php的mysql插件：sudo apt-get install php7.0-mysql安装一些常用的php扩展；sudo apt-get install php7.0-gd php7.0-mbstring php7.0-xml安装composer：sudo apt-get install composer 博客来源：https://blog.csdn.net/u010071211/article/details/79511928 彻底卸载PHP7一、删除php的相关包及配置 1sudo apt-get autoremove php7* 二、删除关联 1sudo find /etc -name \"*php*\" |xargs rm -rf 三、清除dept列表 1sudo apt purge `dpkg -l | grep php| awk '{print $2}' |tr \"\\n\" \" \"` 四、检查是否卸载干净（无返回就是卸载完成） 1dpkg -l | grep php7.0 移动上传的文件失败move_upload_file 权限问题 /tmp的权限是drwxrwxrwx，而我的/var/www/html 权限为drwxr-xr-x 修改所在文件夹的权限： 1chmod -R 777 /home document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Linux","slug":"Linux","permalink":"http://blog.iwxyi.com/tags/Linux/"}]},{"title":"Android DrawerLayout用法","date":"2018-10-07T02:41:00.000Z","path":"2018/10/07/Android-DrawerLayout用法/","text":"布局NavigationView：在Material Design中，Navigation drawer导航抽屉，被设计用于应用导航，提供了一种通用的导航方式，体现了设计的一致性。而NavigationView的典型用途就是配合之前v4包的DrawerLayout，作为其中的Drawer部分，即导航菜单的本体部分。NavigationView是一个导航菜单框架，使用menu资源填充数据，使我们可以更简单高效的实现导航菜单。它提供了不错的默认样式、选中项高亮、分组单选、分组子标题、以及可选的Header。 123456789101112131415161718192021222324&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;android.support.v4.widget.DrawerLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" android:id=\"@+id/drawer_layout\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;FrameLayout android:id=\"@+id/content\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt;&lt;/FrameLayout&gt; &lt;android.support.design.widget.NavigationView android:id=\"@+id/nav_view\" android:layout_width=\"150dp\" android:layout_height=\"match_parent\" android:layout_gravity=\"start\" android:background=\"#303030\" app:headerLayout=\"@layout/nav_header\" app:itemIconTint=\"@color/white\" app:itemTextColor=\"@color/white\" app:menu=\"@menu/nav_menu\" /&gt;&lt;/android.support.v4.widget.DrawerLayout&gt; 注意其中NavigationView的两个自定义属性app:headerLayout接收一个layout，作为导航菜单顶部的Header，可选项。app:menu接收一个menu，作为导航菜单的菜单项，几乎是必选项，不然这个控件就失去意义了。但也可以在运行时动态改变menu属性。用于NavigationView的典型menu文件，应该是一个可选中菜单项的集合。其中checked=”true”的item将会高亮显示，这可以确保用户知道当前选中的菜单项是哪个。item的选中状态可以在代码中设置，代码如下 nav_menu.xml123456789101112131415161718192021222324252627&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;menu xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;group android:id=\"@+id/g1\" android:checkableBehavior=\"single\"&gt; &lt;item android:id=\"@+id/nav_queue\" android:checkable=\"true\" android:icon=\"@mipmap/queue\" android:title=\"排队\" /&gt; &lt;item android:id=\"@+id/nav_count\" android:checkable=\"true\" android:icon=\"@mipmap/count\" android:title=\"统计\" /&gt; &lt;item android:id=\"@+id/nav_tv\" android:checkable=\"true\" android:icon=\"@mipmap/tv\" android:title=\"TV设置\" /&gt; &lt;item android:id=\"@+id/nav_more\" android:checkable=\"true\" android:icon=\"@mipmap/more\" android:title=\"更多\" /&gt; &lt;/group&gt;&lt;/menu&gt; FragmentActivity.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112public class HomeActivity extends FragmentActivity implements NavigationView .OnNavigationItemSelectedListener { // @InjectView(R.id.nav_view) public static NavigationView navView; // @InjectView(R.id.drawer_layout) public static DrawerLayout drawerLayout; private QueueFragment queueFragment; private MoreFragment moreFragment; private CountFragment countFragment; private TVFragment tvFragment; private FragmentManager fm; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate( savedInstanceState ); setContentView( R.layout.activity_home ); navView = (NavigationView) findViewById( R.id.nav_view ); drawerLayout = (DrawerLayout) findViewById( R.id.drawer_layout );// ButterKnife.inject( this ); init(); } /*** * 初始化，默认选中排队选项 */ public void init() { fm = getSupportFragmentManager(); queueFragment = new QueueFragment(); FragmentTransaction ft = fm.beginTransaction(); ft.add( R.id.content, queueFragment, \"queue\" ).commit(); // 别忘了 commit navView.setNavigationItemSelectedListener( this ); } /** * 打开侧滑栏 *这个方法是在其他类里面调用，点击某个按钮可以调出侧滑栏 */ public static void showDrawerLayout() { if (!HomeActivity.drawerLayout.isDrawerOpen( HomeActivity.navView )) { HomeActivity.drawerLayout.openDrawer( HomeActivity.navView ); } } /** * 侧滑栏点击 */ @Override public boolean onNavigationItemSelected(@NonNull MenuItem item) { FragmentTransaction ft = fm.beginTransaction(); hideFragment( ft ); switch (item.getItemId()) { case R.id.nav_queue://排队单击事件 if (queueFragment == null) { queueFragment = new QueueFragment(); ft.add( R.id.content, queueFragment, \"queue\" ); } else { ft.show( queueFragment ); } break; case R.id.nav_count://统计单击事件 if (countFragment == null) { countFragment = new CountFragment(); ft.add( R.id.content, countFragment, \"count\" ); } else { ft.show( countFragment ); } break; case R.id.nav_tv://TV设置单机时间 if (tvFragment == null) { tvFragment = new TVFragment(); ft.add( R.id.content, tvFragment, \"tv\" ); } else { ft.show( tvFragment ); } break; case R.id.nav_more://更多点击事件 if (moreFragment == null) { moreFragment = new MoreFragment(); ft.add( R.id.content, moreFragment, \"more\" ); } else { ft.show( moreFragment ); } break; } ft.commit(); // 别忘了这里，不然是不会有效果的 drawerLayout.closeDrawers(); return true; } /*** * 隐藏fragment */ public void hideFragment(FragmentTransaction ft) { if (queueFragment != null) { ft.hide( queueFragment ); } if (moreFragment != null) { ft.hide( moreFragment ); } if (countFragment != null) { ft.hide( countFragment ); } if (tvFragment != null) { ft.hide( tvFragment ); } }} 这是其中一个子Fragment的例子，其余的都一样 1234567891011121314151617181920212223242526package com.mxt.net.protect.UI.fragment;import android.os.Bundle;import android.support.annotation.Nullable;import android.support.v4.app.Fragment;import android.view.LayoutInflater;import android.view.View;import android.view.ViewGroup;import com.mxt.net.protect.R;/** * Created by Spencer on 2017/3/11. */public class TVFragment extends Fragment { private View view; @Nullable @Override public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container, Bundle savedInstanceState) { view = inflater.inflate(R.layout.tv_fragment, container, false); return view; }} 参考：https://blog.csdn.net/u010068253/article/details/70155261 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Android","slug":"Android","permalink":"http://blog.iwxyi.com/tags/Android/"}]},{"title":"修电脑","date":"2018-09-24T12:39:00.000Z","path":"2018/09/24/修电脑/","text":"WIN无操作自动休眠这是系统无人值守时睡眠时间的设定，默认是两分钟。 解决方法： regedit进入注册表管理器，定位到HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Power\\PowerSettings\\238C9FA8-0AAD-41ED-83F4-97BE242C8F20\\7bc4a2f9-d8fc-4469-b07b-33eb785aaca0，修改attributes的值为2。 进入高级电源设置，在睡眠选项中会出现“无人参与系统睡眠超时”，将默认的2分钟修改成你想要的时间。 开关操作中心regedit进入注册表编辑器，计算机\\HKEY_CURRENT_USER\\Software\\Policies\\Microsoft\\Windows\\Explorer新建项DisableNotificationCenter，值为1时关闭操作中心。重启电脑生效。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Windows","slug":"Windows","permalink":"http://blog.iwxyi.com/tags/Windows/"}]},{"title":"Android RecyclerView添加点击事件","date":"2018-09-22T02:53:00.000Z","path":"2018/09/22/Android-RecyclerView添加点击事件/","text":"使用 Recyclerview 时，如果要添加 item 的点击监听等功能，可以在 Recyclerview.Adapter 的 onBindViewHolder 中设置 123456holder.tv.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { int pos=holder.getLayoutPosition(); } } 注意需要把 onBindViewHolder 中的 holder 参数改成 filnal 类型 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Android","slug":"Android","permalink":"http://blog.iwxyi.com/tags/Android/"}]},{"title":"Android点击图片显示像素颜色值","date":"2018-09-16T03:07:00.000Z","path":"2018/09/16/Android点击图片显示像素颜色值/","text":"包含知识点： 选择图片（相册+拍照） 正方形裁剪 图片压缩 图片点击 12345678910111213141516171819202122232425&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:tools=\"http://schemas.android.com/tools\" android:id=\"@+id/ll\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:gravity=\"center\" android:orientation=\"vertical\" &gt; &lt;Button android:id=\"@+id/btnColor\" android:layout_width=\"fill_parent\" android:layout_height=\"wrap_content\" android:layout_gravity=\"top\" android:text=\"获取图片\" /&gt; &lt;ImageView android:id=\"@+id/iv_image\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:gravity=\"center\" android:scaleType=\"fitCenter\" /&gt;&lt;/LinearLayout&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188package com.wxy.treecalc;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import android.app.Activity;import android.content.Intent;import android.graphics.Bitmap;import android.graphics.BitmapFactory;import android.graphics.Color;import android.net.Uri;import android.os.Bundle;import android.provider.MediaStore;import android.support.v7.app.AppCompatActivity;import android.util.Log;import android.view.MotionEvent;import android.view.View;import android.view.View.OnClickListener;import android.view.View.OnTouchListener;import android.widget.Button;import android.widget.ImageView;import android.widget.TextView;public class MainActivity extends AppCompatActivity { private TextView tv_rgb; private ImageView iv_image; private Bitmap bitmap; private String TAG = \"RGBActivity\"; private Button btnColor; public static final int NONE = 0; public static final int PHOTOHRAPH = 1;// 拍照 public static final int PHOTOZOOM = 2; // 缩放 public static final int PHOTORESOULT = 3;// 结果 public static final String IMAGE_UNSPECIFIED = \"image/*\"; public static final String TEMP_JPG_NAME = \"temp.jpg\"; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); tv_rgb = (TextView) findViewById(R.id.textview); btnColor = (Button) findViewById(R.id.btnColor); iv_image = (ImageView) findViewById(R.id.iv_image); btnColor.setOnClickListener(new OnClickListener() { @Override public void onClick(View v) { openAlbum(); } }); iv_image.setOnTouchListener(new OnTouchListener() { @Override public boolean onTouch(View v, MotionEvent event) { int x = (int) event.getX(); int y = (int) event.getY(); if (event.getAction() == MotionEvent.ACTION_UP) { int color = bitmap.getPixel(x, y); // 如果你想做的更细致的话 可以把颜色值的R G B 拿到做响应的处理 int r = Color.red(color); int g = Color.green(color); int b = Color.blue(color); int a = Color.alpha(color); Log.i(TAG, \"r=\" + r + \",g=\" + g + \",b=\" + b); tv_rgb.setText(\"a=\" + a + \",r=\" + r + \",g=\" + g + \",b=\" + b); btnColor.setTextColor(Color.rgb(r, g, b)); } return true; } }); } // 打开相册 private void openAlbum() { Intent intent = new Intent(Intent.ACTION_PICK, null); intent.setDataAndType(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, \"image/*\"); startActivityForResult(intent, PHOTOZOOM); } @Override protected void onActivityResult(int requestCode, int resultCode, Intent data) { try { if (resultCode == NONE) return; if (data == null) return; // 读取相册缩放图片 if (requestCode == PHOTOZOOM) { if (data != null) { startPhotoZoom(data.getData()); } } // 处理结果 if (requestCode == PHOTORESOULT) { Bundle extras = data.getExtras(); if (extras != null) { bitmap = extras.getParcelable(\"data\"); //ByteArrayOutputStream stream = new ByteArrayOutputStream(); comp(bitmap); //bitmap.compress(Bitmap.CompressFormat.JPEG, 100, stream); iv_image.setImageBitmap(bitmap); /* logoName = FileUtils.getFilename(MainAppUtil.getCustom().getSusername()); FileUtils.writeFile(Constants.LOGO_CACHE_PATH, logoName, photo);*/ } } super.onActivityResult(requestCode, resultCode, data); } catch (Exception e) { e.printStackTrace(); } } private Bitmap compressImage(Bitmap image) { ByteArrayOutputStream baos = new ByteArrayOutputStream(); image.compress(Bitmap.CompressFormat.JPEG, 100, baos);//质量压缩方法，这里100表示不压缩，把压缩后的数据存放到baos中 int options = 100; while (baos.toByteArray().length / 1024 &gt; 100) { //循环判断如果压缩后图片是否大于100kb,大于继续压缩 baos.reset();//重置baos即清空baos image.compress(Bitmap.CompressFormat.JPEG, options, baos);//这里压缩options%，把压缩后的数据存放到baos中 options -= 10;//每次都减少10 } ByteArrayInputStream isBm = new ByteArrayInputStream(baos.toByteArray());//把压缩后的数据baos存放到ByteArrayInputStream中 Bitmap bitmap = BitmapFactory.decodeStream(isBm, null, null);//把ByteArrayInputStream数据生成图片 return bitmap; } private Bitmap comp(Bitmap image) { ByteArrayOutputStream baos = new ByteArrayOutputStream(); image.compress(Bitmap.CompressFormat.JPEG, 100, baos); if (baos.toByteArray().length / 1024 &gt; 1024) { //判断如果图片大于1M,进行压缩避免在生成图片（BitmapFactory.decodeStream）时溢出 baos.reset();//重置baos即清空baos image.compress(Bitmap.CompressFormat.JPEG, 50, baos); //这里压缩50%，把压缩后的数据存放到baos中 } ByteArrayInputStream isBm = new ByteArrayInputStream(baos.toByteArray()); BitmapFactory.Options newOpts = new BitmapFactory.Options(); //开始读入图片，此时把options.inJustDecodeBounds 设回true了 newOpts.inJustDecodeBounds = true; Bitmap bitmap = BitmapFactory.decodeStream(isBm, null, newOpts); newOpts.inJustDecodeBounds = false; int w = newOpts.outWidth; int h = newOpts.outHeight; //现在主流手机比较多是800*500分辨率，所以高和宽我们设置为 float hh = 800f;//这里设置高度为800f float ww = 500f;//这里设置宽度为500f //缩放比。由于是固定比例缩放，只用高或者宽其中一个数据进行计算即可 int be = 1;//be=1表示不缩放 if (w &gt; h &amp;&amp; w &gt; ww) {//如果宽度大的话根据宽度固定大小缩放 be = (int) (newOpts.outWidth / ww); } else if (w &lt; h &amp;&amp; h &gt; hh) {//如果高度高的话根据宽度固定大小缩放 be = (int) (newOpts.outHeight / hh); } if (be &lt;= 0) be = 1; newOpts.inSampleSize = be;//设置缩放比例 //重新读入图片，注意此时已经把options.inJustDecodeBounds 设回false了 isBm = new ByteArrayInputStream(baos.toByteArray()); bitmap = BitmapFactory.decodeStream(isBm, null, newOpts); return compressImage(bitmap);//压缩好比例大小后再进行质量压缩 } private void startPhotoZoom(Uri uri) { Intent intent = new Intent(\"com.android.camera.action.CROP\"); intent.setDataAndType(uri, IMAGE_UNSPECIFIED); intent.putExtra(\"crop\", \"true\"); // aspectX aspectY 是宽高的比例 intent.putExtra(\"aspectX\", 1); intent.putExtra(\"aspectY\", 1); // outputX outputY 是裁剪图片宽高 intent.putExtra(\"outputX\", 300); intent.putExtra(\"outputY\", 300); intent.putExtra(\"return-data\", true); startActivityForResult(intent, PHOTORESOULT); }} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Android","slug":"Android","permalink":"http://blog.iwxyi.com/tags/Android/"}]},{"title":"Android读取图片颜色值","date":"2018-09-15T03:12:00.000Z","path":"2018/09/15/Android读取图片颜色值/","text":"Android SDK中提供了Bitmap图片每个像素颜色读取的方法： 123456789Bitmap src = BitmapFactory.decodeResource(getResources(),R.drawable.imgbg);int height = src.getHeight();int width = src.getWidth();for (int y = 0; y &lt; height; y++) { for (int x = 0; x &lt; width; x++) { int pixelColor = src.getPixel(x, y); // 颜色值 int A = Color.alpha(pixelColor); // A R G B }} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Android","slug":"Android","permalink":"http://blog.iwxyi.com/tags/Android/"}]},{"title":"Android自定义控件之QQ红点","date":"2018-09-11T03:34:00.000Z","path":"2018/09/11/Android自定义控件之QQ红点/","text":"# 拖拽效果 拖拽效果的实现其实是用贝塞尔曲线去构成的，这里上一张图就很明白 可以看到，所谓的拖拽效果只是在两个圆圈之间根据两个圆同侧切点和圆心连线中点三个点构建一条二阶贝塞尔曲线，另一侧也是，将其用颜色填充，就构成了qq红点的拖拽效果，是不是很简单 那么我们这里的目标就是先算出p0，p1,Q0三个点的坐标 代码12345678910111213141516171819202122232425float endX = nowFingerPoint.x;float endY = nowFingerPoint.y;float dx = endX - startX;float dy = endY - startY; float distance = (float) Math.sqrt(Math.pow(endY-startY, 2) + Math.pow(endX-startX, 2));radius = 50 - distance/15;radius = radius&lt;20 ? 20 : radius; double a = Math.atan(dy / dx);float offsetX = (float) (radius * Math.sin(a));float offsetY = (float) (radius * Math.cos(a)); // 根据角度算出四边形的四个点float x1 = startX - offsetX;float y1 = startY + offsetY; float x2 = endX - offsetX;float y2 = endY + offsetY; float x3 = endX + offsetX;float y3 = endY - offsetY; float x4 = startX + offsetX;float y4 = startY - offsetY; 然后要做的就是画两个圆点，以及把这四个点连起来构成贝塞尔曲线 1234567891011float anchorX = (startX + endX) / 2;float anchorY = (startY + endY) / 2; path.reset(); path.reset();path.moveTo(x1, y1);path.quadTo(anchorX, anchorY, x2, y2);path.lineTo(x3, y3);path.quadTo(anchorX, anchorY, x4, y4);path.lineTo(x1, y1); 画圆点，响应移动事件这些就不写了，我直接贴源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118public class QQ_message_drag_effect extends View { public QQ_message_drag_effect(Context context) { super(context); } public QQ_message_drag_effect(Context context, @Nullable AttributeSet attrs) { super(context, attrs); } public QQ_message_drag_effect(Context context, @Nullable AttributeSet attrs, int defStyleAttr) { super(context, attrs, defStyleAttr); } int width; int height; @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) { super.onMeasure(widthMeasureSpec, heightMeasureSpec); setMeasuredDimension(width = ((ViewGroup)getParent()).getMeasuredWidth(),height = ((ViewGroup)getParent()).getMeasuredHeight()); } float radius = 50; PointF startPoint = new PointF(300,500); PointF nowFingerPoint = new PointF(); boolean isMoveing = false; Paint paint = new Paint(); Path path = new Path(); @Override public boolean onTouchEvent(MotionEvent event) { int x = (int) event.getX(); int y = (int) event.getY(); switch (event.getAction()){ case MotionEvent.ACTION_DOWN: if((x &lt; startPoint.x + radius &amp;&amp; x &gt; startPoint.x - radius) &amp;&amp; (y &lt; startPoint.y + radius &amp;&amp; y &gt; startPoint.y - radius)){ isMoveing = true; } break; case MotionEvent.ACTION_MOVE: if(isMoveing){ nowFingerPoint.y = y; nowFingerPoint.x = x; invalidate(); } break; case MotionEvent.ACTION_UP: isMoveing = false; radius = 50; invalidate(); break; } return true; } @Override protected void onDraw(Canvas canvas) { super.onDraw(canvas); float startX = startPoint.x; float startY = startPoint.y; paint.setColor(Color.RED); canvas.drawCircle(startX,startY,radius,paint); if(isMoveing){ float endX = nowFingerPoint.x; float endY = nowFingerPoint.y; float dx = endX - startX; float dy = endY - startY; float distance = (float) Math.sqrt(Math.pow(endY-startY, 2) + Math.pow(endX-startX, 2)); radius = 50 - distance/15; radius = radius&lt;20 ? 20 : radius; double a = Math.atan(dy / dx); float offsetX = (float) (radius * Math.sin(a)); float offsetY = (float) (radius * Math.cos(a)); // 根据角度算出四边形的四个点 float x1 = startX - offsetX; float y1 = startY + offsetY; float x2 = endX - offsetX; float y2 = endY + offsetY; float x3 = endX + offsetX; float y3 = endY - offsetY; float x4 = startX + offsetX; float y4 = startY - offsetY; float anchorX = (startX + endX) / 2; float anchorY = (startY + endY) / 2; path.reset(); path.reset(); path.moveTo(x1, y1); path.quadTo(anchorX, anchorY, x2, y2); path.lineTo(x3, y3); path.quadTo(anchorX, anchorY, x4, y4); path.lineTo(x1, y1); canvas.drawPath(path,paint); canvas.drawCircle(endX,endY,radius,paint); } }} 参考：https://blog.csdn.net/asffghfgfghfg1556/article/details/80409902 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Android","slug":"Android","permalink":"http://blog.iwxyi.com/tags/Android/"}]},{"title":"Bat常用脚本命令","date":"2018-09-01T12:40:00.000Z","path":"2018/09/01/Bat常用脚本命令/","text":"run.bat—打开百度 12path=%path%; C:\\Program Files (x86)\\Internet Explorer\\start iexplore http://www.baidu.com 将c盘下所有文件名输出到a.txt中，如果没有a文件，则在bat同一目录下创建一个 1dir c:\\*.* &gt;a.txt 执行另一个批处理文件 1call c:\\code\\run.bat echo回显 1234@echo off 表示在此语句后所有运行的命令都不显示命令行本身 cd code 进入code文件夹echo enter code directory 显示enter code directorycall run.bat 增加入参 123@echo off type %1 type %2 cmd为 run.bat a.txt b.txt控制台会显示出a和b的文件内容 for循环的使用 123bat脚本@echo offfor %%t in (*.bat *.txt) do type %%t 注意1，打印的是bat和txt文件的内容注意2，此bat放在需打印文件内容的文件一个目录层级下 12@echo offFOR /L %%i in (1,2,20) DO echo %%i if/else判断语句的使用 1234567bat脚本@echo offif {%1}=={%2} (echo eq l.) else (echo not eq l.) cmd输入run.bat 1 2结果为 not eq 1 在一个批处理文件内最多可以使用10个替换参数(%0到%9) 1234567@echo offif exist a.txt ( echo This is a.txt type a.txt)else ( echo a.txt missing.) 判断当前目录下是否有a.txt 12345@ECHO OFFIF EXIST D:\\*.XLS () else (GOTO fail)PAUSE :failECHO 没找到文件 删除文件 12@echo offdel a.txt 12&gt; 注意：指定路径会删除该路径下所有文件&gt; 移动、拷贝文件、文件夹 123456@echo offmove c:\\a.txt c:\\code\\a.txt copy c:\\code\\a.txt c:\\a.txt rd c:\\code\\abc\\abc REM 删除非空文件夹 GOTO语句 123456@ECHO OFFGOTO SECOND:FIRSTecho I AM FIRST:SECONDecho I AM SECOND choice/errorlevel的用法 12345678910111213141516@echo off choice /C 123 /M \"RUN1,RUN2,RUN3\"if errorlevel 3 goto RUN3if errorlevel 2 goto RUN2 if errorlevel 1 goto RUN1 :RUN1 c:\\code\\RUN1 goto RUN3 :RUN2c:\\code\\RUN2goto RUN3 :RUN3echo good bye set 123456789@echo offset a=aa1bb1aa2bb2echo %a%set b=12echo %b%set /a c=39/10 echo %c% 1234567@echo offset p=aaaif %p%==aaa ( echo %p% set p=bbb echo %p% ) 输出 aaa aaa 1234567@echo offset p=aaaif %p%==aaa ( echo %p% set /p p=bbb echo %p% ) 输出 aaa bbb 123echo %CD% #代表当前目录的字符串echo %DATE% #当前日期echo %TIME% #当前时间 从FTP下载文件 12345678910111213@echo open 10.86.56.6 &gt;ftp.txt rem ftp server ip@echo user mos&gt;&gt;ftp.txt rem 用户名@echo mos&gt;&gt;ftp.txt rem 密码@echo cd test&gt;&gt;ftp.txt rem 文件路径@echo get mw-license-switch-conffile.xml&gt;&gt;ftp.txt rem 文件名@echo bye&gt;&gt;ftp.txtftp -i -n -s:ftp.txt rem 文件存放在脚本所在路径下 切换盘符 123set current_dir=C:\\Program Files\\HaoZip pushd %current_dir% echo %cd% 博客来源：https://www.cnblogs.com/laislabonita/p/7145731.html document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Bat","slug":"Bat","permalink":"http://blog.iwxyi.com/tags/Bat/"}]},{"title":"搭建FFM","date":"2018-08-30T05:48:00.000Z","path":"2018/08/30/搭建FFM/","text":"FFM 说明实现无需qq后台，直接借助服务器接收消息通过谷歌云端推送FCM推送到安卓手机，需要科学上网(除非你在国外)和谷歌服务框架，节省手机电量，顺便支持Android 7.0+的通知栏回复。 现在 Web QQ 已经挂掉了，此应用从此失效 一键脚本打基础，cpanm、Mojo-Webqq 这些就不用再装了，直接从下面的第三步开始。不过可能会出问题，最好还是按照下面的步骤来一遍。 再安装一下依赖，直接启动。 12yum install git -ygit clone https://github.com/null-ecp/FFM-one-step.git &amp;&amp; source ~/FFM-one-step/GCM.sh 分步安装1.安装Cpanm1curl -kL https://cpanmin.us | perl - App::cpanminus 2.安装Mojo-Webqq1cpanm Mojo::Webqq 部分centos在这一步会报错，重新执行cpanm Mojo::Webqq即可 3.安装Webqq::Encryption先安装依赖:1yum install -y perl-Crypt-OpenSSL-RSA perl-Crypt-OpenSSL-Bignum 继续安装模块1cpanm Webqq::Encryption 如果 失败则再次安装一遍依赖 4.安装FCM For Mojo安装git包管理器1yum install -y git 安装node.js12curl -sL https://rpm.nodesource.com/setup_9.x | bash -yum -y install nodejs 随后依次执行以下命令1234git clone https://github.com/RikkaApps/FCM-for-Mojo-Server.gitcd FCM-for-Mojo-Servercp config.example.js config.jsnpm install 自此安装完成 后台运行 screen为了让程序在断开ssh后也能运行，可以安装screen 1yum install -y screen 新建screen1screen -S qq screen常用命令1234screen -S [name] //新建screenscreen -r [name] //切换到一个screenscreen -ls //列出所有的screenexit //关闭当前screen 可以使用Ctrl+a+d来将当前screen移至后台 启动FFM1npm start 关闭防火墙不管可能会 time out 1234//临时关闭systemctl stop firewalld//禁止开机启动systemctl disable firewalld VIM 用法 i 在前面编辑 a 在后面编辑 :wq 保存退出 :q 退出 修改HOSTS修改命令 1vi /etc/hosts 404问题 connect.qq.com/proxy.html 404 解决方法是 修改HOSTS改为： 1112.90.143.119 web2.qq.com 一键机器人1cpanm Mojo::Webqq &amp;&amp; perl -MMojo::Webqq -e \"Mojo::Webqq-&gt;new-&gt;load('ShowMsg')-&gt;load('SmartReply')-&gt;run()\" 不过现在好像用不了了？ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"服务器","slug":"服务器","permalink":"http://blog.iwxyi.com/tags/服务器/"}]},{"title":"IIS允许下载APK安装包","date":"2018-08-10T12:41:00.000Z","path":"2018/08/10/IIS允许下载APK安装包/","text":"IIS允许下载APK安装包（MIME类型配置）IIS7MIME配置过程： 打开IIS信息服务管理器，找到要添加配置的网站； 在该网站的功能视图中单击”MIME类型“按钮（如果在功能视图中没有MIME按钮，则需要通过服务器管理器中角色管理进行添加），打开MIME类型设置窗口； 在操作栏里点击”添加“按钮； 单机”确定“保存设置； 重启IIS，使设置生效。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"服务器","slug":"服务器","permalink":"http://blog.iwxyi.com/tags/服务器/"}]},{"title":"fread和fwrite转移文件数据","date":"2018-08-04T12:18:00.000Z","path":"2018/08/04/fread和fwrite转移文件数据/","text":"读取文件，再写入到另一个文件里面： 1、获取文件大小 12345FILE* fp_size = fopen(\"T:/img.jpg\", \"rb\");fseek(fp_size, 0, SEEK_END);int size = ftell(fp_size);fclose(fp_size);cout &lt;&lt; \"文件大小(指针偏移计算):\" &lt;&lt; size; // 字节大小 2、读取文件 1234FILE* fp_read = fopen(\"T:/img.jpg\", \"rb\");int* buffer = (int*)malloc(size+4); // 可以改成其他类型也没事，比如 char*fread(buffer, size, 1, fp_read);fclose(fp_read); 3、写入到另一个文件 123FILE* fp_write = fopen(\"T:/img1.png\", \"wb\");fwrite(buffer,size, 1, fp_write);fclose(fp_write); fread和write的size可以更大，不影响结果（表示上限） 实测一张jpg图片： size超过体积，保存的会是size的大小 1/10时：图片只有一半显示，体积也只有1/10 1/4时：上方5/6的部分清晰，剩下的模糊 1/2时：虽然体积只有一半，但是好像一样清晰…… document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"C","slug":"C","permalink":"http://blog.iwxyi.com/tags/C/"},{"name":"文件","slug":"文件","permalink":"http://blog.iwxyi.com/tags/文件/"}]},{"title":"HTML表格单元格悬浮提示","date":"2018-08-01T05:07:00.000Z","path":"2018/08/01/HTML表格单元格悬浮提示/","text":"1&lt;td title=\"点击了解详细信息\"&gt;&lt;a href=\"#\"&gt;要显示的文本&lt;/a&gt; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"HTML","slug":"HTML","permalink":"http://blog.iwxyi.com/tags/HTML/"}]},{"title":"Swing框架-学习笔记","date":"2018-07-09T05:26:00.000Z","path":"2018/07/09/Swing框架-学习笔记/","text":"绘图相关的类： JFrame JPanel 画到画板12345678910111213141516171819import javax.swing.JFrame;import java.awt.Color;import java.awt.Panel;public class A{ public static void main(String[] args) { // 创建容器 JFrame frame = new JFrame(); frame.setSize(200, 300); frame.setLocation(100, 100); frame.setVisible(true); // 创建画板 Panel panel = new Panel(); panel.setBackground(Color.YELLOW); // 添加容器到画板 frame.add(panel); }} 画板子类123456789101112131415161718192021222324252627282930313233import java.awt.Color;import java.awt.Graphics;import java.awt.Panel;import java.util.Random;public class M extends Panel { int x[], y[]; public M() { super(); // 初始化星星随机坐标 x = new int[300]; y = new int[300]; Random random = new Random(); for (int i = 0; i &lt; 300; i++) { x[i] = random.nextInt(1000); y[i] = random.nextInt(600); } } public void paint(Graphics g) { super.paint(g); this.setBackground(Color.black); // 画月亮 g.setColor(Color.white); g.fillArc(860, 100, 50, 50, 0, 360); // 画星星（文字） for (int i = 0; i &lt; 300; i++) { g.drawString(\"*\", x[i], y[i]); } }} 动态绘图main 123456M panel = new M();frame.add(panel);Thread t = new Thread(panel);panel.run(); // 开始多线程运行方法一//t.start(); // 开始多线程运行方法二 M 1234567891011121314151617181920public class M extends JPanel implements Runnable { /* ... */ public void run() { while (true) { for (int i = 0; i &lt; x.length; i++) { x[i]--; y[i]++; } try { // 定时（动态）操作 Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } // 重绘函数 repaint(); } }} 解决闪烁JPanel 自带双重缓冲。 动态绘图2构造函数： 1move(); // 直接调用 1234567891011121314151617181920public void move() { new Thread() { public void run() { /* ... 位置初始化 ... */ while (true) { /* ... 控件移动 ... */ repaint(); try { Thread.sleep(24); } catch (InterruptedException e) { e.printStackTrace(); } } } }.start();} 无边框frame.setUndecorated(true); 123456789101112public class Main { public static void main(String[] args) { JFrame frame = new JFrame(); BallPanel panel = new BallPanel(); frame.setBounds(100, 100, 1000, 600); // 代替setLocation和setSize frame.setBackground(Color.YELLOW); frame.setUndecorated(true); frame.add(panel); frame.setVisible(true); }} 实测setVisible必须在add和setUndecorated后面 设置图片Graphics.drawImage() 12345public void paint(Graphics g) { super.paint(g); g.drawImage(new ImageIcon(\"img/pic.jpg\").getImage(), 0, 0, this);} 鼠标拖动main 使用工具类 123456public class Main { public static void main(String[] args) { JFrame frame = new JFrame(); LocationUtil lUtil = new LocationUtil(frame); // 设置鼠标可拖动的工具类 }} util：LocationUtil 工具类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package Util;import java.awt.event.MouseEvent;import java.awt.event.MouseListener;import java.awt.event.MouseMotionListener;import javax.swing.JFrame;public class LocationUtil { JFrame frame; private int xx, yy; private boolean isDraging = false; public LocationUtil(JFrame f) { this.frame = f; // 鼠标按键事件 frame.addMouseListener(new MouseListener() { public void mouseReleased(MouseEvent e) { isDraging = false; } public void mousePressed(MouseEvent e) { isDraging = true; xx = e.getX(); yy = e.getY(); } public void mouseExited(MouseEvent e) { } public void mouseEntered(MouseEvent e) { } public void mouseClicked(MouseEvent e) { } }); // 鼠标移动事件 frame.addMouseMotionListener(new MouseMotionListener() { public void mouseMoved(MouseEvent e) { } public void mouseDragged(MouseEvent e) { if (isDraging == true) { int left = frame.getLocation().x; int top = frame.getLocation().y; frame.setLocation(left + e.getX() - xx, top + e.getY() - yy); } } }); }} 设置成屏幕大小123456Dimension screensize = new Dimension();screensize = tk.getScreenSize();width = screensize.getWidth();height = screensize.getHeight();jframe.setSize((int)width, (int)height);jframe.setLocation(0, 0); java语法单个变量形成数组数组引用的是单个变量的地址空间，所以是同一个 123456Student s1 = new Student();Student s2 = new Student();Student[] ss = new Student[] { s1, s2 };System.out.println(ss[1] == s2); // true 向上转型123456789101112131415private static void pout(Object o) { System.out.println(o.toString());}public static void main(String[] args) { Boolean b = new Boolean(false); pout(b); String s = new String(\"1431\"); pout(s); Integer i = new Integer(1000); pout(i);} 子类的创建、继承、覆盖 构造函数只能调用，不能继承 创建子类对象时在调用子类的构造器前，会调用父类的（无参）构造器 先对父类初始化，再对子类初始化 子类构造器中使用super([参数])来调用父类的构造器 如果父类只有有参构造器，则必须在子类构造函数第一行使用super([参数])来调用 类、字段、构造器不存在覆盖的概念 静态区优先于对象而创建，也不存在覆盖的概念（隐藏）。调用使用类名.方法，而非类示例.方法 遮蔽 三种情况 局部变量和成员变量同名，使用this 子类和父类存在同名成员变量，使用super调用父类成员变量 子类和父类存在相同静态方法，方法不存在覆盖 多态一个对象可以有多种形态 1. 父类指针指向子类对象 2. 把子类对象复制给父类的变量 3. 继承是多态的前提，没有继承就没有多态 多态的好处 - 把不同的子类对象都当做父类类型来看 - 可以屏蔽不同子类对象之间的差异 父类和子类同时存在静态方法时： - 直接调用静态方法（子类） - 父类名.静态方法静态方法不是覆盖，而属于隐藏 多态是对象的概念，和类没有关系 √ instanceof 判断是否是某个（父）类的实例 1if (a instanceof A) // true 123B extends A;if (b instanceof A) // true (其实还有其他更深的用法，例如 c instanceof C 有 true 也有 false) 封装1234567891011121314151617int i = 129;Integer I1 = new Integer(129);Integer I2 = new Integer(129);if (i == I1) // trueif (I1 == I2) // falseif (I1.equals(I2)) // trueInteger I3 = new Integer(127);Integer I4 = new Integer(127)if (I3 == I4) // true, 享元模式 当 &lt; 128 时，Integer对象都是共享的;当 &gt;=128 时，才真正分配对象 就是用一个Integer数组先缓存了，后面如果是在 [-128, 127] 区间内的数直接从缓存数组中取，否则才构造新的Integer。缓存思想还是很重要的。 控件常用函数JFrame123456setBounds(200, 50, 900, 700);setUndecorated(true); // 无边框setIconImage(new ImageIcon(\"\").getImage());add(panel);setVisible(true);setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE); JPanel1setBackground(Color.black); JButton12345678setBounds(100, 100, 200, 200);addActionListener(click);setActionCommand(\"close\");setBackground(Color.WHITE);setOpaque(false); // 透明setBorderPainted(false); // 无边框setContentAreaFilled(false); // 按下透明setIcon(new ImageIcon(\"\")); JLabel123456setLayout(null);setOpaque(false);setBounds(19, 70, 235, 57);setFont(new Font(\"宋体\", Font.BOLD, 20));setForeground(Color.white);add(label2) document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://blog.iwxyi.com/tags/学习笔记/"},{"name":"Swing","slug":"Swing","permalink":"http://blog.iwxyi.com/tags/Swing/"}]},{"title":"Python手动安装插件","date":"2018-07-08T05:40:00.000Z","path":"2018/07/08/Python手动安装插件/","text":"路径：C:\\Users\\Administrator\\AppData\\Local\\Programs\\Python\\Python35\\Scripts cmd 命令：pip install nltk（注：下载很慢很慢20kb/s） 更新：pip install --upgrade nltk 插件列表： pip install flake8 检测插件 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Python","slug":"Python","permalink":"http://blog.iwxyi.com/tags/Python/"}]},{"title":"CentOS安装可视化界面","date":"2018-07-07T05:59:00.000Z","path":"2018/07/07/CentOS安装可视化界面/","text":"在联网的情况下使用yum命令安装即可需要安装x window服务与desktop桌面，不分先后，命令如下： 12yum groupinstall \"GNOME Desktop\"yum groupinstall \"X Window System\" 最后启动输入命令 1startX 如果在本地使用即可正常切换，通过ssh登录则不能切换，会报错 可视化桌面卸载12yum groupremove 'MATE Desktop' -yyum groupremove 'X Window System' -y 找不到包1No packages in any requested group available to install or update 通过下面语句来看能安装的group，选择名字来安装 1yum grouplist 控制1yum install xrdp 然后使用windows自带的远程桌面控制 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Linux","slug":"Linux","permalink":"http://blog.iwxyi.com/tags/Linux/"}]},{"title":"C#-学习笔记","date":"2018-06-22T23:21:00.000Z","path":"2018/06/23/C-学习笔记/","text":"入门 需要C++基础 示例代码12345678910111213using System;namespace HelloWorldApplication{ class HelloWorld { static void Main(string[] args) { /* 我的第一个 C# 程序*/ Console.WriteLine(\"Hello World\"); Console.ReadKey(); } }} 上面程序的各个部分： 程序的第一行 using System; - using 关键字用于在程序中包含 System 命名空间。 一个程序一般有多个 using 语句。 下一行是 namespace 声明。一个 namespace 是一系列的类。HelloWorldApplication 命名空间包含了类 HelloWorld。 几个注意点： C# 是大小写敏感的。 所有的语句和表达式必须以分号（;）结尾。 程序的执行从 Main 方法开始。 与 Java 不同的是，文件名可以不同于类的名称。 基本语法数据类型：引用类型引用类型不包含存储在变量中的实际数据，但它们包含对变量的引用。换句话说，它们指的是一个内存位置。 内置的引用类型有：object、dynamic 和 string。 对象（Object）类型对象（Object）类型 是 C# 通用类型系统（Common Type System - CTS）中所有数据类型的终极基类。Object 是 System.Object 类的别名。所以对象（Object）类型可以被分配任何其他类型（值类型、引用类型、预定义类型或用户自定义类型）的值。但是，在分配值之前，需要先进行类型转换。 当一个值类型转换为对象类型时，则被称为 装箱；另一方面，当一个对象类型转换为值类型时，则被称为 拆箱。 12object obj;obj = 100; // 这是装箱 动态（Dynamic）类型存储任何类型的值在动态数据类型变量中。 1dynamic &lt;variable_name&gt; = value; 例如： 1dynamic d = 20; 动态类型与对象类型相似，但是对象类型变量的类型检查是在编译时发生的，而动态类型变量的类型检查是在运行时发生的。 字符串（String）类型字符串（String）类型 允许您给变量分配任何字符串值。字符串（String）类型是 System.String 类的别名。它是从对象（Object）类型派生的。字符串（String）类型的值可以通过两种形式进行分配：引号和 @引号。 例如： 1String str = \"runoob.com\"; 一个 @引号字符串： 1@\"runoob.com\"; C# string 字符串的前面可以加 @（称作”逐字字符串”）将转义字符（\\）当作普通字符对待，比如： string str = @\"C:\\Windows\"; 等价于 string str = \"C:\\\\Windows\"; @ 字符串中可以任意换行，换行符及缩进空格都计算在字符串长度之内。 1234string str = @\"&lt;script type=\"\"text/javascript\"\"&gt; &lt;!-- --&gt;&lt;/script&gt;\"; 用户自定义引用类型有：class、interface 或 delegate。 类型转换C# 提供了下列内置的类型转换方法： 序号 方法 &amp; 描述 1 ToBoolean 如果可能的话，把类型转换为布尔型。 2 ToByte 把类型转换为字节类型。 3 ToChar 如果可能的话，把类型转换为单个 Unicode 字符类型。 4 ToDateTime 把类型（整数或字符串类型）转换为 日期-时间 结构。 5 ToDecimal 把浮点型或整数类型转换为十进制类型。 6 ToDouble 把类型转换为双精度浮点型。 7 ToInt16 把类型转换为 16 位整数类型。 8 ToInt32 把类型转换为 32 位整数类型。 9 ToInt64 把类型转换为 64 位整数类型。 10 ToSbyte 把类型转换为有符号字节类型。 11 ToSingle 把类型转换为小浮点数类型。 12 ToString 把类型转换为字符串类型。 13 ToType 把类型转换为指定类型。 14 ToUInt16 把类型转换为 16 位无符号整数类型。 15 ToUInt32 把类型转换为 32 位无符号整数类型。 16 ToUInt64 把类型转换为 64 位无符号整数类型。 例如： 1a.ToString() document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://blog.iwxyi.com/tags/学习笔记/"},{"name":"C#","slug":"C","permalink":"http://blog.iwxyi.com/tags/C/"}]},{"title":"Win32 SDK绘制字体及透明文字","date":"2018-06-19T01:40:00.000Z","path":"2018/06/19/VC-绘制字体及透明文字/","text":"在hdc上绘制文字：CreateFont 12345678910111213141516HDC hdc;HFONT hf;TEXTMETRIC tm;double len;int left;hdc = GetDC(hWnd);hf = CreateFont(0, 0, 0, 0, 0, 0, 0, 0, 0, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS, DEFAULT_QUALITY, DEFAULT_PITCH, \"楷体\"); // (HFONT) GetStockObject(0)SelectObject(hdc, hf); // 绑定画笔SetTextColor(hdc, 0x0000FF/*BGR*/); // 绑定颜色GetTextMetrics(hdc, &amp;tm); // 绑定大小len = strlen(str) * tm.tmAveCharWidth; // 要画的文字总长度left = R - len / 2; // 居中对齐TextOut(hdc, left, 0, str, strlen(str));DeleteObject(hf);cheight += tm.tmHeight; // 下一行的高度 设置文字背景透明 1SetBkMode(mdc, TRANSPARENT); 还有两句额外的设置颜色的 12SetTextColor(mdc, RGB(255, 0, 0));SetBkColor(mdc, RGB(0, 0, 0)); document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Win32 SDK","slug":"Win32-SDK","permalink":"http://blog.iwxyi.com/tags/Win32-SDK/"}]},{"title":"SQL查询及删除重复记录","date":"2018-06-15T10:38:00.000Z","path":"2018/06/15/SQL查询及删除重复记录/","text":"1、查找表中多余的重复记录，重复记录是根据单个字段（peopleId）来判断 12select * from peoplewhere peopleId in (select peopleId from people group by peopleId having count(peopleId) &gt; 1) 2、删除表中多余的重复记录，重复记录是根据单个字段（peopleId）来判断，只留有rowid最小的记录 123delete from peoplewhere peopleId in (select peopleId from people group by peopleId having count(peopleId) &gt; 1)and rowid not in (select min(rowid) from people group by peopleId having count(peopleId )&gt;1) 3、查找表中多余的重复记录（多个字段） 12select * from vitae awhere (a.peopleId,a.seq) in (select peopleId,seq from vitae group by peopleId,seq having count(*) &gt; 1) 4、删除表中多余的重复记录（多个字段），只留有rowid最小的记录 123delete from vitae awhere (a.peopleId,a.seq) in (select peopleId,seq from vitae group by peopleId,seq having count(*) &gt; 1)and rowid not in (select min(rowid) from vitae group by peopleId,seq having count(*)&gt;1) 5、查找表中多余的重复记录（多个字段），不包含rowid最小的记录 123select * from vitae awhere (a.peopleId,a.seq) in (select peopleId,seq from vitae group by peopleId,seq having count(*) &gt; 1)and rowid not in (select min(rowid) from vitae group by peopleId,seq having count(*)&gt;1) document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"SQL","slug":"SQL","permalink":"http://blog.iwxyi.com/tags/SQL/"}]},{"title":"Win32 SDK绘图函数","date":"2018-06-09T02:16:00.000Z","path":"2018/06/09/Win32-SDK绘图函数/","text":"获取HDC 12345678910111213141516171819202122232425LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam){ switch(message) { case WM_PAINT : PAINTSTRUCT ps; HDC hdc; hdc = BeginPaint(hWnd, &amp;ps); RECT rect; GetClientRect (hWnd, &amp;rect); paintOperator(hdc, rect.left, rect.top, rect.right, rect.bottom); EndPaint(hWnd, &amp;ps); break; case WM_DESTROY : PostQuitMessage(0); // 发出 WM_QUIT 消息，没有这句话则只是关闭窗口但进程不会停止 break; default : return DefWindowProc(hWnd, message, wParam, lParam); // 默认时采用系统消息默认处理函数 } return 0;} 画笔123456789101112131415HPEN hp;hp = (HPEN) GetStockObject(BLACK_PEN); // 默认画笔SelectObject(hdc, hp);MoveToEx(hdc,x,y,NULL);LineTo(hdc,x,y); // 画直线，需要先移动点的位置Ellipse(hdc, L, T, R, B); // 画椭圆hp = (HPEN) CreatePen(PS_SOLID, 3, RGB(0xFF, 0, 0)); // 自定义画笔SelectObject(hdc, hp);POINT lpPoints[4] = { {L, B}, {R, B}, {(L+R)/2, T}, {L, B} }; // 三角形的点Polyline(hdc, lpPoints, 4); // 画点数组DeleteObject(hp); // 别忘了CreatePen后要手动删除 画刷1234HBRUSH hbr = (HBRUSH) CreateSolidBrush(RGB(color[pos][0], color[pos][1], color[pos][2]));SelectObject(hdc, hbr);Rectangle(hdc, L, T, R, B);DeleteObject(hbr); 字体12345678910111213141516HFONT hf;TEXTMETRIC tm;char * str[5] = {\"HELLO WORLD!\", \"\", \"\"};hf = CreateFont(0, 0, 0, 0, 0, 0, 0, 0, 0, OUT_DEFAULT_PRECIS, CLIP_DEFAULT_PRECIS, DEFAULT_QUALITY, DEFAULT_PITCH, \"楷体\"); // (HFONT) GetStockObject(0) // 创建字体SelectObject(hdc, hf);SetTextColor(hdc, 0x0000FF/*BGR*/); // 选择颜色GetTextMetrics(hdc, &amp;tm); // 获取字体属性：宽高double len = strlen(str[0]) * tm.tmAveCharWidth; // 字体长度int left = (R-W/2) - len/2; // 居中靠上显示，获取左边坐标TextOut(hdc, left, 0, str[0], strlen(str[0])); // 输出DeleteObject(hf);double cheight += tm.tmHeight; // 当前字体的高度，以便于下一行double cwidth = tm.tmAveCharWidth; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Win32 SDK","slug":"Win32-SDK","permalink":"http://blog.iwxyi.com/tags/Win32-SDK/"}]},{"title":"C++不能重载的符号","date":"2018-06-07T23:30:00.000Z","path":"2018/06/08/C-不能重载的符号/","text":"半边括号( ) [ ]、{}、&lt;&gt;、!、.、\"、'、?、:、;、~、::、...、//、/* */ 可以重载：, document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"C++","slug":"C","permalink":"http://blog.iwxyi.com/tags/C/"}]},{"title":"Win32 SDK双缓冲模板","date":"2018-06-04T02:19:00.000Z","path":"2018/06/04/Win32-SDK双缓冲模板/","text":"游戏窗口双缓冲模板，可直接使用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149#include &lt;windows.h&gt;#include &lt;tchar.h&gt;#include \"StdAfx.h\"HINSTANCE hInst;HWND hWnd;DWORD tPre, tNow;int TOP, RIGHT, WIDTH = 1000, HEIGHT = 571;int MX, MY; // 鼠标位置HDC hdc, mdc, bufdc;PAINTSTRUCT ps;RECT rect;HBITMAP fullmap, hBgBmp;ATOM MyRegisterClass(HINSTANCE hInstance);BOOL InitInstance(HINSTANCE, int);LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);void MyPaint(HDC hdc);//***WinMain函数，程序入口点函数**************************************int APIENTRY WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow){ MSG msg; MyRegisterClass(hInstance); //初始化 if (!InitInstance (hInstance, nCmdShow)) return FALSE; //消息循环 GetMessage(&amp;msg, NULL, NULL, NULL); //初始化msg while( msg.message != WM_QUIT ) { if( PeekMessage( &amp;msg, NULL, 0, 0 , PM_REMOVE) ) { TranslateMessage( &amp;msg ); DispatchMessage( &amp;msg ); } else { tNow = GetTickCount(); if(tNow - tPre &gt;= 40) MyPaint(hdc); } } return msg.wParam;}//****设计一个窗口类，类似填空题，使用窗口结构体*************************ATOM MyRegisterClass(HINSTANCE hInstance){ WNDCLASSEX wcex; wcex.cbSize = sizeof(WNDCLASSEX); wcex.style = CS_HREDRAW | CS_VREDRAW; wcex.lpfnWndProc = (WNDPROC)WndProc; wcex.cbClsExtra = 0; wcex.cbWndExtra = 0; wcex.hInstance = hInstance; wcex.hIcon = NULL; wcex.hCursor = NULL; wcex.hCursor = LoadCursor(NULL, IDC_ARROW); wcex.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1); wcex.lpszMenuName = NULL; wcex.lpszClassName = \"canvas\"; wcex.hIconSm = NULL; return RegisterClassEx(&amp;wcex);}//****初始化函数*************************************// 加载位图并设定各对象的初始值BOOL InitInstance(HINSTANCE hInstance, int nCmdShow){ hInst = hInstance; hWnd = CreateWindow(\"canvas\", \"演示\" , WS_OVERLAPPEDWINDOW, CW_USEDEFAULT, CW_USEDEFAULT, WIDTH, HEIGHT, NULL, NULL, hInstance, NULL); if (!hWnd) return FALSE; // MoveWindow(hWnd, 10, 10, WIDTH, HEIGHT, true); ShowWindow(hWnd, nCmdShow); UpdateWindow(hWnd); hdc = GetDC(hWnd); mdc = CreateCompatibleDC(hdc); bufdc = CreateCompatibleDC(hdc); fullmap = CreateCompatibleBitmap(hdc, WIDTH, HEIGHT); SelectObject(mdc, fullmap); /* ... 初始化各值 ... */ MyPaint(hdc); return TRUE;}void MyPaint(HDC hdc){ /* ... 画图操作，可以生成动画 ... */ tPre = GetTickCount();}//****消息处理函数***********************************LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam){ int i, j; switch (message) { case WM_PAINT : hdc = BeginPaint(hWnd, &amp;ps); GetClientRect(hWnd, &amp;rect); MyPaint(hdc); EndPaint(hWnd, &amp;ps); break; case WM_MOUSEMOVE : MX = LOWORD(lParam) - roleFlyBmp[action][actionFrame].bmWidth / 2; MY = HIWORD(lParam) - roleFlyBmp[action][actionFrame].bmHeight / 2; break; case WM_LBUTTONDOWN : break; case WM_KEYDOWN : switch (wParam) { case VK_UP : break; } break; case WM_CHAR : switch (wParam) { case ' ' : break; } break; case WM_DESTROY: //窗口结束消息，撤销各种DC DeleteDC(mdc); DeleteDC(bufdc); DeleteObject(fullmap); ReleaseDC(hWnd, hdc); PostQuitMessage(0); break; default: //其他消息 return DefWindowProc(hWnd, message, wParam, lParam); } return 0;} 游戏模板参照上面的双缓冲模板。 之前做的一个作业样例。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354#include &lt;windows.h&gt;#include &lt;tchar.h&gt;#include &lt;stdio.h&gt;#include \"StdAfx.h\"#include \"testOutput.h\"//using namespace std;#define LIMIT_RECT 1 // 矩形限制区域#define LIMIT_CIRC 2 // 圆形限制区域#define ACTION_STARTFLY 0 // 开始飞行#define ACTION_FLY 1 // 向右飞#define ACTION_FLY2 2 // 向左飞#define ACTION_ATTACK 3 // 向右攻击#define ACTION_ATTACK2 4 // 向左攻击HINSTANCE hInst;HWND hWnd;DWORD tPre, tNow;int TOP, RIGHT, WIDTH = 1000, HEIGHT = 571;int OX = 370, OY = 180, MX, MY; // 实例位置int SX = 10, SY = 10; // 每步移动的距离int EX = 0, EY = 0; // 目标位置HDC hdc, mdc, bufdc;PAINTSTRUCT ps;RECT rect;HBITMAP fullmap, hBgBmp, hRoleBmp[10][100], _hRoleBmp[10][100];BITMAP bgBmp, roleFlyBmp[10][100], _roleFlyBmp[10][100];int action = ACTION_STARTFLY /*0 normal, 1 2 fly*/, actionFrame = 0, actionFrameContrler = 0;int limitsMap[][5] ={ { 0, 0, 1000, 55, LIMIT_RECT }, { 258, 0, 850, 55, LIMIT_RECT }, { 342, 0, 500, 70, LIMIT_RECT }, { 0, 225, 170, 50, LIMIT_RECT }, { 0, 275, 54, 72, LIMIT_RECT }, { 0, 455, 72, 119, LIMIT_RECT }, { 310, 360, 324, 80, LIMIT_RECT }, { 404, 300, 200, 237, LIMIT_RECT }, { 504, 468, 522, 115, LIMIT_RECT }, { 0, 0, 43, 306, LIMIT_RECT }, { 940, 0, 42, 187, LIMIT_RECT }}, limitsMapNum = 11;ATOM MyRegisterClass(HINSTANCE hInstance);BOOL InitInstance(HINSTANCE, int);LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);void MyPaint(HDC hdc);//***WinMain函数，程序入口点函数**************************************int APIENTRY WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow){ MSG msg; MyRegisterClass(hInstance); //初始化 if (!InitInstance (hInstance, nCmdShow)) return FALSE; //消息循环 GetMessage(&amp;msg, NULL, NULL, NULL); //初始化msg while( msg.message != WM_QUIT ) { if( PeekMessage( &amp;msg, NULL, 0, 0 , PM_REMOVE) ) { TranslateMessage( &amp;msg ); DispatchMessage( &amp;msg ); } else { tNow = GetTickCount(); if(tNow - tPre &gt;= 40) MyPaint(hdc); } } return msg.wParam;}int max(int a, int b) { return a &gt; b ? a : b;}//****设计一个窗口类，类似填空题，使用窗口结构体*************************ATOM MyRegisterClass(HINSTANCE hInstance){ WNDCLASSEX wcex; wcex.cbSize = sizeof(WNDCLASSEX); wcex.style = CS_HREDRAW | CS_VREDRAW; wcex.lpfnWndProc = (WNDPROC)WndProc; wcex.cbClsExtra = 0; wcex.cbWndExtra = 0; wcex.hInstance = hInstance; wcex.hIcon = NULL; wcex.hCursor = NULL; wcex.hCursor = LoadCursor(NULL, IDC_ARROW); wcex.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1); wcex.lpszMenuName = NULL; wcex.lpszClassName = \"canvas\"; wcex.hIconSm = NULL; return RegisterClassEx(&amp;wcex);}//****初始化函数*************************************// 加载位图并设定各对象的初始值BOOL InitInstance(HINSTANCE hInstance, int nCmdShow){ hInst = hInstance; hWnd = CreateWindow(\"canvas\", \"动画演示\" , WS_OVERLAPPEDWINDOW, CW_USEDEFAULT, CW_USEDEFAULT, WIDTH, HEIGHT, NULL, NULL, hInstance, NULL); if (!hWnd) return FALSE; // MoveWindow(hWnd, 10, 10, WIDTH, HEIGHT, true); ShowWindow(hWnd, nCmdShow); UpdateWindow(hWnd); hdc = GetDC(hWnd); mdc = CreateCompatibleDC(hdc); bufdc = CreateCompatibleDC(hdc); fullmap = CreateCompatibleBitmap(hdc, WIDTH, HEIGHT); SelectObject(mdc, fullmap); hBgBmp = (HBITMAP)LoadImage(NULL, \"bg.bmp\", IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE); GetObject(hBgBmp, sizeof(BITMAP), &amp;bgBmp); int i, j; char actionName[10][20] = { \"startfly\", \"fly\", \"fly2\", \"attack\", \"attack2\" }; for (i = 0; i &lt; 5; i++) { char fullName[100]; for (j = 0; j &lt; 5; j++) { sprintf(fullName, \"%s%d.bmp\", actionName[i], j); hRoleBmp[i][j] = (HBITMAP)LoadImage(NULL, fullName, IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE); sprintf(fullName, \"_%s%d.bmp\", actionName[i], j); _hRoleBmp[i][j] = (HBITMAP)LoadImage(NULL, fullName, IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE); GetObject(hRoleBmp[i][j], sizeof(BITMAP), &amp;roleFlyBmp[i][j]); } } MyPaint(hdc); return TRUE;}void limitXY(int nOX, int nOY){ int lix, liy, liw, lih; for (int i = 0; i &lt; limitsMapNum; i++) { lix = limitsMap[i][0]; liy = limitsMap[i][1]; liw = limitsMap[i][2]; lih = limitsMap[i][3]; // 画限制区域和人物的范围，调试用 /*HBRUSH hb; hb = (HBRUSH) CreateSolidBrush(RGB(0xFF, 0xFF, 0xFF)); SelectObject(hdc, hb); Rectangle(hdc, lix, liy, lix + liw, liy + lih); Ellipse(hdc, OX, OY, OX + roleFlyBmp[action][actionFrame].bmWidth, OY + roleFlyBmp[action][actionFrame].bmHeight); DeleteObject(hb);*/ if (OX &gt; lix + liw || OX + roleFlyBmp[action][actionFrame].bmWidth &lt; lix || OY &gt; liy + lih || OY + roleFlyBmp[action][actionFrame].bmHeight &lt; liy || (OX - lix - liw / 2) * (OX - lix - liw / 2) + (OY - liy - lih / 2) * (OY - liy - lih / 2) &gt; (max(liw , lih) * max(liw , lih)) &gt;&gt; 1) ; // 边角处理 else { if (OX &gt; lix + liw || OX + roleFlyBmp[action][actionFrame].bmWidth &lt; lix) ; else OX = nOX; if (OY &gt; liy + lih || OY + roleFlyBmp[action][actionFrame].bmHeight &lt; liy) ; else OY = nOY; if (OX == nOX &amp;&amp; OY == nOY) break; } }}void MyPaint(HDC hdc){ // 运动 int nOX = OX, nOY = OY; if (EX || EY) { int fflag = 0; if (abs(EX - OX) &gt; SX) { fflag = 1; if (EX &gt; OX) OX += SX; else OX -= SX; } if (abs(EY - OY) &gt; SY) { fflag = 1; if (EY &gt; OY) OY += SY; else OY -= SY; } if (!fflag) EX = EY = 0; } limitXY(nOX, nOY); // 画背景 SelectObject(bufdc, hBgBmp); BitBlt(mdc, rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top, bufdc, 0, 0, SRCCOPY); // 画背景 SelectObject(bufdc, _hRoleBmp[action][actionFrame]); BitBlt(mdc, OX, OY, roleFlyBmp[action][actionFrame].bmWidth, roleFlyBmp[action][actionFrame].bmHeight, bufdc, 0, 0, SRCAND); // 画人物 SelectObject(bufdc, hRoleBmp[action][actionFrame]); BitBlt(mdc, OX, OY, roleFlyBmp[action][actionFrame].bmWidth, roleFlyBmp[action][actionFrame].bmHeight, bufdc, 0, 0, SRCPAINT); // 画人物 BitBlt(hdc, 0, 0, WIDTH, HEIGHT, mdc, 0, 0, SRCCOPY); // 动画 switch (action) { case ACTION_STARTFLY: if (!EX &amp;&amp; !EY &amp;&amp; OX==370 &amp;&amp; OY==180) return ; if (actionFrameContrler &gt;= 4) { actionFrameContrler = 0; action = 1; } actionFrame = actionFrameContrler; break; case ACTION_FLY: case ACTION_FLY2: if (actionFrameContrler &gt;= 8) actionFrameContrler = 0; actionFrame = actionFrameContrler / 2; break; case ACTION_ATTACK: case ACTION_ATTACK2: if (actionFrameContrler &gt;= 15) { actionFrameContrler = 0; action -= (ACTION_ATTACK - ACTION_FLY); } actionFrame = actionFrameContrler / 3; break; } actionFrameContrler++; tPre = GetTickCount();}//****消息处理函数***********************************LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam){ int i, j; switch (message) { case WM_PAINT : hdc = BeginPaint(hWnd, &amp;ps); GetClientRect(hWnd, &amp;rect); MyPaint(hdc); EndPaint(hWnd, &amp;ps); break; case WM_MOUSEMOVE : MX = LOWORD(lParam) - roleFlyBmp[action][actionFrame].bmWidth / 2; MY = HIWORD(lParam) - roleFlyBmp[action][actionFrame].bmHeight / 2; break; case WM_LBUTTONDOWN : EX = MX; EY = MY; if (EX &lt; OX) action = ACTION_FLY2; else if (action != ACTION_STARTFLY) action = ACTION_FLY; break; case WM_KEYDOWN : switch (wParam) { case VK_UP : OY -= 20; limitXY(OX, OY + 20); break; case VK_DOWN : OY += 20; limitXY(OX, OY - 20); break; case VK_LEFT : OX -= 20; limitXY(OX + 20, OY); action = 2; break; case VK_RIGHT : OX += 20; limitXY(OX - 20, OY); action = 1; break; } break; case WM_CHAR : switch (wParam) { case 'w' : OY -= 20; limitXY(OX, OY + 20); break; case 's' : OY += 20; limitXY(OX, OY - 20); break; case 'a' : OX -= 20; limitXY(OX + 20, OY); action = 2; break; case 'd' : OX += 20; limitXY(OX - 20, OY); action = 1; break; case ' ' : if (action != 3 &amp;&amp; action != 4) { if (action == 1 || action == 2) action += 2; else action = 3; actionFrameContrler = 0; break; } } break; case WM_DESTROY: //窗口结束消息，撤销各种DC DeleteDC(mdc); DeleteDC(bufdc); DeleteObject(fullmap); for (i = 0; i &lt; 5; i++) for (j = 0; j &lt; 5; j++) { DeleteObject(hRoleBmp[i][j]); DeleteObject(_hRoleBmp[i][j]); } ReleaseDC(hWnd, hdc); PostQuitMessage(0); break; default: //其他消息 return DefWindowProc(hWnd, message, wParam, lParam); } return 0;} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"模板","slug":"模板","permalink":"http://blog.iwxyi.com/tags/模板/"},{"name":"Win32 SDK","slug":"Win32-SDK","permalink":"http://blog.iwxyi.com/tags/Win32-SDK/"}]},{"title":"Win32 SDK双缓冲","date":"2018-06-04T02:00:00.000Z","path":"2018/06/04/Win32-SDK双缓冲/","text":"声明123HDC hdc, mdc, bufdc;HBITMAP fullmap, hBgBmp, hRoleBmp[10][100], _hRoleBmp[10][100];BITMAP bgBmp, roleFlyBmp[10][100], _roleFlyBmp[10][100]; 初始化1234567891011121314151617181920212223242526hdc = GetDC(hWnd);mdc = CreateCompatibleDC(hdc);bufdc = CreateCompatibleDC(hdc);fullmap = CreateCompatibleBitmap(hdc, WIDTH, HEIGHT);SelectObject(mdc, fullmap);hBgBmp = (HBITMAP)LoadImage(NULL, \"bg.bmp\", IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE);GetObject(hBgBmp, sizeof(BITMAP), &amp;bgBmp);// 循环加载所有图片int i, j;char actionName[10][20] = { \"startfly\", \"fly\", \"fly2\", \"attack\", \"attack2\" };for (i = 0; i &lt; 5; i++){ char fullName[100]; for (j = 0; j &lt; 5; j++) { sprintf(fullName, \"%s%d.bmp\", actionName[i], j); hRoleBmp[i][j] = (HBITMAP)LoadImage(NULL, fullName, IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE); // 原图 sprintf(fullName, \"_%s%d.bmp\", actionName[i], j); _hRoleBmp[i][j] = (HBITMAP)LoadImage(NULL, fullName, IMAGE_BITMAP, 0, 0, LR_LOADFROMFILE); // 掩图 GetObject(hRoleBmp[i][j], sizeof(BITMAP), &amp;roleFlyBmp[i][j]); }} 绘图12345678910SelectObject(bufdc, hBgBmp);BitBlt(mdc, rect.left, rect.top, rect.right - rect.left, rect.bottom - rect.top, bufdc, 0, 0, SRCCOPY); // 画背景到mdcSelectObject(bufdc, _hRoleBmp[action][actionFrame]);BitBlt(mdc, OX, OY, roleFlyBmp[action][actionFrame].bmWidth, roleFlyBmp[action][actionFrame].bmHeight, bufdc, 0, 0, SRCAND); // 画人物[掩图]到mdcSelectObject(bufdc, hRoleBmp[action][actionFrame]);BitBlt(mdc, OX, OY, roleFlyBmp[action][actionFrame].bmWidth, roleFlyBmp[action][actionFrame].bmHeight, bufdc, 0, 0, SRCPAINT);BitBlt(hdc, 0, 0, WIDTH, HEIGHT, mdc, 0, 0, SRCCOPY); // 画mdc到hdc document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Win32 SDK","slug":"Win32-SDK","permalink":"http://blog.iwxyi.com/tags/Win32-SDK/"}]},{"title":"HTML改变Chrome标签页颜色","date":"2018-06-03T05:09:00.000Z","path":"2018/06/03/HTML改变Chrome标签页颜色/","text":"1&lt;meta name=\"theme-color\" content=\"#db5945\"&gt; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"HTML","slug":"HTML","permalink":"http://blog.iwxyi.com/tags/HTML/"}]},{"title":"CSS伪元素计数","date":"2018-06-03T04:57:00.000Z","path":"2018/06/03/CSS伪元素计数/","text":"123456789&lt;h2&gt;&lt;/h2&gt;&lt;h2&gt;&lt;/h2&gt;&lt;style&gt;body {counter-reset:section;}h2:before {counter-increment: section;content: \"Chapter\" counter(section) \".\";}&lt;/style&gt; 结果如下： 12Chapter1.Chapter2. document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"CSS","slug":"CSS","permalink":"http://blog.iwxyi.com/tags/CSS/"}]},{"title":"C++取数组长度函数","date":"2018-06-03T00:17:00.000Z","path":"2018/06/03/C-取数组长度函数/","text":"12345template &lt;typename Type, size_t N&gt;inline size_t GetArrayLength(const Type(&amp;)[N]){ return N;} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"C++","slug":"C","permalink":"http://blog.iwxyi.com/tags/C/"}]},{"title":"C++11 Lambda示例","date":"2018-06-03T00:04:00.000Z","path":"2018/06/03/C-11-Lambda示例/","text":"声明 Lambda 表达式12345auto f1 = [](int x, int y) { return x + y; };cout &lt;&lt; f1(2, 3) &lt;&lt; endl; // 输出 5function&lt;int(int, int)&gt; f2 = [](int x, int y) { return x + y; };cout &lt;&lt; f2(3, 4) &lt;&lt; endl; // 输出 7 12345678910111213141516#include &lt;functional&gt;#include &lt;iostream&gt;int main(){ using namespace std; int i = 3, j = 5; function&lt;int (void)&gt; f = [i, &amp;j] { return i + j; }; i = 22; j = 44; cout &lt;&lt; f() &lt;&lt; endl; // 3 + j = 47，输出 47} 调用 Lambda 表达式12345678#include &lt;iostream&gt;int main(){ using namespace std; int n = [] (int x, int y) { return x + y; }(5, 4); cout &lt;&lt; n &lt;&lt; endl; // 输出 9} 12345678910111213141516171819202122232425// STL+Lambda 用法#include &lt;list&gt;#include &lt;algorithm&gt;#include &lt;iostream&gt;int main(){ using namespace std; list&lt;int&gt; numbers; numbers.push_back(13); numbers.push_back(17); numbers.push_back(42); numbers.push_back(46); numbers.push_back(99); const list&lt;int&gt;::const_iterator result = find_if(numbers.begin(), numbers.end(),[](int n) { return (n % 2) == 0; }); if (result != numbers.end()) { cout &lt;&lt; \"The first even number in the list is \" &lt;&lt; *result &lt;&lt; \".\" &lt;&lt; endl; // 第一个偶数是 42 } else { cout &lt;&lt; \"The list contains no even numbers.\" &lt;&lt; endl; }} 嵌套 Lambda 表达式12345678910111213#include &lt;iostream&gt;int main(){ using namespace std; // The following lambda expression contains a nested lambda // expression. int timestwoplusthree = [](int x) { return [](int y) { return y * 2; }(x) + 3; }(5); // Print the result. cout &lt;&lt; timestwoplusthree &lt;&lt; endl;} 高阶Lambda函数https://msdn.microsoft.com/zh-cn/library/dd293599.aspx document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"C++11","slug":"C-11","permalink":"http://blog.iwxyi.com/tags/C-11/"},{"name":"Lambda","slug":"Lambda","permalink":"http://blog.iwxyi.com/tags/Lambda/"}]},{"title":"C++11 auto类型与引用","date":"2018-06-02T23:50:00.000Z","path":"2018/06/03/C-11-auto类型与引用/","text":"123int count = 10;int&amp; countRef = count;auto myAuto = countRef; // 普通的int，非引用 您可能会认为 myAuto 是一个 int 引用，但它不是。 验证： 12345countRef = 11;cout &lt;&lt; count &lt;&lt; \" \";myAuto = 12;cout &lt;&lt; count &lt;&lt; endl; 它只是一个 int。因为输出为 11 11，而不是 11 12； 如果 auto 尚未删除此引用，则会出现此情况。 12345678910111213141516171819202122map&lt;int,list&lt;string&gt;&gt;::iterator i = m.begin();auto i = m.begin(); // 就是如此简单……#include &lt;deque&gt;using namespace std;int main(){ deque&lt;double&gt; dqDoubleData(10, 0.1); for (auto iter = dqDoubleData.begin(); iter != dqDoubleData.end(); ++iter) // 注意是 ++iter { /* ... */ } for (auto elem : dqDoubleData) { /* ... */ } for (auto&amp; elem : dqDoubleData) { /* ... */ } for (const auto&amp; elem : dqDoubleData) { /* ... */ }} 123456789101112131415161718double x = 12.34;auto *y = new auto(x), **z = new auto(&amp;x);auto x = 1, *y = &amp;x, **z = &amp;y; // Resolves to int.auto a(2.01), *b (&amp;a); // Resolves to double.auto c = 'a', *d(&amp;c); // Resolves to char.auto m = 1, &amp;n = m; // Resolves to int.int f(int x) { return x; }int main(){ auto x = f(0); // int x const auto &amp; y = f(1); // const int &amp; y 引用 int (*p)(int x); p = f; auto fp = p; // 返回值为 int 类型的函数的指针} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"C++11","slug":"C-11","permalink":"http://blog.iwxyi.com/tags/C-11/"}]},{"title":"C++重载()仿构造函数","date":"2018-06-02T23:46:00.000Z","path":"2018/06/03/C-重载-仿构造函数/","text":"坑同事技巧+1 1234567891011121314151617181920class Point{public: Point() { _x = _y = 0; } Point &amp;operator()( int dx, int dy ) { _x += dx; _y += dy; return *this; }private: int _x, _y;};int main(){ Point pt; // 初始化为 (0, 0) pt( 3, 2 ); // 这他妈不是函数……} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"C++","slug":"C","permalink":"http://blog.iwxyi.com/tags/C/"}]},{"title":"C++异常规范","date":"2018-06-02T23:43:00.000Z","path":"2018/06/03/C-异常规范/","text":"throw、try、catch 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;stdio.h&gt;void handler() { printf_s(\"in handler\\n\");}void f1(void) throw(int) { printf_s(\"About to throw 1\\n\"); if (1) throw 1;}void f5(void) throw() { try { f1(); } catch(...) { handler(); }}//invalid, doesn't handle the int exception thrown from f1()/*void f3(void) throw() { f1();}*/void __declspec(nothrow) f2(void) { try { f1(); } catch(int) { handler(); }}extern \"C\" void f4(void);void f4(void) { f1();}int main() { f2(); try { f4(); } catch(...) { printf_s(\"Caught exception from f4\\n\"); } f5();} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"C++","slug":"C","permalink":"http://blog.iwxyi.com/tags/C/"}]},{"title":"C++线程函数","date":"2018-06-02T23:42:00.000Z","path":"2018/06/03/C-线程函数/","text":"线程随着 std::thread 类型实例的创建而创建 从 C++ 11 开始，推荐使用列表初始化的方式，构造类类型的变量。 当函数的名字被当做一个值来使用的时候，实际上使用的是函数的指针。 12345678910111213#include &lt;iostream&gt;#include &lt;thread&gt; // 1void greeting() { // 2 std::cout &lt;&lt; \"Hello multithread!\" &lt;&lt; std::endl; return;}int main() { std::thread t{greeting}; // 3 t.join(); // 4 return 0;} std::thread wk_thread(ThreadTask()); // 1 std::thread wk_thread{ThreadTask{}}; // 2 在 (1) 处，作者的本意，是想构造一个 ThreadTask 实例，作为可调用对象作为 wk_thread 线程的线程函数。但实际上，ThreadTask() 是一个函数指针的类型——这个函数没有参数 (void)，返回值的类型是 ThreadTask。因此，整个 (1) 会被 C++ 理解为一个函数声明：参数是一个函数指针（前述），返回类型是 std::thread。 构造函数和普通的函数是有一些不同的。构造函数执行完毕之后，就产生了一个可用的实例。产生这样误解的本质原因，是 std::thread 的构造函数也是函数，因而采用 () 接受参数列表；这样一来，从形式上构造函数就没有任何特殊性了。C++ 11 引入了列表初始化的概念，允许程序员以花括号代替圆括号，将参数传递给构造函数。这样一来，(2) 就没有歧义了。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"C++","slug":"C","permalink":"http://blog.iwxyi.com/tags/C/"},{"name":"多线程","slug":"多线程","permalink":"http://blog.iwxyi.com/tags/多线程/"}]},{"title":"C++11 Lambda表达式","date":"2018-06-02T23:27:00.000Z","path":"2018/06/03/C-11-Lambda表达式/","text":"Lambda 可在其主体中引入新的变量（用 C++14），它还可以访问（或“捕获”）周边范围内的变量。 12345678910#include &lt;algorithm&gt;#include &lt;cmath&gt;void abssort(float* x, unsigned n) { std::sort(x, x + n, [](float a, float b) { return (std::abs(a) &lt; std::abs(b)); } );} 指定要捕获的变量以及是通过值还是引用进行捕获。 有与号 (&amp;) 前缀的变量通过引用访问，没有该前缀的变量通过值访问。 以使用默认捕获模式（标准语法中的 capture-default）来指示如何捕获 lambda 中引用的任何外部变量：[&amp;] 表示通过引用捕获引用的所有变量，而 [=] 表示通过值捕获它们。 可以使用默认捕获模式，然后为特定变量显式指定相反的模式。 （引用和值，效果同函数形参） 例如，如果 lambda 体通过引用访问外部变量 total 并通过值访问外部变量 factor，则以下 capture 子句等效： 123456[&amp;total, factor][factor, &amp;total][&amp;, factor][factor, &amp;][=, &amp;total][&amp;total, =] identifier(&amp;/=) 或 this 在 capture 子句中出现的次数不能超过一次。示例： 12345678struct S { void f(int i); };void S::f(int i) { [&amp;, i]{}; // OK [&amp;, &amp;i]{}; // ERROR: i preceded by &amp; when &amp; is the default [=, this]{}; // ERROR: this when = is the default [i, i]{}; // ERROR: i repeated} 包扩展：capture 后跟省略号可变参数模板 12345template&lt;class... Args&gt;void f(Args... args) { auto x = [args...] { return g(args...); }; x();} 参数列表 1234int y = [] (int first, int second){ return first + second;}; 12345// C++14，创建模板auto y = [] (auto first, auto second){ return first + second;}; 在 C++14 中，如果参数类型是泛型，则可以使用 auto 关键字作为类型说明符。 这将告知编译器将函数调用运算符创建为模板。 参数列表中的每个 auto 实例等效于一个不同的类型参数。 异常规范 1234int main() // C4297 expected{ []() throw() { throw 5; }();} 返回类型 1234auto x1 = [](int i){ return i; }; // OK: return type is intauto x2 = []{ return{ 1, 2 }; }; // ERROR: return type is void, deducing// return type from braced-init-list is not valid lambda 表达式可以生成另一个 lambda 表达式作为其返回值。 通过值显式捕获变量 n 并通过引用隐式捕获变量 m 的 lambda 表达式： 12345678910#include &lt;iostream&gt;using namespace std;int main(){ int m = 0; int n = 0; [&amp;, n] (int a) mutable { m = ++n + a; }(4); cout &lt;&lt; m &lt;&lt; \" \" &lt;&lt; n &lt;&lt; endl; // 输出：5 0} mutable 规范允许在 lambda 中修改 n。 示例：使用 generate 函数和 lambda 表达式为 vector 对象中的每个元素赋值。 lambda 表达式将修改静态变量以生成下一个元素的值。 12345678910111213#include &lt;algorithm&gt;#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;using namespace std;void fillVector(vector&lt;int&gt;&amp; v){ static int nextValue = 1; generate(v.begin(), v.end(), [] { return nextValue++; }); // generate 函数见：生成 ‎ //WARNING: not thread-safe and …} 1234567891011121314151617181920212223242526272829303132template &lt;typename C&gt;void print(const string&amp; s, const C&amp; c) { cout &lt;&lt; s; for (const auto&amp; e : c) { cout &lt;&lt; e &lt;&lt; \" \"; } cout &lt;&lt; endl;}int main(){ const int elementCount = 9; vector&lt;int&gt; v(elementCount, 1); int x = 1, y = 1; //斐波那契：每个等于前两个的和 generate_n(v.begin() + 2, elementCount - 2, [=]() mutable throw() -&gt; int { int n = x + y; x = y; y = n; return n; }); print(\"vector v after call to generate_n() with lambda: \", v); cout &lt;&lt; \"x: \" &lt;&lt; x &lt;&lt; \" y: \" &lt;&lt; y &lt;&lt; endl; // x y 仍为1 fillVector(v); print(\"vector v after 1st call to fillVector(): \", v); fillVector(v); print(\"vector v after 2nd call to fillVector(): \", v);} 输出： 1234vector v after call to generate_n() with lambda: 1 1 2 3 5 8 13 21 34x: 1 y: 1vector v after 1st call to fillVector(): 1 2 3 4 5 6 7 8 9vector v after 2nd call to fillVector(): 10 11 12 13 14 15 16 17 18 参考：https://msdn.microsoft.com/zh-cn/library/dd293608.aspx document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"C++11","slug":"C-11","permalink":"http://blog.iwxyi.com/tags/C-11/"},{"name":"Lambda","slug":"Lambda","permalink":"http://blog.iwxyi.com/tags/Lambda/"}]},{"title":"VC++ ATL对象的COM组件","date":"2018-06-01T02:05:00.000Z","path":"2018/06/01/VC-ATL对象的COM组件/","text":"使用 ATL 开发和调用 COM 组件 12345678910111213141516171819202122232425262728293031323334353637383940414243#include \"stdafx.h\"#include \"ATL1.h\"#include \"ATL1_i.c\"int main(){ ITest * pITest; HRESULT hResult; if (CoInitialize(NULL) != S_OK) { printf(\"Initialize COM library failed!n\"); return -1; } GUID ATL1CLSID; hResult = ::CLSIDFromProgID(L\"ATL1.Test\", &amp;ATL1CLSID); if (hResult != S_OK) { printf(\"Can't find the ATL1 CLSID!n\"); return -2; } hResult = CoCreateInstance(ATL1CLSID, NULL, CLSCTX_INPROC_SERVER, IID_ITest, (void **)&amp;pITest); if (hResult != S_OK) { printf(\"Create object failed!n\"); return -2; } printf(\"Call ITest interface's functions...n\"); double k; double *ans = &amp;k; pITest-&gt;getArea(3, 4, 5, ans); printf(\"3,4,5=%.2lfn\",*ans); printf(\"Test over...n\"); pITest-&gt;Release(); CoUninitialize(); return 0;} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"VC++","slug":"VC","permalink":"http://blog.iwxyi.com/tags/VC/"}]},{"title":"HTML解决英文段落不换行","date":"2018-05-28T05:09:00.000Z","path":"2018/05/28/HTML解决英文段落不换行/","text":"加上这2个属性其中之一，就可以实现换行了。 word-break : break-all; 只对英文起作用，以字母作为换行依据 word-wrap : break-word; 只对英文起作用，以单词作为换行依据 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"HTML","slug":"HTML","permalink":"http://blog.iwxyi.com/tags/HTML/"}]},{"title":"嵌套循环优化","date":"2018-05-20T11:50:00.000Z","path":"2018/05/20/嵌套循环优化/","text":"题目请对以下的代码进行优化： 1234for (int i = 0; i &lt; 1000; i++) for (int j = 0; j &lt; 100; j++) for (int k = 0; k &lt; 10; k++) testFunction (i, j, k); 分析从给出的代码可知，不论如何优化，testFunction执行的次数都是相同的，该部分不存在优化的可能。那么，代码的优化只能从循环变量i、j、k的实例化、初始化、比较、自增等方面的耗时上进行分析。 首先，我们先分析原题代码循环变量在实例化、初始化、比较、自增等方面的耗时情况： 变量 实例化(次数) 初始化(次数) 比较(次数) 自增(次数) i 1 1 1000 1000 j 1000 1000 1000 * 100 1000 * 100 k 1000 * 100 1000 * 100 1000 * 100 * 10 1000 * 100 * 10 该代码的性能优化就是尽可能减少循环变量i、j、k的实例化、初始化、比较、自增的次数，同时，不能引进其它可能的运算耗时。 方案1234for (int i = 0; i &lt; 10; i++) for (int j = 0; j &lt; 100; j++) for (int k = 0; k &lt; 1000; k++) testFunction (k, j, i); 该方案主要是将循环次数最少的放到外面，循环次数最多的放里面，这样可以最大程度的（注：3个不同次数的循环变量共有6种排列组合情况，此种组合为最优）减少相关循环变量的实例化次数、初始化次数、比较次数、自增次数，方案耗时情况如下： 变量 实例化(次数) 初始化(次数) 比较(次数) 自增(次数) i 1 1 10 10 j 10 10 10 * 100 10 * 100 k 10 * 100 10 * 100 10 * 100 * 1000 10 * 100 * 1000 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"C","slug":"C","permalink":"http://blog.iwxyi.com/tags/C/"},{"name":"优化","slug":"优化","permalink":"http://blog.iwxyi.com/tags/优化/"}]},{"title":"Android SharedPreferences 存取 JavaBean 或 List Bean","date":"2018-05-17T02:55:00.000Z","path":"2018/05/17/Android-SharedPreferences-存取-JavaBean-或-List-Bean/","text":"1. 存储单个JavaBean12345678910SharedPreferences sp = getSharedPreferences(\"SP_PEOPLE\",Activity.MODE_PRIVATE);//创建sp对象,如果有key为\"SP_PEOPLE\"的sp就取出，否则就创建一个此key的sp对象People people= new People() ;//创建javabean对象people.setId(1); people.setName(\"小邵\");Gson gson = new Gson(); String jsonStr=gson.toJson(people); //将对象转换成Jsoneditor = sp.edit() ;editor.putString(\"KEY_PEOPLE_DATA\", jsonStr) ; //存入json串editor.commit() ; //提交ShowDialog(\"您已经保存成功\"); 2. 存储JavBean的List集合1234567891011121314151617SharedPreferences sp = getSharedPreferences(\"SP_PEOPLE_List\",Activity.MODE_PRIVATE);//创建sp对象List&lt;People&gt; peopleList = new ArrayList&lt;People&gt;() ; //创建List集合对象People people1= new People() ;//创建javabean对象people1.setId(1); people1.setName(\"小邵\"); People people2= new People() ;//创建javabean对象people2.setId(2); people2.setName(\"小林\"); peopleList.add(people1);peopleList.add(people2);Gson gson = new Gson(); String jsonStr=gson.toJson(peopleList); //将List转换成JsonSharedPreferences.Editor editor = sp.edit() ;editor.putString(\"KEY_PEOPLE_LIST_DATA\", jsonStr) ; //存入json串editor.commit() ; //提交ShowDialog(\"您已经保存成功\"); 3. 从SP中查询一个JavaBean1234567SharedPreferences sp = getSharedPreferences(\"SP_PEOPLE\",Activity.MODE_PRIVATE);//创建sp对象,如果有key为\"SP_PEOPLE\"的sp就取出peopleJson = sp.getString(\"KEY_PEOPLE_DATA\",\"\"); //取出key为\"KEY_PEOPLE_DATA\"的值，如果值为空，则将第二个参数作为默认值赋值if(peopleJson!=\"\") //防空判断{Gson gson = new Gson(); People people = gson.fromJson(peopleJson, People.class); //将json字符串转换成 people对象} 4. 从SP中查询javaBean集合1234567SharedPreferences sp = getSharedPreferences(\"SP_PEOPLE_LIST\",Activity.MODE_PRIVATE);//创建sp对象,如果有key为\"SP_PEOPLE\"的sp就取出peopleListJson = sp.getString(\"KEY_PEOPLE_LIST_DATA\",\"\"); //取出key为\"KEY_PEOPLE_DATA\"的值，如果值为空，则将第二个参数作为默认值赋值if(peopleJson!=\"\") //防空判断{Gson gson = new Gson(); List&lt;People&gt; peopleList = gson.fromJson(peopleListJson, new TypeToken&lt;List&lt;People&gt;&gt;() {}.getType()); //将json字符串转换成List集合} 5. 删除一个JavaBean直接把sp干掉。 12345SharedPreferences sp = getSharedPreferences(\"SP_PEOPLE\",Activity.MODE_PRIVATE);//创建sp对象,如果有key为\"SP_PEOPLE\"的sp就取出peopleJson = sp.getString(\"KEY_PEOPLE_DATA\",\"\"); SharedPreferences.Editor editor = sp.edit() ;editor.clear();editor.commit(); 6. 删除List中的某个javaBean1.先取，2.转换成List，3.从List中删掉，4.转换成新List,5.存入新json串将原先的替换掉。 1234567891011121314SharedPreferences sp = getSharedPreferences(\"SP_PEOPLE_LIST\",Activity.MODE_PRIVATE);peopleListJson = sp.getString(\"KEY_PEOPLE_LIST_DATA\",\"\"); if(peopleJson!=\"\") //防空判断{Gson gson = new Gson(); List&lt;People&gt; peopleList = gson.fromJson(peopleListJson, new TypeToken&lt;List&lt;People&gt;&gt;() {}.getType()); //1.2\\. 取出并转换成ListpeopleList.remove(position) ; //3.移除第position个的javabeanString jsonStr=gson.toJson(peopleList); //4.将删除完的List转换成JsonSharedPreferences.Editor editor = sp.edit() ;editor.putString(\"KEY_PEOPLE_LIST_DATA\", jsonStr) ; //存入json串editor.commit() ; //提交} 7. 更新先取，将要改变的bean更新了 ，转换成List，存入新json串将原先的替换掉。 1234567891011121314SharedPreferences sp = getSharedPreferences(\"SP_PEOPLE_LIST\",Activity.MODE_PRIVATE);peopleListJson = sp.getString(\"KEY_PEOPLE_LIST_DATA\",\"\"); if(peopleJson!=\"\") //防空判断{Gson gson = new Gson(); List&lt;People&gt; peopleList = gson.fromJson(peopleListJson, new TypeToken&lt;List&lt;People&gt;&gt;() {}.getType()); //取出**// 省略的操作：取出，更新bean的操作，添加到List,将新List转换成json**SharedPreferences.Editor editor = sp.edit() ;editor.putString(\"KEY_PEOPLE_LIST_DATA\", jsonStr) ; //存入json串editor.commit() ; //提交} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Android","slug":"Android","permalink":"http://blog.iwxyi.com/tags/Android/"}]},{"title":"Android users-permission与permission的区别","date":"2018-05-15T03:26:00.000Z","path":"2018/05/15/Android-users-permission与permission的区别/","text":"&lt;uses-permission android:name=\"android.permission.CALL_PHONE\" /&gt;官方权限，会显示在应用权限那里是调用别人的东西自己需要声明的权限与 application 节点同级 &lt;permission android:name=\"android.permission.CALL_PHONE\" /&gt;可以供其他应用使用本应用的说明在 application 节点里面 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Android","slug":"Android","permalink":"http://blog.iwxyi.com/tags/Android/"}]},{"title":"Android Intent拨号","date":"2018-05-15T02:45:00.000Z","path":"2018/05/15/Android-Intent拨号/","text":"Intent 拨号权限：&lt;uses-permission android:name=\"android.permission.CALL_PHONE\" 1234567891011121314151617public void gotoCall(View v){ EditText et = findViewById(R.id.phone); String num = et.getText().toString(); if (num.equals(\"\")) Toast.makeText(this, \"no num\", Toast.LENGTH_SHORT).show(); else startCall(num);}public void startCall(String num){ Intent intent = new Intent(); intent.setAction(Intent.ACTION_CALL); intent.setData(Uri.parse(\"tel:\" + num)); startActivity(intent);} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Android","slug":"Android","permalink":"http://blog.iwxyi.com/tags/Android/"}]},{"title":"MFC常用控件","date":"2018-05-15T02:10:00.000Z","path":"2018/05/15/MFC常用控件/","text":"静态文本框1m_stext.SetWindowTextW(TEXT(\"Hello\")); 编辑框基本函数123456m_Edit1.SetSel(0,-1); //表示选中编辑框IDC_EDIT1中的全部内容。m_Edit1.ReplaceSel(\"\"); //用空字符串代替所选中的文本，即把所选的文本删除掉m_Edit1.Copy(); //将m_Editl编辑框中所选的内容拷贝到剪贴板上m_Edit2.Paste(); //将剪贴板中的内容粘贴到m_Edit2编辑框中m_Edit1.Undo(); // Undo（）函数是CEdit类中的成员函数，表示取消编辑框中上一次操作m_Edit1.GetWindowText(str, 10); // 将内容放到字符串上，参数2是长度（包括\\0） 数值与控件转换IDC_EDIT1 绑定 int 变量 m_A 123456UpdateData(TRUE); // 刷新成数值int i=m_A*m_B;m_Result.Format(\"%d\", i);UpdateData(FALSE); // 刷新回控件 图像框12 组框 Group Box12 按钮按下按钮 1m_btn1.SetWindowText(\"你已按下了按钮！\"); 复选框1234if(m_chk1.GetCheck()&gt;0) m_chk1.SetCheck(0); else m_chk1.SetCheck(1); 单选框按下单选框1m_rad1.SetCheck(1); 初始化选中给一组单选按钮中的一个指定按钮加上选中标志，并且清除组中其他按钮的选中标志。 1BOOL CheckRadioButton([HWND hDlg,] int nlDFirstButton, int nlDLastBUtton, int nlDCheckButton) 获取状态12345int iSexRADIO = GetCheckedRadioButton(IDC_BOY_RADIO, IDC_GIRL_RADIO); // 参数是第一个和最后一个if (iSexRADIO == IDC_BOY_RADIO) ;else ; 组合框初始化时添加下拉列表框项目1m_cb.AddString(\"Monday\"); // 添加项目 初始化时选中字符串SelectString：搜索在组合框的列表框中的字符串，如果找到该字符串，选择列表框和复制的字符串到编辑控件。 1m_Combo.SelectString(-1, \"a\"); // 参数1：从0开始的索引，-1为全部；参数2：搜索词，区分大小写 获取并弹出选中项目123CString msg;m_cb.GetLBText(m_cb.GetCurSel(), msg);AfxMessageBox(msg); 列表框12 水平滚动条12 垂直滚动条12 旋转 Spin滑块的滚动事件在对话框的事件里，与其他控件不同。为什么？它就是这样设计的。 初始化 12CSpinButtonCtrl* pSpin =(CSpinButtonCtrl*) GetDlgItem(IDC_SPIN1);pSpin-&gt;SetRange(0, 100); 滚动事件 12345678910void CTestDlg::OnVScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar) { if (pScrollBar-&gt;GetDlgCtrlID() == IDC_SPIN1) { CString strValue; strValue.Format(\"%3.1f\", (double) nPos / 10.0); // 共3位，小数点后1位 ( (CSpinButtonCtrl*) pScrollBar )-&gt;GetBuddy()-&gt;SetWindowText(strValue); } CDialog::OnVScroll(nSBCode, nPos, pScrollBar);} 进度条 Progress1234CProgressCtrl* pProg = (CProgressCtrl*) GetDlgItem(IDC_PROGRESS1);pSlide1-&gt;SetRange(0, 100); // 范围pProg-&gt;SetPos(0); // 进度=0pProg-&gt;SetPos( pProg-&gt;GetPos()+1 ); // 获取进度并+1 滑块滑块事件也是在对话框滚动事件里面。 12345678910void CTestDlg::OnHScroll(UINT nSBCode, UINT nPos, CScrollBar* pScrollBar) { if(pScrollBar-&gt;GetDlgCtrlID() == IDC_SLIDER1) { CSliderCtrl* pSlide = (CSliderCtrl*) pScrollBar; CString strText; strText.Format(\"%d\", pSlide-&gt;GetPos()); SetDlgItemText(IDC_STATIC_SLIDER, strText); // 滑块位置显示到编辑框里 }} 热键12 列表控件初始化 123456789101112131415static char * color[] = {\"white\",\"black\",\"red\",\"blue\",\"yellow\",\"cyan\",\"purple\",\"green\"};HICON hIcon[8];int n;m_imageList.Create(16,16,0,8,8); hIcon[0] = AfxGetApp()-&gt;LoadIcon(IDI_ICON_WHITE);hIcon[1] = ...略...for (n=0;n&lt;8;n++) m_imageList.Add(hIcon[n]);CListCtrl* pList = (CListCtrl*) GetDlgItem(IDC_LIST1); // 获得控件对象pList-&gt;SetImageList(&amp;m_imageList, LVSIL_SMALL); // 设置小图标图片列表for (n = 0; n &lt; 8; n++) pList-&gt;InsertItem(n, color[n], n); // 第一个参数为项id，第二个为标签文字，第三个为对应图片列表idpList-&gt;SetBkColor(RGB(0, 255, 255)); // 设置背景色pList-&gt;SetTextBkColor(RGB(255, 0, 255)); //设置文字的背景色 事件 12345678910111213141516171819202122232425262728293031323334353637void CTestDlg::OnItemchangedList1(NMHDR* pNMHDR, LRESULT* pResult) // 选中，修改用来显示的标签{ NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR; CListCtrl* pList = (CListCtrl*) GetDlgItem(IDC_LIST1); int nSelected = pNMListView-&gt;iItem; if (nSelected &gt;= 0) { CString strItem = pList-&gt;GetItemText(nSelected, 0); SetDlgItemText(IDC_STATIC_LIST, strItem); } *pResult = 0;}void CTestDlg::OnRclickList1(NMHDR* pNMHDR, LRESULT* pResult) // 右键修改成输入文本{ NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR; CListCtrl* pList = (CListCtrl*) GetDlgItem(IDC_LIST1); int nSelected = pNMListView-&gt;iItem; if (nSelected &gt;= 0) pList-&gt;EditLabel(nSelected); *pResult = 0;}void CTestDlg::OnEndlabeleditList1(NMHDR* pNMHDR, LRESULT* pResult) // 选中后并单击编辑{ LV_DISPINFO* pDispInfo = (LV_DISPINFO*)pNMHDR; LVITEMA item = pDispInfo-&gt;item; CString str =item.pszText; str.TrimLeft(); str.TrimRight(); if(str.GetLength() &gt; 0) { CListCtrl* pList = (CListCtrl*) GetDlgItem(IDC_LIST1); pList-&gt;SetItemText(item.iItem, item.iSubItem, item.pszText); } *pResult = 0;} 树状控件1234567891011121314151617181920212223242526272829303132333435363738394041424344CTreeCtrl* pTree = (CTreeCtrl*) GetDlgItem(IDC_TREE1);pTree-&gt;SetImageList(&amp;m_imageList, TVSIL_NORMAL); // 设置图片列表TV_INSERTSTRUCT tvinsert; // 创建待插入的TV_INSERTSTRUCT结构tvinsert.hParent = NULL; // 无父结点tvinsert.hInsertAfter = TVI_LAST; // 插入到本层最后tvinsert.item.mask = TVIF_IMAGE | TVIF_SELECTEDIMAGE| TVIF_TEXT; // 掩码包括 图标 选中图标 文字tvinsert.item.hItem = NULL; // 句柄为空tvinsert.item.state = 0; // 状态tvinsert.item.stateMask = 0; // 状态掩码，不使用这两项tvinsert.item.cchTextMax = 6; // 最大文字长度，忽略tvinsert.item.iSelectedImage = 1; // 选中图标索引tvinsert.item.cChildren = 0; // 没有子节点tvinsert.item.lParam = 0; // 自定义数据// 第一层tvinsert.item.iImage = 2; // 一般图标tvinsert.item.pszText = \"father\"; // 插入第一层第一个节点\"father\"HTREEITEM hDad = pTree -&gt;InsertItem(&amp;tvinsert);tvinsert.item.pszText = \"mother\"; // 插入第一层第二个节点\"mother\"HTREEITEM hMom = pTree-&gt;InsertItem(&amp;tvinsert);// 创建第二层tvinsert.hParent = hDad; // 父节点为\"father\"tvinsert.item.iImage = 3; // 一般图标tvinsert.item.pszText = \"son\"; // 插入第二层\"father\"的第一个节点\"son\"pTree-&gt;InsertItem(&amp;tvinsert);tvinsert.item.pszText = \"daughter\"; // 插入第二层\"father\"的第二个节点\"daughter\"pTree-&gt;InsertItem(&amp;tvinsert);// 还是创建第二层，但是父节点变成 Momtvinsert.hParent = hMom; // 父结点为\"mother\"tvinsert.item.iImage = 4;tvinsert.item.pszText = \"cartoon\"; // 插入第二层\"mother\"的节点\"cartoon\"HTREEITEM hOther = pTree-&gt;InsertItem(&amp;tvinsert);// 创建第三层tvinsert.hParent = hOther; // 连续不断地创建 事件 1234567891011121314151617181920212223242526272829303132void CTestDlg::OnSelchangedTree1(NMHDR* pNMHDR, LRESULT* pResult) // 被选中，修改选中项的图标{ NM_TREEVIEW* pNMTreeView = (NM_TREEVIEW*)pNMHDR; CTreeCtrl* pTree = (CTreeCtrl*) GetDlgItem(IDC_TREE1); HTREEITEM hSelected = pNMTreeView-&gt;itemNew.hItem; if (hSelected != NULL) { char text[31]; TV_ITEM item; item.mask = TVIF_HANDLE | TVIF_TEXT; item.hItem = hSelected; item.pszText = text; item.cchTextMax = 30; VERIFY(pTree-&gt;GetItem(&amp;item)); SetDlgItemText(IDC_STATIC_TREE, text); } *pResult = 0;}void CTestDlg::OnEndlabeleditTree1(NMHDR* pNMHDR, LRESULT* pResult) // 选中后并单击编辑{ TV_DISPINFO* pTVDispInfo = (TV_DISPINFO*)pNMHDR; TVITEMA item = pTVDispInfo-&gt;item; CString str =item.pszText; str.TrimLeft(); str.TrimRight(); if(str.GetLength() &gt; 0) { CTreeCtrl* pTree = (CTreeCtrl*) GetDlgItem(IDC_TREE1); pTree-&gt;SetItemText(item.hItem,item.pszText); } *pResult = 0;} Tab控件12 动画12 富文本 Rich Edit12 月历12 日期时间选择器12345678CDateTimeCtrl* pDT =(CDateTimeCtrl*) GetDlgItem(IDC_DATETIMEPICKER1);CString formatStr= _T(\"'今天是: 'yy'/'MM'/'dd\");pDT-&gt;SetFormat(formatStr); // 设置控件内容的格式CTime t;pDT-&gt;GetTime(t);CString s = t.Format( \"%A, %B %d, %Y %H:%M:%S\" );AfxMessageBox(s); IP地址12 自定义控件12 扩展组合框12 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"MFC","slug":"MFC","permalink":"http://blog.iwxyi.com/tags/MFC/"}]},{"title":"VC++复制控件","date":"2018-05-15T01:35:00.000Z","path":"2018/05/15/VC-复制控件/","text":"vc中如何拷贝一个工程的对话框资源到另一个工程中? 方法一：在你的工程中添加另一个工程的rc文件，这时资源视图中就会出现两个rc,从后加的rc中拷贝资源到你自己工程的rc中就可以了。 在VC6环境下，选择Class视图，选中想要克隆的对话框所对应的类，例如CAboutDlg，点击鼠标右键，选择Add to gallery。在新工程中选择Project菜单，选择Add Component and ActivX，你会看到多了一个文件夹（与上一个工程同名），进入该文件夹，选择*.ogx。选择Insert，你会发现原来的对话框被加入到新的工程中了！ 补充： .net下更简单，将原来的工程加到新的工程中，直接将对话框拷贝过去就行了！ VC++中如何复制对话框资源 第一步：用记事本打开原工程的.rc文件，找到想复制的对话框的信息，如下所示 123456789101112131415161718192021222324252627IDD_UGMS_DIALOGDIALOGEX 0, 0, 320, 230STYLE WS_CHILD | WS_VISIBLEEXSTYLE WS_EX_APPWINDOWFONT 9, \"宋体\"BEGIN GROUPBOX \"学生信息\",IDC_STATIC,10,8,290,200 GROUPBOX \"\",IDC_STATIC,25,55,205,120 PUSHBUTTON \"最前(&amp;F)\",IDC_BUTTON_FIRST,30,30,35,15 PUSHBUTTON \"向前(&amp;B)\",IDC_BUTTON_PRE,82,30,35,15 PUSHBUTTON \"向后(&amp;N)\",IDC_BUTTON_NEXT,134,30,35,15 PUSHBUTTON \"最后(&amp;L)\",IDC_BUTTON_LAST,186,30,35,15 PUSHBUTTON \"查询(&amp;Q)\",IDC_BUTTON_QUERY,246,70,40,15 PUSHBUTTON \"增加(&amp;A)\",IDC_BUTTON_ADD,246,96,40,15 PUSHBUTTON \"修改(&amp;M)\",IDC_BUTTON_MODIFY,246,122,40,15 PUSHBUTTON \"删除(&amp;D)\",IDC_BUTTON_DELETE,246,148,40,15 PUSHBUTTON \"确定(&amp;O)\",IDC_BUTTON_OK,58,183,40,15 PUSHBUTTON \"取消(&amp;C)\",IDC_BUTTON_CANCEL,150,183,40,15 LTEXT \"学号：\",IDC_STATIC,52,75,25,8 LTEXT \"姓名：\",IDC_STATIC,52,100,25,8 LTEXT \"性别：\",IDC_STATIC,52,125,25,8 LTEXT \"入学时间：\",IDC_STATIC,44,151,41,8 EDITTEXT IDC_EDIT_SID,91,72,95,15,ES_AUTOHSCROLL EDITTEXT IDC_EDIT_SNAME,91,96,95,15,ES_AUTOHSCROLL EDITTEXT IDC_EDIT_SSEX,91,120,95,15,ES_AUTOHSCROLL CONTROL \"DateTimePicker1\",IDC_DATETIMEPICKER_SCOMEDATE, \"SysDateTimePick32\",DTS_RIGHTALIGN | WS_TABSTOP,91,144, 95,15 GROUPBOX \"\",IDC_STATIC,25,19,205,35END 上面代码中绿色背景代表的是要复制的对话框资源的ID，此段代码也就是.rc文件中记录的此对话框的信息，黄色背景中间的代码就是 相应对话框中添加的控件信息，只需将相应代码拷到新工程的相应.rc文件相应的ID对话框资源的BEGIN 和END之间即可； 第二步：打开原工程的FileView视图下的Header Files 下的resource.h文件，将其中相应ID的信息复制到新工程的resource.h中即可； 例如： 123456789101112131415//复制的资源ID#define IDC_BUTTON_FIRST 1000#define IDC_BUTTON_PRE 1001#define IDC_BUTTON_NEXT 1002#define IDC_BUTTON_LAST 1003#define IDC_BUTTON_QUERY 1004#define IDC_BUTTON_ADD 1005#define IDC_BUTTON_MODIFY 1006#define IDC_BUTTON_DELETE 1007#define IDC_BUTTON_OK 1008#define IDC_BUTTON_CANCEL 1009#define IDC_EDIT_SID 1010#define IDC_EDIT_SNAME 1011#define IDC_EDIT_SSEX 1012#define IDC_DATETIMEPICKER_SCOMEDATE 1013 第三步：记得不要遗漏啊，如有ID重复，可以更改一下即可！ 法4： 今天碰到模块移植问题了,自己做的对话框类(继承于CDialog)要移植到目标工程中.在网上搜了几个帖子发现都说的很生涩.问了我们的技术总监之后总算解决这个问题了. 问题:把一个MFC SDI工程中的一个对话框资源和类拷贝到另一个MFC SDI中. 1.在VC6中打开老的工程,在工作区Resource标签页中选中Dialog文件夹下的资源文件(就是双击后会出现编辑窗口界面的那个东西),按Ctrl+C(Edit-&gt;Copy也一样). 2.关闭当前工程,注意不要关闭VC6,打开目标工程(File-&gt;OpenWorkspace),然后选中工作区的Resource标签页中的Dialog文件夹,然后按Ctrl+V(Edit-&gt;Paste也一样).好了,对话框拷贝过来了. 3.将对话框类的cpp h文件拷贝到目标工程中(不详细说了,往当前工程添加文件) 4.打开复制过来的类cpp和h文件,删除没用的头文件(老工程相关的),并且在.h文件中添加文件包含 #include “Resource.h” 第四步很关键,老工程中根本就没有这个文件包含,可是移植之后必须手动添加头文件包含.因为这个问题卡了10几分钟… 当你用资源ID时（通常资源编辑器编辑的资源ID都在resource.h中），如果没有包含CWinApp的派生类所在的头文件就会出错，你看一下它的头文件里，包含了这个文件， 而向导生成的类，它的实现文件都有包含CWinApp派生类所在的头文件的 然后在新工程中就可以使用这个类了,主要就是这个类的对话框中的资源复制头一次遇到.不敢独享,拿出来跟新手们一起学习. 于是，当有已经创建好的对话框资源要添加到新工程中时： （1）右键单击新工程所在的解决方案添加“现有项目”把旧工程添加进来； （2）切换到“资源视图”并在旧工程对话框资源上右键“复制”； （3）在新工程对话框资源上右键“粘贴”； （4）现在就可以为新对话框添加类了，顺便把旧工程的响应函数拷贝过来； （5）切换回“解决方案资源管理器”，右键旧工程“移除”。 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"VC++","slug":"VC","permalink":"http://blog.iwxyi.com/tags/VC/"}]},{"title":"VC++动态链接库DLL","date":"2018-05-15T01:32:00.000Z","path":"2018/05/15/VC-动态链接库DLL/","text":"隐式链接 用特殊声明 _declspec(dllexport) 定义一个导出函数 1234567891011#include \"stdafx.h\"_declspec(dllexport) long square (long x) // 导出标记{ return x * x;}BOOL APIENTRY DllMain(HANDLE hModule, DWORD ul_reason_for_call, LPVOID lpReserved){ return TRUE;} 编译、链接, 生成.Dll文件和.Lib文件，并拷贝到客户端目录 工程设置里，exe 关联 .Lib 文件 注：是源文件所在目录，而不是Debug文件夹 使用特殊声明 _declspec(dllimport) 声明导出函数并调用 12345678910111213#include \"stdafx.h\"#include &lt;iostream&gt;using namespace std;_declspec(dllimport) long square(long x); // 导入标记int main(int argc, char* argv[]){ int x; cin &gt;&gt; x; cout &lt;&lt; square(x) &lt;&lt; endl; return 0;} 显示链接 定义一个函数：bool __stdcall square(long x); 1234567891011#include \"stdafx.h\"long _stdcall square (long x){ return x * x;}BOOL APIENTRY DllMain(HANDLE hModule, DWORD ul_reason_for_call, LPVOID lpReserved){ return TRUE;} 通过 .def 文件导出函数并防止函数名被修饰。 12345LIBRARY \"dll1\"EXPORTS square @1 ;函数 [@序号] dll 文件放在 exe 运行目录下（例如：Debug） 通过3个API函数直接调用.DLL中的导出函数。 HMODULE LoadLibrary(LPCTSTR lpFileName); // 获取 dll 句柄 FARPROC GetProcAddress(HMODULE hModule, LPSCTR lpProcName); // 加载 dll 函数 BOOL FreeLibrary(HMODULE hModule); // 释放 dll 空间 1234567891011121314151617181920212223242526272829303132#include \"stdafx.h\"#include &lt;iostream&gt;#include &lt;windows.h&gt;using namespace std;typedef long (_stdcall * LF) (long);int main(int argc, char* argv[]){ HMODULE hModule = LoadLibrary(\"dll1\"); if (!hModule) { cout &lt;&lt; \"NONE HMODULE\" &lt;&lt; endl; return -1; } LF lf = (LF) GetProcAddress(hModule, \"square\"); if (!lf) { cout &lt;&lt; \"NONE FUNCTION\" &lt;&lt; endl; return -1; } int x; cin &gt;&gt; x; cout &lt;&lt; lf(x) &lt;&lt; endl; FreeLibrary(hModule); return 0;} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"VC++","slug":"VC","permalink":"http://blog.iwxyi.com/tags/VC/"}]},{"title":"Android动态获取权限","date":"2018-05-14T03:11:00.000Z","path":"2018/05/14/Android动态获取权限/","text":"在6.0 系统中请求某些权限需要检查权限 下面以拨打电话为例 123456789101112131415if (!TextUtils.isEmpty(phone)) { if (!hasPermission()) { // 在6.0 系统中请求某些权限需要检查权限 int curApiVersion = Build.VERSION.SDK_INT; if (curApiVersion &gt;= Build.VERSION_CODES.M) { // 动态请求拨打电话权限 requestPermissions( new String[] { Manifest.permission.CALL_PHONE }, 0x11); } else { intentToCall(phone); } } else { intentToCall(phone); }} 12345678910111213141516171819202122232425262728293031323334private boolean hasPermission() { if (checkSelfPermission(Manifest.permission.CALL_PHONE) != PackageManager.PERMISSION_GRANTED) { return false; } return true; } private void intentToCall(String phoneNumber) { Intent intent = new Intent(Intent.ACTION_CALL); Uri data = Uri.parse(\"tel:\" + phoneNumber); intent.setData(data); startActivity(intent); } /** * 动态请求拨打电话权限后，监听用户的点击事件 */ @Override public void onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults) { super.onRequestPermissionsResult(requestCode, permissions, grantResults); if (requestCode == 0x11) { // If request is cancelled, the result arrays are empty. if (grantResults.length &gt; 0 &amp;&amp; grantResults[0] == PackageManager.PERMISSION_GRANTED) { CldLog.i(\"CMCC\", \"权限被允许\"); String phone = mContactsInfo.getPhone(); intentToCall(phone); } else { CldLog.i(\"CMCC\", \"权限被拒绝\"); } } } document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Android","slug":"Android","permalink":"http://blog.iwxyi.com/tags/Android/"}]},{"title":"Android获取IMEI码","date":"2018-05-10T03:15:00.000Z","path":"2018/05/10/Android获取IMEI码/","text":"12345import android.telephony.TelephonyManager;public String getIMEI() { return ((TelephonyManager) mainActivity.getContext().getSystemService(\"phone\")).getDeviceId();} 需要权限 &lt;uses-permission android:name=\"android.permission.READ_PHONE_STATE\" /&gt; document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Android","slug":"Android","permalink":"http://blog.iwxyi.com/tags/Android/"}]},{"title":"MFC画图","date":"2018-05-08T02:14:00.000Z","path":"2018/05/08/MFC画图/","text":"MFC在控件上画图 1234567891011121314CStatic* p;p = (CStatic*)GetDlgItem(IDC_STATIC);CRect rcStatic;p-&gt;GetClientRect(&amp;rcStatic);HDC hdc = ::GetDC(*p);HPEN hPen;OLE_COLOR m_colOLE;COLORREF m_colRREF;m_colOLE = RGB(255, 0, 0);OleTranslateColor(m_colOLE, NULL, &amp;m_colRREF);hPen = CreatePen(PS_SOLID, 3, m_colRREF);SelectObject(hdc, hPen);Rectangle(hdc, rcStatic.left, rcStatic.top, rcStatic.right, rcStatic.bottom); document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"MFC","slug":"MFC","permalink":"http://blog.iwxyi.com/tags/MFC/"}]},{"title":"MFC常用函数","date":"2018-05-08T02:09:00.000Z","path":"2018/05/08/MFC常用函数/","text":"流程控制12OnOK(); // 确定onCancel(); // 取消 通过ID获取控件对象12GetDlgItem(IDC_DATE)-&gt;EnableWindow(FALSE);m_Date.EnableWindow(TRUE); 可视与可用12345EnableWindow(TRUE); // TRUE可用 / FALSE不可用EnableWindow(FALSW); // 变灰，不可操作ShowWindow(SW_HIDE); // 不可视，SW_HIDE=0ShowWindow(SW_SHOW); // 可视，SW_SHOW=5 弹出信息框12345AfxMessageBox(\"Hello World!\");CString msg;m_cb.GetLBText(m_cb.GetCurSel(), msg);AfxMessageBox(msg); 获取现行日期时间123CTime tNow = CTime::GetCurrentTime();CString date = tNow.Format(\"%y.%m.%d\"); // 日期CString time = tNow.Format(\"%I:%M:%S\"); // 时间（小时是I而不是H） 定时器123456789SetTimer(1,100,NULL); // 参数1：定时器ID，参数2：间隔void CEx9_9Dlg::OnTimer(UINT nIDEvent) { if(nIDEvent == 1){ // 定时器的ID ... if(...) KillTimer(nIDEvent); // 结束进程 }} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"MFC","slug":"MFC","permalink":"http://blog.iwxyi.com/tags/MFC/"}]},{"title":"Win32 SDK游戏循环","date":"2018-05-08T02:02:00.000Z","path":"2018/05/08/Win32-SDK游戏循环/","text":"其实就是 Windows 消息循环 12345678910111213141516//消息循环GetMessage(&amp;msg, NULL, NULL, NULL); //初始化msgwhile( msg.message != WM_QUIT ){ if( PeekMessage( &amp;msg, NULL, 0, 0 , PM_REMOVE) ) { TranslateMessage( &amp;msg ); DispatchMessage( &amp;msg ); } else { tNow = GetTickCount(); if(tNow - tPre &gt;= 40) MyPaint(hdc); }} 1tPre = GetTickCount(); document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Win32 SDK","slug":"Win32-SDK","permalink":"http://blog.iwxyi.com/tags/Win32-SDK/"},{"name":"游戏开发","slug":"游戏开发","permalink":"http://blog.iwxyi.com/tags/游戏开发/"}]},{"title":"Win32 SDK加载位图","date":"2018-05-08T01:52:00.000Z","path":"2018/05/08/Win32-SDK加载位图/","text":"初始化位图 1234hMemDC = CreateCompatibleDC(hdc);hBitmap = LoadBitmap(hInst, \"mybmp\");SelectObject(hMemDC, hBitmap);GetObject(hBitmap, sizeof(BITMAP), &amp;bitmap); 绘制位图 1BitBlt(hdc, bmx, bmy, bitmap.bmWidth, bitmap.bmHeight, hMemDC, 0, 0, SRCCOPY); 1234567891011121314151617181920212223242526272829303132LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam){ HDC hdc; PAINTSTRUCT ps; RECT rect; static HDC hMemDC; static HBITMAP hBitmap; static BITMAP bitmap; switch(message) { case WM_CREATE : // 初始化 hdc = GetDC(hWnd); hMemDC = CreateCompatibleDC(hdc); hBitmap = LoadBitmap(hInst, \"mybmp\"); SelectObject(hMemDC, hBitmap); GetObject(hBitmap, sizeof(BITMAP), &amp;bitmap); ReleaseDC(hWnd, hdc); break; case WM_PAINT : // 重绘 hdc = BeginPaint(hWnd, &amp;ps); GetClientRect(hWnd, &amp;rect); BitBlt(hdc, bmx, bmy, bitmap.bmWidth, bitmap.bmHeight, hMemDC, 0, 0, SRCCOPY); EndPaint(hWnd, &amp;ps); break; case WM_DESTROY : // 析构 DeleteObject(hBitmap); ReleaseDC(hWnd, hMemDC); PostQuitMessage(0); break; }} 两张/多张位图 12345hBitmap = (HBITMAP)LoadImage(NULL,\"mybmp.bmp\",IMAGE_BITMAP,800,800,LR_LOADFROMFILE);hBitmap2 = (HBITMAP)LoadImage(NULL,\"mybmp2.bmp\",IMAGE_BITMAP,50,50,LR_LOADFROMFILE);SelectObject(hMemDC, hBitmap);GetObject(hBitmap, sizeof(BITMAP), &amp;bitmap);GetObject(hBitmap2, sizeof(BITMAP), &amp;bitmap2); document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Win32 SDK","slug":"Win32-SDK","permalink":"http://blog.iwxyi.com/tags/Win32-SDK/"}]},{"title":"VC++工具使用","date":"2018-05-08T01:37:00.000Z","path":"2018/05/08/VC-工具使用/","text":"快捷键：在Button标题处使用&amp;，例如：&amp;Enable快捷键为alt+E，Enable &amp;Again快捷键为alt+A 单选框：按照创建顺序会有一个默认的编号，然后每组第一个radio属性的组设为True，其余radio不做变动。有组的radio显示在类向导里面，并且可以关联int变量，直接初始化成其他值 复制控件：看另外一篇 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"VC++","slug":"VC","permalink":"http://blog.iwxyi.com/tags/VC/"}]},{"title":"VC++菜单操作","date":"2018-05-08T01:16:00.000Z","path":"2018/05/08/VC-菜单操作/","text":"123hmenu = GetMenu(hWnd);haddmenu = CreateMenu();AppendMenu(haddmenu, MF_ENABLED, 4, \"求和\"); 1234567891011121314151617181920212223242526272829LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam){ HMENU hmenu, haddmenu/*添加的菜单句柄*/; switch(message) { case WM_COMMAND : switch (LOWORD(wParam)) { case 1 : // 添加菜单项 hmenu = GetMenu(hWnd); haddmenu = CreateMenu(); AppendMenu(haddmenu, MF_ENABLED, 4, \"求和\"); AppendMenu(haddmenu, MF_ENABLED, 5, \"求差\"); InsertMenu(hmenu, 2, MF_POPUP | MF_BYPOSITION, (UINT)haddmenu, \"统计计算\"); EnableMenuItem(hmenu, 1, MF_GRAYED); EnableMenuItem(hmenu, 2, MF_ENABLED); DrawMenuBar(hWnd); break; case 2 : // 删除菜单项 hmenu = GetMenu(hWnd); DeleteMenu(hmenu, 2, MF_BYPOSITION); EnableMenuItem(hmenu, 1, MF_ENABLED); EnableMenuItem(hmenu, 2, MF_GRAYED); DrawMenuBar(hWnd); break; } break; }} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"VC++","slug":"VC","permalink":"http://blog.iwxyi.com/tags/VC/"}]},{"title":"Win32 SDK事件响应","date":"2018-05-07T02:17:00.000Z","path":"2018/05/07/Win32-SDK事件响应/","text":"按键响应 1234567891011121314151617181920212223242526272829303132LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam){ switch(message) { case WM_CHAR : if (wParam == 'r') // r { ; } else if (wParam == 'r'-96) // ctrl+r { ; } else if (wParam == 'B') // shift+b { ; } break; case WM_KEYDOWN : if (wParam == VK_UP) // UP键 { ; } else if (wParam == VK_CONTROL) // Ctrl键 { ; } break; case WM_KEYUP : // 按键弹起 ; }} 鼠标响应123456789101112131415161718LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam){ switch(message) { case WM_MOUSEMOVE : // 鼠标移动 x = LOWORD(lParam); y = HIWORD(lParam); break; case WM_LBUTTONDBLCLK : // 左键单击 ; case WM_LBUTTONDOWN : // 左键按下 ; case WM_LBUTTONUP : // 左键弹起 ; case WM_RBUTTONDOWN : // 右键按下 ; }} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Win32 SDK","slug":"Win32-SDK","permalink":"http://blog.iwxyi.com/tags/Win32-SDK/"}]},{"title":"MFC编辑框","date":"2018-05-07T02:08:00.000Z","path":"2018/05/07/MFC编辑框/","text":"12345m_Edit1.SetSel(0,-1); //表示选中编辑框IDC_EDIT1中的全部内容。m_Edit1.ReplaceSel(\"\"); //用空字符串代替所选中的文本，即把所选的文本删除掉m_Edit1.Copy(); //将m_Editl编辑框中所选的内容拷贝到剪贴板上m_Edit2.Paste(); //将剪贴板中的内容粘贴到m_Edit2编辑框中m_Edit1.Undo(); // Undo（）函数是CEdit类中的成员函数，表示取消编辑框中上一次操作 数值与控件转换IDC_EDIT1 绑定int变量 m_A 123456UpdateData(TRUE); // 刷新成数值int i=m_A*m_B;m_Result.Format(\"%d\", i);UpdateData(FALSE); // 刷新回控件 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"MFC","slug":"MFC","permalink":"http://blog.iwxyi.com/tags/MFC/"}]},{"title":"VC++使用RC文件","date":"2018-05-07T01:56:00.000Z","path":"2018/05/07/VC-使用RC文件/","text":"## 文件导入的资源（BITMAP， ICON， HTML， FONT， CURSOR） 举例： .rc文件 :#include&lt;windows.h&gt; #include”resource.h” IDI_ICON1 ICON “dlgapp.ico” //ICON RESOURCE Resource.h文件:#define IDI_ICON1 1001 注册窗口类:wcs.hIcon = LoadIcon(g_hInstance, MAKEINTRESOURCE(IDI_ICON1)); 对话框资源见图： img 对应的.rc文件：123456789101112IDD_DIALOG1 DIALOG DISCARDABLE 0, 0, 187, 94STYLE DS_MODALFRAME | WS_POPUP | WS_CAPTION | WS_SYSMENUCAPTION \"对话\"FONT 10, \"System\"_BEGIN_ DEFPUSHBUTTON \"确定\",IDOK,130,7,50,14 PUSHBUTTON \"取消\",IDCANCEL,130,24,50,14_END_ 对应resource.h:#define IDD_DIALOG1 102 对应的.cpp文件：123456voidOnNoModel(HWND hWnd){ HWND hDlg = CreateDialog(g_hInstance,//根据资源创建对话框 MAKEINTRESOURCE(IDD_DIALOG1),hWnd, MyDialogProc); ShowWindow(hDlg,1);//需要显示对话框} 菜单资源：(当然，菜单不使用资源也可以创建的～用命令创建的感觉和QT用命令创建很相似，本文不涉及) 对应的.rc文件：12345678910111213#include\"resource.h\"#include&lt;windows.h&gt;IDR_MENU1 _MENU_ //MENU RESOURCE_BEGIN_ POPUP \"File\" // POPUP RESOURCE _BEGIN_ MENUITEM \"&amp;Open\", ID_FILE_OPEN // MENUITEM STATEMENT MENUITEM \"&amp;Save\", ID_FILE_SAVE // MENUITEM STATEMENT MENUITEM SEPARATOR // MENUITEM STATEMENT MENUITEM \"E&amp;xit\", ID_FILE_EXIT // MENUITEM STATEMENT _END__END_ 对应的resource.h文件：#define IDR_MENU1 1001 #define ID_FILE_OPEN 1003 #define ID_FILE_SAVE 1004 #define ID_FILE_EXIT 1005 对应的.cpp文件：wcs.lpszMenuName = MAKEINTRESOURCE(IDR_MENU1); document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"VC++","slug":"VC","permalink":"http://blog.iwxyi.com/tags/VC/"}]},{"title":"Win32 SDK列出目录下子文件","date":"2018-05-07T01:55:00.000Z","path":"2018/05/07/Win32-SDK列出目录下子文件/","text":"123456DWORD cchCurDir = MAX_PATH; // long类型，最大目录字符长度LPTSTR lpszCurDir; // 指针类型CHAR tchBuffer[MAX_PATH]; // char类型lpszCurDir = tchBuffer; GetCurrentDirectory(cchCurDir, lpszCurDir); // 获取运行目录DlgDirList(lpszCurDir, IDC_LIST_DIR, IDC_STATIC_DIR, 0); // 将目录展示到List 显示List的Item并删除 123456int i = m_list.GetCurSel();CString str;m_list.GetText(i, str); // 获取文字m_list.DeleteString(i); // 删除列表CString msg = \"Item \"+str+\" deleted!\";AfxMessageBox(msg); document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Win32 SDK","slug":"Win32-SDK","permalink":"http://blog.iwxyi.com/tags/Win32-SDK/"}]},{"title":"MFC函数总结","date":"2018-05-07T00:43:00.000Z","path":"2018/05/07/MFC函数总结/","text":"1、MFC编辑框、静态文本框相关的常用函数 《1》GetDlgItemText(ID ,str) 作用：从对话框中获取文本 第一个参数为要获取的编辑框(或者静态文本框、单选按钮等可以显示内容的控件)的ID，第二个参数为字符串(Cstring 类型)的变量，获取的文本存储在str中。 《2》SetDlgItemText(ID,str) 作用：将字符串显示在控件中 第一个参数为要显示的编辑框(或者静态文本框、单选按钮、组合框等可以显示内容的控件)的ID，第二个参数为字符串(Cstring 类型)的变量，显示的文本存储在str中。如果要显示的变量的类型不是Cstring，则通过Format函数强制转换。 通常还要加一个UpDateData(FALSE)。 《3》UINT nID=GetCheckedRadioButton(IDC1, IDC2); 作用：获取单选框的选项的ID 第一个参数为该组合框中第一个单选按钮的ID，第二个参数为该组合框中最后一个按钮的ID。 《4》CheckRadioButton(IDC1, IDC2, IDC3); 作用：初始化单选按钮 第一个参数为该组合框中第一个单选按钮的ID，第二个参数为该组合框中最后一个按钮的ID，第三个参数为为缺省选项的ID。 《5》m_scrollBar.SetScrollRange(0, 500) ; 作用：设置水平滚动条的取值范围，m_scrollBar为水平滚动条的控制类型的变量，0为设置最小值，500为设置的最大值。 《6》m_nAmount = m_slider.GetPos() ; 作用：获取滑块的当前位置。 《7》m_slider.SetRange(0,1000) ; 作用：设置滑块取值范围 第一个参数为设置的最小值，第二个参数为设置的最大值。 《8》double Volum = atof(strCtrl); 作用：将字符串strCtl转换成浮点型的Volum 《9》int Volum = atof(strCtrl); 作用：将字符串strCtl转换成整型的Volum 《10》MessageBox(str) ;（局部函数） 作用：输出字符串str 《11》AfxMessageBox(str) ;（全局函数） 作用：输出字符串str 《12》tempt = m_time2.Format(\"%H:%m:%S\") ; 作用：将时间转化成字符型（时、分、秒） m_time2为日历时间选取器的变量，tempt为CString型变量 《13》tempt = m_time.Format(\"%Y-%m-%d\") ;//将时间转化成字符型 作用：将时间转化成字符型（年、月、日） m_time2为日历时间选取器的变量，tempt为CString型变量 《14》m_time = CTime::GetCurrentTime(); 作用：获取系统当前时间 m_time为Ctime类型的变量。 《15》m_list.AddString(str); 功能：将Cstrig类型的变量的内容显示在列表框中(或者组合框中)。 m_str为ClistBox类型的变量（或者是CcomboBox类型的变量）。 《16》m_time = CTime(2012 ,5 ,28 ,0 ,0 ,0) ; 功能：初始化日期 m_time为Ctime类型的变量 《17》str.TrimLeft(); 功能：去掉Cstring类型变量的左边的空格 《18》str.TrimRight(); 功能：去掉Cstring类型变量的右边的空格 《19》str.IsEmpty(); 功能：判断Cstring类型的变量str是否为空，如果为空则返回1，否则返回零。 《20》int nIndex=m_list.FindString(int k,str); 功能：列表框中查找与str匹配的列表项，m_list为ClistBox类型变量。 从第k个位置开始查找，若为-1，则从头至尾查找。 函数原型： int FindString(int nStartAfter,LPCTSTR lpszItem) const; int FindStringExact(int nIndexStart,LPCTSTR lpszFind) const; 其中，FindStringExact的查找精度最高 《21》m_list.ResetContent() ; 功能：清空列表框中的内容 m_list为ClistBox类型变量。 《22》m_listSearch.DeleteString(int nIndex); 功能：删除列表框中的第nIndex条记录。 m_listSearch为ClistBox类型变量。 《23》GetDlgItem(IDC_BUTTON_DELETE)-&gt;EnableWindow(FALSE); 功能：是ID为IDC_BUTTON_DELETE的按钮灰选。 《24》GetDlgItem(IDC_BUTTON_DELETE)-&gt;EnableWindow(TRUE); 功能：是ID为IDC_BUTTON_DELETE的按钮还原。 《25》str.Left(length); 功能：获取字符串str左边长度为length的值。 《26》int length = str.GetLength() ; 功能：获取字符串str的长度 《27》dlg.DoModal() ; 功能：建立一个对话框 dlg为该对话框的类的对象。 《28》CDialog::OnCancel(); 功能：关闭窗口 《29》CMenu* pSysMenu=GetMenu(); 功能：获取程序菜单指针 《30》int nCount=pSysMenu-&gt;GetMenuItemCount(); 功能：获取项层菜单项的项数 《31》int nIndex=m_ListBox.GetCurSel(); 功能：获取指针在列表框中的位置 m_ListBox为ClistBox类型变量。 《32》GetWindowText(str) ; 功能：获取当前窗口的标题 Str为Cstring 类型的变量 《33》GetDlgItem(IDC_CLICKHERE)-&gt;SetFocus(); 将光标设置在控件IDC_CLICKHERE处,若是在打开某个对话框时候做此设置，则将该语句加到消息处理函数OnInitDialog的return语句前，并且将最后的语句 return TRUE; 该为 return FALSE; GetDlgItem(IDC_CLICKHERE)-&gt;SetFocus();也可写成m_strit.SetFocus(); 其中m_strit为该控件对应的变量。 《34》GetDlgItem(IDC_STATIC_NUMBER1) 功能：获取ID为IDC_STATIC_NUMBER1控件的指针. 例如： 123CString str ;GetDlgItem(IDC_STATIC_NUMBER1)-&gt;GetWindowText(str) ;//此句等价于GetDlgItemText(IDC_STATIC_NUMBER1,str); 《35》int num1 = GetDlgItemInt(IDC_EDIT1); 功能：获取ID为IDC_EDIT1控件的文本并且转化成整形的值，如果文本中含有非数字字符则转化失败. 《36》SetDlgItemInt(IDC_EDIT3,num3) ; 功能：将整数num3显示在ID为IDC_EDIT3的编辑框中. 《37》::SendMessage(GetDlgItem(IDC_EDIT1)-&gt;m_hWnd,WM_GETTEXT,10,(LPARAM)ch1); 注意：在函数前面加上作用域分节符表示调用的是全局函数. 功能：取ID为IDC_EDIT1控件的文本,获取的最大长度为10，并且将获取的内容存储在ch1中.相当于GetDlgItemText(IDC_EDIT1,ch1,10); 说明：第一个参数为对应控件的句柄，第二个参数为消息名称，第三个参数为获取文本的最大长度，第四个参数为存储文本的缓冲区，此处ch1为字符数组,即 char ch1[10];第四个参数的类型必须强制转换成LPARAM. 此函数有多种调用方式，其功能是相同的。列举如下： (1) ::SendMessage(GetDlgItem(IDC_EDIT1)-&gt;m_hWnd,WM_GETTEXT,10,(LPARAM)ch1); (2) GetDlgItem(IDC_EDIT1)-&gt;SendMessage(WM_GETTEXT,10,(LPARAM)ch1); (3) m_edit1.SendMessage(WM_GETTEXT,10,(LPARAM)ch1); (4) ::SendMessage(m_edit1.m_hWnd,WM_GETTEXT,10,(LPARAM)ch1); 其中m_edit1是IDC_EDIT1控件的类别为Control，类型为CEdit的变量. 《38》::SendMessage(GetDlgItem(IDC_EDIT3)-&gt;m_hWnd,WM_SETTEXT,0,(LPARAM)ch3); 功能：将缓冲区ch3的内容显示在D为IDC_EDIT1控件上.其作用相当于SetDlgItemText(IDC_EDIT1,ch1); 说明：第一个参数为对应控件的句柄，第二个参数为消息名称，第三个参数用不上，故设置为零，第四个参数为要显示的文本内容, 第四个参数的类型必须强制转换成LPARAM. 《39》SendDlgItemMessage(IDC_EDIT1,WM_GETTEXT,10,(LPARAM)ch1); 功能等价于::SendMessage(GetDlgItem(IDC_EDIT1)-&gt;m_hWnd,WM_GETTEXT,10,(LPARAM)ch1); 《40》SendDlgItemMessage(IDC_EDIT3,WM_SETTEXT,0,(LPARAM)ch3); 功能等价于::SendMessage(GetDlgItem(IDC_EDIT3)-&gt;m_hWnd,WM_SETTEXT,0,(LPARAM)ch3); 2、常用函数（比较全） WinExec() ExitWindowsEx() GlobalMemoryStatus() GetSystemInfo() GetSystemDirectory() GetWindowsDirectory() GetTaskmanWindow() user32.dll中 获取任务栏窗口句柄 OpenProcessToken() 打开一个进程的访问令牌 GetCurrentProcess() 获取本进程句柄 LookupPrivilegeValue() 修改进程权限 AdjustTokenProvileges() 通知WindowsNT修改本进程权利 CreateRectRgn() CreateEllipticRgnIndirect() PtInRegion() CommandToIndex() ID号转换为索引值 菜单类: DrawMenuBar() 重画菜单 SetDefaultItem() 设置默认菜单项 CheckMenuItem()设置菜单项Check状态 CreatePopupMenu()创建弹出菜单 窗口类: MoveWindow() Invalidate()使窗口无效,窗口无效时会进行窗口重绘 GetParent() 获得窗口的父窗口句柄 BringWindowToTop()把窗口放到顶部 SetWindowPos() DeferWindowPos() SetActiveWindow()激活顶层窗口 Set/GetForegroundWindow() 设置/获取前台窗口,返回句柄 Set/GetWindowLong()改变窗口属性 GetNextWindow()获取下一个窗口句柄 GetWindow() 获取窗口句柄 FromHandle() 通过句柄获取指针 AfxGetInstanceHandle()获取程序当前实例句柄 AfxRegisterWndClass() Set/GetClassLong() Set/GetWindowLong() GetWindowRect()获取窗口在屏幕中的Rect 对话框: GetDlgItem() Set/GetDlgItemText() Set/GetDlgItemInt() Set/GetDlgItem() SendDlgItemMessage() SetFocus()文本编辑框Edit控件若要响应回车按键消息，必须设置为多行类型 GetNextDlgTabItem()获取下一个有TABStop属性的控件句柄 OnCtlColor() WM_CTLCOLOR窗口绘制消息响应函数 GetDlgCtrlID() SetButtonText()设置按钮文本CreateRectRgn GetStartPosition() GetNextPathName() SetHorizontalExtent() SHBrowseForFolder() 属性表单: SetWizardMode() SetWizardButtons() OnSetActive() 工具栏: RecalcLayout() ShowControlBar() 状态栏: CommandToIndex() 根据ID号获取索引值 SetMessageText() GetMessageBar() GetDescendantWindow() 图形类 OnEraseBkgnd() CButton::DrawItem() SetBkMode()设置文字背景 SetTextColor() SetBkColor() SetROP2() SetClipRtn() DrawText() BeginPath() EndPath() BeginPaint() EndPaint() GetTextExtend() SetWorldTransform() GetDeviceCaps() Set/GetViewportOrg() Set/GetWindowOrg() DPtoLP()将设备坐标点转换为逻辑坐标点 LPtoDP()将逻辑坐标点转换为设备坐标点 DeleteMetaFile() CopyMetaFile() GetMetaFile() GetEnhMetaFile() 123456void CView::OnPaint(){ CPaintDC dc(this); OnPrepareDC(&amp;dc); OnDraw(&amp;dc);} 文件操作: EncryptFile() CreateFile() ReadFile() WriteFile() SetFilePointer() ::WriteProfileString() 向win.ini写入相关信息 ::GetProfileString() 从win.ini获取相关信息 CWinApp::WriteProfileString()向注册表中写入相关信息 CWinApp::GetProfileString() 从注册表中获取相关信息 ::WritePrivateProfileString() RegCreateKeyEx()创建注册表项 RegCloseKey()关闭注册表项 RegOpenKeyEx() 打开注册表项 RegSetValueEx() 写入注册表项 RegQueryValueEx() 读取注册表项 RegEnumKeyEx() RegDeleteKey() 文档视图: 钩子: SetWindowsHookEx() CallNextHookEx() UnhookWindowsHookEx() GetCurrentThreadID() GetModuleHandle() 动态库: #pragma data_seg() #pragma comment(linker,\"/section:XXX,RWS\") R可读W可写S共享 SEGMENTS XXX READ WRITE SHARED MAKEINTRESOURCE() GetProcAddress()获取函数地址 LoadLibrary()加载Dll FreeLibrary()减少Dll的引用计数 多线程: CreateThread() CloseHandle() 互斥: CreateMutex() ReleaseMutex() WaitForSingleObject() 事件: CreateEvent() SetEvent() 设置有信号状态 ResetEvent() 设置无信号状态 临界区: EnterCriticalSection() InitializeCriticalSection() LeaveCriticalSection() DeleteCriticalSection() 异步套接字: WSAAsyncSelect() 为一个套接字请求网络消息通知 WSAEnumProtocols()检索可用的网络通信协议 WSASocket() 剪贴板: OpenClipboard() 打开剪贴板 CloseClipboard()关闭剪贴板 EmptyClipboard()清空剪贴板 SetClipboardData() GetClipboardData() GlobalAlloc() GlobalLock() GlobalUnlock() IsClipboardFormatAvailable() 匿名管道: CreatePipe() CreateProcess() CreateFile() ReadFile() WriteFile() 命名管道: CreateNamedPipe() ConnectNamedPipe() WaitNamedPipe() CreateFile() ReadFile() WriteFile() 邮槽: CreateMailslot() 多媒体: mciSendCommand() &lt;mmsystem.h&gt; 窗口、控件的指针和句柄的相互转化 1指针转化为句柄 在MFC应用程序中首先要获得窗口的指针，然后将其转化为句柄 12CWnd* pWnd;HANDLE hWnd = pWnd-&gt;GetSafeHwnd(); 2句柄转化为指针 在MFC应用程序中首先获得对话框控件的句柄，然后获得其指针 123HANDLE hWnd;GetDlgItem(IDC_xxx,&amp;hWnd);CWnd * pWnd = FromHandle(hWnd); 获得程序窗口指针的办法 1获得主框架窗口指针(任何时候都可以用，只要是MFC程序中) CWnd* pWnd = AfxGetMainWnd(); 2获得对话框中控件指针 CWnd* pWnd = GetDlgItem(IDC_xxx); 3获得对话框中某控件的句柄 HANDLE GetDlgItem(m_hDLG,m_nID_DlgItem); 4获得GDI对象的句柄 HANDLE m_hGDIObj = m_pGDIObj-&gt;GetSafeHanle(); 1. 如何获取应用程序的 实例句柄? AfxGetInstanceHandle() 应用程序的 实例句柄保存在`CWinAppIm_hInstance` 中,可以这么调用 `AfxGetInstancdHandle`获得句柄. `Example: HANDLE hInstance=AfxGetInstanceHandle();`2. 如何通过代码获得应用程序主窗口的 指针? AfxGetMainWnd GetSafeHwnd() AfxGetAppName() `AfxGetThread`` 主窗口的 指针保存在`CWinThread::m_pMainWnd`中,调用 `AfxGetMainWnd`实现。 【例】 AfxGetMainWnd() -&gt;ShowWindow(SW_SHOWMAXMIZED); //使程序最大化. 【例】此例的主窗口是对话框，下面的代码是在另外一个CFileTreeCtrl 类（子窗）中相关函数实现在主对话框（主窗）中的几个 静态文本框（子窗）中显示路径： 12345678910111213141516CWnd* m_pCWnd= AfxGetMainWnd(); //得到主窗口指针,通过主窗指针访问其他子窗资源//方法一m_pCWnd-&gt;SetDlgItemText(IDC_STATIC_path,\"CWnd* \"+m_sCurPath); //在主窗中的子窗（ID：IDC_STATIC_path）中显示字符串m_pCWnd-&gt;SetDlgItemText(IDC_STATIC_who,\"路径显示由FileTreeCtrl类完成：\");//方法二m_pCWnd-&gt;SendMessage(STN_CLICKED); //向主窗口发送一个消息,显示任务由主窗完成。//在主窗的.cpp中有：ON_MESSAGE(STN_CLICKED, OnSTATICpath3)相关描述&nbsp;//有的函数必须通过窗口的 句柄 来访问，我们可以使用下面的方法三//CWnd::GetSafeHwnd&nbsp;//Returns the window handle for a window//HWND GetSafeHwnd( ) const;HWND m_hWnd_tree =GetSafeHwnd();//【注】此处得到的只是当前窗口（FileTree类）的句柄HWND m_hWnd = m_pCWnd-&gt;GetSafeHwnd();// 这里才是主窗口的句柄（由主窗指针得到主窗的句柄）//BOOL SetWindowText( HWND hWnd, LPCTSTR lpString )::SetWindowText(m_hWnd,\"ok2222\");//修改主窗口标题::SetDlgItemText(m_hWnd,IDC_STATIC_path2,\"HWND: \"+m_sCurPath); 【另】AfxGetThread `CWinThread* AfxGetThread( );` Return Value：Pointer to the currently executing thread. 3. 如何在程序中获得其他程序的 图标? AfxGetInstanceHandle() HINSTANCE AfxGetInstanceHandle( ); Return Value An HINSTANCE to the current instance of the application. If called from within a DLL linked with the USRDLL version of MFC, an HINSTANCE to the DLL is returned. Remarks This function allows you to retrieve the instance handle of the current application. AfxGetInstanceHandle always returns the HINSTANCE of your executable file (.EXE) unless it is called from within a DLL linked with the USRDLL version of MFC. In this case, it returns an HINSTANCE to the DLL. 两种方法: (1) SDK函数 `SHGetFileInfo` 或使用 ExtractIcon获得图标资源的 handle(句柄), (2) SDK函数 `SHGetFileInfo`获得有关文件的 很多信息,如大小图标,属性,类型等. Example(1): 在程序窗口左上角显示 NotePad图标.12345678void CSampleView: OnDraw(CDC * pDC){ if( :: SHGetFileInfo(_T(\"c:\\\\pwin95\\\\notepad.exe\"),0, &amp;stFileInfo,sizeof(stFileInfo),SHGFI_ICON)) { pDC -&gt;DrawIcon(10,10,stFileInfo.hIcon); }} Example(2):同样功能,Use ExtractIcon Function1234567void CSampleView:: OnDraw(CDC *pDC){ HICON hIcon=:: ExtractIcon(AfxGetInstanceHandle(),_T (\"NotePad.exe\"),0); if (hIcon &amp;&amp;hIcon!=(HICON)-1) pDC-&gt;DrawIcon(10,10,hIcon);} 【说明】关于如何得到系统文件的正确路径，象win.ini system32.ini等的路径，各种系统中具体的路径是不一样的。如： 获得notepad.exe的路径正规上来说用`GetWindowsDirectory` 函数得到； 如果是调用 win95下的画笔，应该用访问注册表的方法获得其路径； 要作成一个比较考究的程序，考虑应该全面点. 【另】 `HINSTANCE AfxGetResourceHandle( );` Return Value：An HINSTANCE handle where the default resources of the application are loaded. 4. 有关取得桌面句柄 GetDesktopWindow() MSDN中的例子： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849// 静态函数CWnd:: GetDesktopWindow 返回桌面窗口的指针。下例说明了MFCvoid CFrameWnd::BeginModalState (){ //first count all windows that need to be disabled UINT nCount=0; HWND hWnd=:: GetWindow (:: GetDesktopWindow (), GW_CHILD); while (hWnd!=NULL) { if (:: IsWindowEnabled (hwnd) &amp;&amp; CWnd::FromHandlePermanent (hWnd)!=NULL &amp;&amp; AfxIsDescendant (pParent-&gt;m_hWnd, hWnd) &amp;&amp; :: SendMessage (hWnd, WM_DISABLEMODAL, 0, 0) == 0) { ++nCount; } hWnd=:: GetWindow (hWnd, GW_HWNDNEXT); }}&nbsp;//用户的问题：下面程序取的不是同一程序的句柄,但是GetModuleFileName返回的结果一样请问为什莫&nbsp;HWND ChWnd;//子窗口句柄&nbsp;HWND hwDesktop=::GetDesktopWindow();//取得桌面句柄&nbsp;ChWnd=::GetWindow(hwDesktop,GW_CHILD);//取得桌面子句柄&nbsp;CString csTitle,csClass,csTm,mLookstring;&nbsp;char szBuffer[255];&nbsp;while(ChWnd!=NULL)//循环取子句柄的同级句柄&nbsp;{ if(::IsWindowVisible(ChWnd))//判断是否为可显示窗口&nbsp; {&nbsp; ::GetWindowText(ChWnd,csTitle.GetBuffer(255),254);&nbsp; ::GetClassName(ChWnd,csClass.GetBuffer(255),254);&nbsp; csTitle.ReleaseBuffer();//标题&nbsp; csClass.ReleaseBuffer();//类名&nbsp; csTm.Format(\"%08X:\",ChWnd);&nbsp; if(csTitle==\"\")&nbsp; {&nbsp; mLookstring=csTm+csClass;&nbsp; }else&nbsp; {&nbsp; mLookstring=csTm+csTitle;&nbsp; }&nbsp; //这里的窗口句柄不是同一个程序吧?（问题所在！）可是为什莫结果一样&nbsp; HINSTANCE hInstance = (HINSTANCE)::GetWindowLong(ChWnd,DWL_USER);&nbsp; ::GetModuleFileName(hInstance, szBuffer, sizeof(szBuffer));&nbsp; MessageBox(szBuffer,mLookstring);&nbsp; }&nbsp; ChWnd=::GetWindow(ChWnd,GW_HWNDNEXT);&nbsp;} 回答: 问题在于Win32下GetWindowLong(ChWnd,DWL_USER)总是返回当前程序运行的hInstance，所以你得到的文件名总是一个。所以你要用枚举所有”进程的程序名”来获得程序名。 === 再谈句柄与指针的区别 许多开始学习VC的朋友，最多听说的两个词莫过于指针和句柄了。 但是，确经常搞不清他们之间的区别。 首先，句柄是一个窗口的标志，也就是所有从CWND类继承下来的，多有句柄这个成员。 他能做的，也就是唯一代表一个桌面上的窗口罢了。而指针是一个地址，如果它指向了一个内存中的对象，那么就可以对它进行任意操作了，当然，并不局限于自己的应用程序，你如果能够获得别的应用程序的某个对象的指针，也可以进行操作。然而，如果要获得指针，首先，必须找到那个窗口的句柄，然后用函数FromHandle就可以得到他的指针了。 === 问题1: 如何在自定义的消息中发送一个字符串？例如: SendMessage(MyWnd,WM_USERDEFINED, 0,0) 如何将字符串Buffer写入wParam或lParam? 你可以把字符串的地址传递过去，因为地址正好是32位。如： 12char s[256];&nbsp;SendMessage(MyWnd,WM_USERDEFINED, (WPARAM) s,0) 接收方只需要将wParam赋给一个char*就可以了。但此方法只能使用于在一个进程内部传递数据。 === 问题2: 1.在VC应用程序框架中,如何加入自己做的类,如何定义这个类的对象,我想在鼠标点击某个菜单项的时候才生成这个对象,做得到吗?(这个类的构造函数是带参数的)。 2.消息发送函数: PostMessage(HWND handle,WM_MYMESSAGE, WPARAM wParam,LPARAM lParam) 中: 第一个参数如何获得? 如果我的消息是在自己的应用程序中生成的,想发给应用程序的窗口让它显示某些数据(用TextOut函数),能做到吗? (也可以说是这样的问题:用Appwizard生成应用程序框架,在生成的类(如CView)中如何得到窗口的句柄,并放在PostMessage函数中。) 3.wParam,lParam,在消息响应函数中如何用?vc是怎样保证这两个数传到函数中的?问题比较多,谢谢! 水平: 刚入门 回答: 1、这个问题是肯定的。你可以使用ClassWizard定义类，也可以手工输入。如果类定义已经在某个文件中，只要使用Project|Add files将文件加入工程就可以了。要想定义类的对象，只要在你的菜单项的相应事件中就可以了。如： 123456{&nbsp; ...&nbsp; MyClass myObject(\"Hello\");&nbsp; myObject.MyMethod();&nbsp; ...&nbsp;} 2、在你自己的程序中传递消息当然没有任何问题,只要你知道要调用的窗口类是从CWnd继承来的，你就可以使用GetSafeHwnd函数获得窗口句柄。不过一般在自己的同一个程序中有时不愿意使用自定义消息，因为太麻烦。你完全可以给要调用的类添加一个成员函数，只要想显示数据，直接调用这个成员函数不就可以了？何必使用PostMessage呢？一般只有在程序间调用，才愿意使用自定义消息。这时，你通常可以使用FindWindow获得窗口句柄(QA000251 “如何利用FindWindow()函数查找程序”)。 3、对于MFC已经定义了消息处理函数的消息，MFC会自动把wParam和lParam映射为更容易使用的方式。如OnMouseMove( UINT nFlags, CPoint point )。对于MFC不能自动处理的函数，如你使用ON_MESSAGE定义消息函数，则MFC会把wParam和lParam原原本本的传递给你的函数，不做任何处理。 === 一个未公开的Win32 API函数：GetTaskmanWindow() 下例中还用到： `GetProcAddress` `GetParent(hWnd)` `HMODULE hUser32 = GetModuleHandle(\"user32\");` 123456789101112131415161718192021222324252627282930313233343536373839// getaskmanwnd.cpp (Windows NT/2000)//// 利用一个未公开的Win32 API函数：GetTaskmanWindow，// 对Windows的任务栏进行操作(显示/隐藏)。这个函数返回拥有任务栏按钮的窗口句柄。//// This example will show you how you can obtain a handle to the// Windows Taskbar window.//// (c)1999 Ashot Oganesyan K, SmartLine, Inc// mailto:ashot@aha.ru, http://www.protect-me.com, http://www.codepile.com#include &lt;windows.h&gt;#include &lt;stdio.h&gt;// User32!GetTaskmanWindow (NT specific!)// This function returns a handle to the window that ownes the taskbar buttons// HWND GetTaskmanWindow()typedef HWND (WINAPI *PROCGETTASKMANWND)(void);PROCGETTASKMANWND GetTaskmanWindow;void main(int argc, char* argv[]){ if (argc&lt;2) { printf(\"Usage:\\n\\ngetaskmanwnd.exe S|H\\n\"); return; } HMODULE hUser32 = GetModuleHandle(\"user32\"); if (!hUser32) return; GetTaskmanWindow = (PROCGETTASKMANWND)GetProcAddress(hUser32,\"GetTaskmanWindow\");&nbsp; if (!GetTaskmanWindow) return; HWND hWnd = GetTaskmanWindow(); if (!hWnd) return; if (*argv[1]==\"H\" || *argv[1]==\"h\") ShowWindow(GetParent(hWnd),SW_HIDE); else ShowWindow(GetParent(hWnd),SW_SHOW);} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"整理","slug":"整理","permalink":"http://blog.iwxyi.com/tags/整理/"},{"name":"C++","slug":"C","permalink":"http://blog.iwxyi.com/tags/C/"},{"name":"MFC","slug":"MFC","permalink":"http://blog.iwxyi.com/tags/MFC/"}]},{"title":"Win32 SDK窗口模板","date":"2018-05-01T02:15:00.000Z","path":"2018/05/01/Win32-SDK窗口模板/","text":"Windows SDK 应用程序窗口模板 可以直接用 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990#include &lt;Windows.h&gt;#include &lt;tchar.h&gt;LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM); // 窗口函数说明// -------------------- 入口函数的代码 --------------------int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow){ WNDCLASSEX wcex; HWND hWnd; MSG msg; TCHAR szWindowClass[] = \"窗口示例\"; // 窗口类名 TCHAR szTitle[] = \"我的窗口\"; // 窗口标题名 // ------------------- 初始化窗口类 ------------------- wcex.cbSize = sizeof(WNDCLASSEX); // 窗口类的大小 wcex.style = 0; // 窗口类型为默认类型 wcex.lpfnWndProc = WndProc; // 窗口处理函数为 WndProc wcex.cbClsExtra = 0; // 窗口类无扩展 wcex.cbWndExtra = 0; // 窗口实例无扩展 wcex.hInstance = hInstance; // 当前实例句柄 wcex.hIcon = LoadIcon(hInstance, MAKEINTRESOURCE(IDI_APPLICATION)); // 窗口的图标为默认图标 wcex.hCursor = LoadCursor(NULL, IDC_ARROW); // 窗口采用箭头光标 wcex.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH); // 窗口背景为白色 wcex.lpszMenuName = NULL; // 窗口中无菜单 wcex.lpszClassName = szWindowClass; // 窗口类名为“窗口实例” wcex.hIconSm = LoadIcon(wcex.hInstance, MAKEINTRESOURCE(IDI_APPLICATION)); // 窗口的小图标为默认图标 // -------------------- 注册窗口类 -------------------- if ( !RegisterClassEx(&amp;wcex) ) // 如果注册失败则发出警告 { MessageBox(NULL, _T(\"窗口类注册失败！\"), _T(\"窗口注册\"), NULL); return 1; } // --------------------- 创建窗口 --------------------- hWnd = CreateWindow( szWindowClass, // 窗口类名 szTitle, // 窗口实例的标题名 WS_OVERLAPPEDWINDOW, // 窗口的风格 CW_USEDEFAULT, CW_USEDEFAULT, // 窗口左上角坐标为默认值 CW_USEDEFAULT, CW_USEDEFAULT, // 窗口的高和宽为默认值 NULL, // 无父窗口 NULL, // 无主菜单 hInstance, // 创建此窗口应用程序的当前句柄 NULL // 如果创建窗口失败则发出警告 ); if ( !hWnd ) { MessageBox(NULL, \"创建窗口失败！\", _T(\"创建窗口\"), NULL); return 1; } ShowWindow(hWnd, nCmdShow); // 显示窗口 UpdateWindow(hWnd); // 绘制用户区 while(GetMessage(&amp;msg, NULL, 0, 0)) // 消息循环 { TranslateMessage(&amp;msg); DispatchMessage(&amp;msg); } return (int) msg.wParam; // 程序终止时将信息返回系统}// ----------------------- 窗口函数 -----------------------LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam){ switch(message) { case WM_DESTROY : PostQuitMessage(0); // 发出 WM_QUIT 消息，没有这句话则只是关闭窗口但进程不会停止 break; default : return DefWindowProc(hWnd, message, wParam, lParam); // 默认时采用系统消息默认处理函数 break; } return 0;} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"模板","slug":"模板","permalink":"http://blog.iwxyi.com/tags/模板/"},{"name":"Win32 SDK","slug":"Win32-SDK","permalink":"http://blog.iwxyi.com/tags/Win32-SDK/"}]},{"title":"VC++连接外部DLL","date":"2018-05-01T01:38:00.000Z","path":"2018/05/01/VC-连接外部DLL/","text":"1、隐式的加载时链接这种方法需要DLL工程经编译产生的LIB文件，此文件中包含了DLL允许应用程序调用的所有函数的列表，当链接器发现应用程序调用了LIB文件列出的某个函数，就会在应用程序的可执行文件的文件映像中加入一些信息，这些信息指出了包含这个函数的DLL文件的名字。当这个应用程序运行时，也就是它的可执行文件被操作系统产生映像文件时，系统会查看这个映像文件中关于DLL的信息，然后将这个DLL文件映像到进程的地址空间。 系统通过DLL文件的名称，试图加载这个文件到进程地址空间时，它寻找DLL 文件的路径按照先后顺序如下： 程序运行时的目录，即可执行文件所在的目录； 当前程序工作目录 系统目录：对于Windows95/98来说，可以调用GetSystemDirectory函数来得到，对于WindowsNT/2000 来说，指的是32位Windows的系统目录，也可以调用GetSystemDirectory函数来得到，得到的值为SYSTEM32。 Windows目录 列在PATH环境变量中的所有目录 VC中加载DLL的LIB文件的方法有以下三种： ①LIB文件直接加入到工程文件列表中在VC中打开File View一页，选中工程名，单击鼠标右键，然后选中“Add Files to Project”菜单，在弹出的文件对话框中选中要加入DLL的LIB文件即可。 ②设置工程的 Project Settings来加载DLL的LIB文件打开工程的 Project Settings菜单，选中Link，然后在Object/library modules下的文本框中输入DLL的LIB文件。 ③通过程序代码的方式加入预编译指令#pragma comment (lib,”.lib”)，这种方法优点是可以利用条件预编译指令链接不同版本的LIB文件。因为，在Debug方式下，产生的LIB文件是Debug 版本，如Regd.lib；在Release方式下，产生的LIB文件是Release版本，如Regr.lib。当应用程序对DLL的LIB文件加载后，还需要把DLL对应的头文件（.h）包含到其中，在这个头文件中给出了DLL中定义的函数原型，然后声明。 2、显式的运行时链接 隐式链接虽然实现较简单，但除了必须的.dll文件外还需要DLL的.h文件和.lib文件，在那些只提供.dll文件的场合就无法使用，而只能采用显式链接的方式。这种方式通过调用API函数来完成对DLL的加载与卸载，其能更加有效地使用内存，在编写大型应用程序时往往采用此方式。这种方法编程具体实现步骤如下： ①使用Windows API函数Load Library或者MFC提供的AfxLoadLibrary将DLL模块映像到进程的内存空间，对DLL模块进行动态加载。 ②使用GetProcAddress函数得到要调用DLL中的函数的指针。 ③不用DLL时，用Free Library函数或者AfxFreeLibrary函数从进程的地址空间显式卸载DLL。 参考：https://blog.csdn.net/yu444/article/details/4728068 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"VC++","slug":"VC","permalink":"http://blog.iwxyi.com/tags/VC/"}]},{"title":"VC++绘图函数大全","date":"2018-03-18T01:07:00.000Z","path":"2018/03/18/MFC控件使用大全/","text":"windows的绘图工具 画笔CPen 画刷CBrush 调色板CPalette 画笔通常具有宽度 样式和颜色3中属性构造函数 CPen( ); CPen( int nPenStyle, int nWidth, COLORREF crColor ); CPen( int nPenStyle, int nWidth, const LOGBRUSH* pLogBrush, int nStyleCount = 0, const DWORD* lpStyle = NULL ); 当使用第一种构造函数时，还得继续调用一下函数 CPen::CreatePen BOOL CreatePen( int nPenStyle, int nWidth, COLORREF crColor ); BOOL CreatePen( int nPenStyle, int nWidth, const LOGBRUSH* pLogBrush, int nStyleCount = 0, const DWORD* lpStyle = NULL ); BOOL CreatePenIndirect( LPLOGPEN lpLogPen ); 涉及的结构体1234567891011121314typedef struct tagLOGPEN { /* lgpn */ UINT lopnStyle; POINT lopnWidth; COLORREF lopnColor;} LOGPEN;typedef struct tagLOGBRUSH { UINT lbStyle; COLORREF lbColor; LONG lbHatch; } LOGBRUSH, *PLOGBRUSH; typedef struct tagPOINT { LONG x; LONG y;} POINT; 例子 12CPen pen; pen.CreatePen(PS_SOLID,1,RGB(0,0,225)); 1CPen *pen1=new CPen(PS_SOLID,1,RGB(0,0,225)) 画刷通常具有填充色 填充图案和填充样式3种属性构造函数 CBrush( ); CBrush( COLORREF crColor ); CBrush( int nIndex, COLORREF crColor ); CBrush( CBitmap* pBitmap ); If you use the constructor with no arguments, you must initialize the resulting CBrush object withCreateSolidBrush,CreateHatchBrush,CreateBrushIndirect,CreatePatternBrush, orCreateDIBPatternBrush. 例子 12CBrush brush1; // Must initialize!brush1.CreateSolidBrush(RGB(0, 0, 255)); // Blue brush. 12CBrush brush3(HS_DIAGCROSS, RGB(0, 255, 0));CBrush brush3(HS_DIAGCROSS, RGB(0, 255, 0)); 123CBitmap bmp;bmp.LoadBitmap(IDB_BRUSH);CBrush brush4(&amp;bmp); 绘画函数 画点CDC::SetPixel 12COLORREF SetPixel( int x, int y, COLORREF crColor );COLORREF SetPixel( POINT point, COLORREF crColor ); CDC::SetPixelV 12BOOL SetPixelV(int x, int y, COLORREF crColor);BOOL SetPixelV( POINT point, COLORREF crColor ); 画线CDC::MoveTo（获取当前点CDC::GetCurrentPosition） 12CPoint MoveTo( int x, int y );CPoint MoveTo( POINT point ); Moves the current position to the point specified by x and y (or by point). CDC::LineTo12BOOL LineTo( int x, int y );BOOL LineTo( POINT point ); Draws a line from the current position up to, but not including, the point specified by x and y (or point). The line is drawn with the selected pen. The current position is set to x,y or to point. 椭圆和弧画椭圆CDC::Ellipse 12BOOL Ellipse( int x1, int y1, int x2, int y2 );BOOL Ellipse( LPCRECT lpRect ); Draws an ellipse. The center of the ellipse is the center of the bounding rectangle specified by x1, y1, x2, and y2, or lpRect. The ellipse is drawn with the current pen, and its interior is filled with the current brush. 画椭圆弧CDC::Arc 12BOOL Arc( int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4 );BOOL Arc( LPCRECT lpRect, POINT ptStart, POINT ptEnd ); Since an arc is not a closed figure, it is not filled. 画带弦的椭圆弧CDC::Chord 12BOOL Chord( int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4 );BOOL Chord( LPCRECT lpRect, POINT ptStart, POINT ptEnd ); The chord is drawn by using the selected pen and filled by using the selected brush. 画一条椭圆弧并且弧的两个端点与圆心连线CDC::Pie 12BOOL Pie( int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4 );BOOL Pie( LPCRECT lpRect, POINT ptStart, POINT ptEnd ); Draws a pie-shaped wedge by drawing an elliptical arc whose center and two endpoints are joined by lines. The pie-shaped area is filled with the current brush 线段、曲线画连续的线段（从数组中的第一个点开始）CDC::Polyline 1BOOL Polyline( LPPOINT lpPoints, int nCount ); Return ValueNonzero if the function is successful; otherwise 0. ParameterslpPointsPoints to an array of POINT structures or CPoint objects to be connected.nCountSpecifies the number of points in the array. This value must be at least 2. 画连续的线段（会从当前的点开始）CDC::PolylineTo 1BOOL PolylineTo( const POINT* lpPoints, int nCount ); A line is drawn from the current position to the first point specified by the lpPoints parameter by using the current pen. 画贝塞尔曲线CDC::PolyBezier 12345BOOL PolyBezier( const POINT* lpPoints, int nCount );CDC::PolyBezierTo```CBOOL PolyBezierTo( const POINT* lpPoints, int nCount ); The first spline is drawn from the current position to the third point by using the first two points as control points. 画多组连接的线段CDC::Polyline 12BOOL Polyline( const POINT* lpPoints, const DWORD* lpPolyPoints, int nCount );参数 lpPointsPoints to an array of variables specifying the number of points in the lpPoints array for the corresponding polygon. Each entry must be greater than or equal to 2. 绘任意多边形CDC::Polygon 1BOOL Polygon( LPPOINT lpPoints, int nCount ); 矩形填充矩形CDC::Rectangle 12BOOL Rectangle( int x1, int y1, int x2, int y2 );BOOL Rectangle( LPCRECT lpRect ); Draws a rectangle using the current pen. The interior of the rectangle is filled using the current brush. 画一个带圆角的矩形CDC::RoundRect 12BOOL RoundRect( int x1, int y1, int x2, int y2, int x3, int y3 );BOOL RoundRect( LPCRECT lpRect, POINT point ); 用指定的颜色填充矩形CDC::FillSolidRect 12void FillSolidRect( LPCRECT lpRect, COLORREF clr );void FillSolidRect( int x, int y, int cx, int cy, COLORREF clr ); RemarksCall this member function to fill the given rectangle with the specified solid color.FillSolidRect is very similar to CDC::FillRect; however, FillSolidRect uses only solid colors (indicated by the COLORREF parameter), while FillRect takes a brush and therefore can be used to fill a rectangle with a solid color, a dithered color, hatched brushes, or a pattern. FillSolidRect usually is faster than FillRect. 使用指定的画刷填充矩形CDC::FillRect 1void FillRect( LPCRECT lpRect, CBrush* pBrush ); RemarksCall this member function to fill a given rectangle using the specified brush. The function fills the complete rectangle, including the left and top borders, but it does not fill the right and bottom borders. 使用指定的画刷填充矩形，可以指定样式CDC::ExtFloodFill 1BOOL ExtFloodFill( int x, int y, COLORREF crColor, UINT nFillType ); RemarksFills an area of the display surface with the current brush. This member function offers more flexibility than FloodFill because you can specify a fill type in nFillType. 使用当前画刷填充显示区域CDC::FloodFill 1BOOL FloodFill( int x, int y, COLORREF crColor ); RemarksFills an area of the display surface with the current brush. The area is assumed to be bounded as specified by crColor. The FloodFill function begins at the point specified by x and y and continues in all directions to the color boundary. Only memory-device contexts and devices that support raster-display technology support the FloodFill member function. document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"整理","slug":"整理","permalink":"http://blog.iwxyi.com/tags/整理/"},{"name":"VC++","slug":"VC","permalink":"http://blog.iwxyi.com/tags/VC/"}]},{"title":"Windows卡顿优化","date":"2018-03-04T11:52:00.000Z","path":"2018/03/04/Windows卡顿优化/","text":"关闭家庭组因为这功能会导致硬盘和CPU处于高负荷状态 关闭方案：控制面板–管理工具–服务– HomeGroup Listener 和 HomeGroup Provider 禁用。 关闭性能特效（配置较低的机器可以关闭）系统属性-高级-性能-设置-关闭淡出淡入效果。 关闭磁盘碎片整理计划磁盘碎片整理可以提高磁盘性能，但不需要整理计划，可以关闭整理计划。选中磁盘C-属性–工具–对驱动器进行优化和碎片整理–优化–更改设置–取消选择按计划执行。关闭IPv6协议 Win10默认开启的IPv6协议，对于日常使用的我们来讲，使用率几乎为0，而它却大大的占用着系统资源。打开控制面板，进入网络和 Internet，找到网络和共享中心窗口，从左侧的栏目中点击更改适配器设置进入网络连接。打开以太网属性窗口。在列表中找到Internet协议版本6(TCP/IPv6)，点击取消勾选，确定=】即可。 卸载预装应用（强力）使用Cortana搜索，输入PowerShell，右键PowerShell，以管理员身份运行。在PowerShell中输入：Get-AppXPackage | Remove-AppxPackage遇到错误时请无视，继续执行该命令最终结果是，所有预装软件中只剩Edge浏览器，连APP商店都没了使用win更新系统后，预装软件均可找回 关闭服务win+r输入services.msc 以下是可以更改为手动启动的服务（按名称排序）： 1、Application Experience（启动时为程序处理应用程序兼容性缓存请求） 2、Computer Browser（维护网络上计算机的更新列表，不需要联网的话可以改为手动） 3、Diagnostic Policy Service（诊断策略服务）Diagnositic 开头的都禁用 4、Distributed Link Tracking Client（维护计算机内的NTFS文件之间的链接） 5、IP Helper（使用IPv6转换技术） 6、Offline Files（脱机文件服务） 7、Program Compatibility Assistant Service（为应用程序兼容性助手提供支持） 8、Portable Device Enumerator Service（强制可移动大容量存储设备的组策略） 9、Print Spooler（没有打印机的话可以关闭它） 10、Remote Registry（远程注册表设置，这项服务应该保持禁用状态） 11、Secondary Logon（在不同凭据下启用启动过程，改为手动即可，禁用会导致魔兽世界等游戏无法登录） 12、Security Center（监视并报告计算机上的安全健康设置） 13、Server （支持计算机通过网络进行共享，若处于单机状态的话，可以改为手动） 14、TCP/IP NetBIOS Helper （提供NetBIOS名称解析支持，若你的计算机没有连接到工作组网络的话，可以改为手动） 15、Windows Error Reporting Service （报告错误并提供现有解决方案） 16、Windows Image Acquisition （WIA） （为扫描仪和照相机提供图像采集服务） 17、Windows Search （提供内容索引，如果你不怎么使用Windows自带搜索的话，可以改手动） 18、Windows Time （维护时间和日期同步） 19、Windows Update 系统更新（禁用） 20、Superfetch 超级与读取（禁用） document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Windows","slug":"Windows","permalink":"http://blog.iwxyi.com/tags/Windows/"}]},{"title":"Emment语法","date":"2018-03-03T11:57:00.000Z","path":"2018/03/03/Emment语法/","text":"1.1 生成html初始文档123!+tab或者html:5 生成html5文档的初始结构html:xt 生成html4过渡型html:4s 生成html4严格型） 生成的文档如下： 12345678910&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 1.2 生成带有id,class的HTML标签1. 1#aaa 生成一个ID为aaa的div 生成结构如下： 1&lt;div id=\"aaa\"&gt;&lt;/div&gt; 2. 1ul#ccc.ddd 生成一个ID为ccc,class为ddd的ul 生成结构如下： 1&lt;ul id=\"ccc\" class=\"ddd\"&gt;&lt;/ul&gt; 1.3 生成后代 “&gt;”1div.aaa&gt;ul&gt;li 生成一个无序列表，而且被class为aaa的div包裹 生成结构如下： 12345&lt;div class=\"aaa\"&gt; &lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 1.4 生成兄弟1div+p+dp 123&lt;div&gt;&lt;/div&gt;&lt;p&gt;&lt;/p&gt;&lt;dp&gt;&lt;/dp&gt; 1.5 生成上级元素 “^”上级 （Climb-up）元素是什么意思呢？前面咱们说过了生成下级元素的符号“&gt;”，当使用 div&gt;ul&gt;li 的指令之后，再继续写下去，那么后续内容都是在 li 下级的。如果我想编写一个跟 ul 平级的 span 标签，那么我需要先用 “^” 提升一下层次。例如： 1div&gt;ul&gt;li^span 123456&lt;div&gt; &lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt; &lt;span&gt;&lt;/span&gt;&lt;/div&gt; 如果我想生成一个与div平级的span，那么就再上升一个层级，多用一个^ 1div&gt;ul&gt;li^^span 123456&lt;div&gt; &lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;span&gt;&lt;/span&gt; 1.6重复生成多份*1ul&gt;li*5 1234567&lt;ul&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt;&lt;/ul&gt; 1.7生成分组()1div&gt;(header&gt;ul&gt;li*2&gt;a)+footer&gt;p 12345678910&lt;div&gt;&lt;/div&gt; &lt;header&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=\"\"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"\"&gt;&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/header&gt; &lt;footer&gt; &lt;p&gt;&lt;/p&gt; &lt;/footer&gt; 分组还可以结合上面的*符号生成重复结构 1(div&gt;dl&gt;(dt&gt;dd)*3)+footer&gt;p 12345678910111213141516&lt;div&gt; &lt;dl&gt; &lt;dt&gt; &lt;dd&gt;&lt;/dd&gt; &lt;/dt&gt; &lt;dt&gt; &lt;dd&gt;&lt;/dd&gt; &lt;/dt&gt; &lt;dt&gt; &lt;dd&gt;&lt;/dd&gt; &lt;/dt&gt; &lt;/dl&gt;&lt;/div&gt;&lt;footer&gt; &lt;p&gt;&lt;/p&gt;&lt;/footer&gt; 1.8生成自定义属性[attr]a 标签中往往需要附带 href 属性和 title 属性，如果我们想生成一个 href 为 “http://google.com” ，title 为“我爱水煮鱼”的 a 标签，可以这样写： 1a[href=\"www.google.com\" title=\"我爱水煮鱼\"] 1&lt;a href=\"www.google.com\" title=\"我爱水煮鱼\"&gt;&lt;/a&gt; 1.9生成内容编号$1ul&gt;li.item$*5 1234567&lt;ul&gt; &lt;li class=\"item1\"&gt;&lt;/li&gt; &lt;li class=\"item2\"&gt;&lt;/li&gt; &lt;li class=\"item3\"&gt;&lt;/li&gt; &lt;li class=\"item4\"&gt;&lt;/li&gt; &lt;li class=\"item5\"&gt;&lt;/li&gt;&lt;/ul&gt; 1ul&gt;li.item$$$*5 1234567&lt;ul&gt; &lt;li class=\"item001\"&gt;&lt;/li&gt; &lt;li class=\"item002\"&gt;&lt;/li&gt; &lt;li class=\"item003\"&gt;&lt;/li&gt; &lt;li class=\"item004\"&gt;&lt;/li&gt; &lt;li class=\"item005\"&gt;&lt;/li&gt;&lt;/ul&gt; 只能这样单调的生成序号？对于强大的 Emmet 来说，肯定不会会了，我们也可以在 $ 后面增加 @- 来实现倒序排列： 1ul&gt;li.item$@-*5 1234567&lt;ul&gt; &lt;li class=\"item5\"&gt;&lt;/li&gt; &lt;li class=\"item4\"&gt;&lt;/li&gt; &lt;li class=\"item3\"&gt;&lt;/li&gt; &lt;li class=\"item2\"&gt;&lt;/li&gt; &lt;li class=\"item1\"&gt;&lt;/li&gt;&lt;/ul&gt; 我们也可以使用@N指定开始的序号 1ul&gt;li.item$@3*5 1234567&lt;ul&gt; &lt;li class=\"item3\"&gt;&lt;/li&gt; &lt;li class=\"item4\"&gt;&lt;/li&gt; &lt;li class=\"item5\"&gt;&lt;/li&gt; &lt;li class=\"item6\"&gt;&lt;/li&gt; &lt;li class=\"item7\"&gt;&lt;/li&gt;&lt;/ul&gt; 配合上面倒序输出，可以这样写: 1ul&gt;li.item$@-3*5 1234567&lt;ul&gt; &lt;li class=\"item7\"&gt;&lt;/li&gt; &lt;li class=\"item6\"&gt;&lt;/li&gt; &lt;li class=\"item5\"&gt;&lt;/li&gt; &lt;li class=\"item4\"&gt;&lt;/li&gt; &lt;li class=\"item3\"&gt;&lt;/li&gt;&lt;/ul&gt; 2.0生成文本内容{}1a[href=\"www.google.com\"]{click me} 或者 1a[href=\"www.google.com\"]&gt;{click me} 1&lt;a href=\"www.google.com\"&gt;click me&lt;/a&gt; 注意不能有空格 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"HTML","slug":"HTML","permalink":"http://blog.iwxyi.com/tags/HTML/"},{"name":"语法","slug":"语法","permalink":"http://blog.iwxyi.com/tags/语法/"}]},{"title":"安卓Rec模式清除锁屏密码","date":"2018-01-29T12:44:00.000Z","path":"2018/01/29/安卓Rec模式清除锁屏密码/","text":"打开TWRP的adb shell 12345rm /data/system/locksettings.dbrm /data/system/locksettings.db-shmrm /data/system/locksettings.db-walrm /data/system/gatekeeper.password.keyrm /data/system/gatekeeper.pattern.key 实测可以用文件管理删除前两项即可（不同类型密码的文件不同） document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"搞机","slug":"搞机","permalink":"http://blog.iwxyi.com/tags/搞机/"}]},{"title":"Python-学习笔记","date":"2018-01-24T05:38:00.000Z","path":"2018/01/24/Python-学习笔记/","text":"入门变量和基础类型数据类型 整数 十六进制：0x 浮点数 1.23e4 字符串 ‘xxx’ 或 “xxx” 布尔值 True、False and、or、not 空值 None（不能理解为0） print12print '1 + 2=', 1 + 2 # 1 + 2 = 3 结束后自动换行print 'hello' , 'world' # 逗号会输出一个空格 变量大小写英文、数字、下划线，且不能是数字开头 123a = 1t_007 = 'T007'a == 1 # 相等 变量本身类型不固定的语言称之为动态语言，与之对应的是静态语言。 字符串####常见字符串 如果字符串包含单引号'，则要用双引号\"\"括起来 如果既包含单引号又包含双引号，就要用反斜杠\\来转义 ####raw字符串 如果一个字符串有很多要转义的字符，可以加个前缀r，表示这是一个raw字符串，里面的字符就不需要转义了。例如： 1r'\\(~_~)/ \\(~_~)/' 但是r'...'表示法不能表示多行字符串，也不能表示包含'和 \"的字符串 ####多行字符串 如果要表示多行字符串，可以用'''...'''表示（同样可以在前面加一个r）： 123'''Line 1Line 2Line 3''' 上面这个字符串的表示方法和下面的是完全一样的： 1'Line 1\\nLine 2\\nLine 3' Unicode字符串最早的Python只支持ASCII编码，普通的字符串’ABC’在Python内部都是ASCII编码的。 Python在后来添加了对Unicode的支持，以Unicode表示的字符串用u’…’表示，比如： 1print u'中文' # 中文 注意: 不加 u ，中文就不能正常显示。 除了多了一个u之外，与普通字符串没啥区别，转义字符和多行表示法仍然有效 如果中文字符串在Python环境下遇到 UnicodeDecodeError，这是因为.py文件保存的格式有问题。可以在第一行添加注释 1# -*- coding: utf-8 -*- 整数与浮点数同C语言： 整数 + 浮点数 = 浮点数 整数 / 整数 = 整数 整数 / 浮点数 = 浮点数 List 与 Tuple 类型###list 123classmates = ['Michael', 'Bob', 'Tracy']L = ['Michael', 100, True]empty_list = [] ####倒序访问 12print L[0] # 索引从 0 开始print L[-1] # 倒序访问最后一个元素（也注意不要越界） 添加元素12L.append('Paul') # 添加到尾部L.insert(0, 'Paul') # 添加到开头 删除元素12L.pop() # 删除最后一个并返回这个元素L.pop(2) # 删除第三个元素 替换元素1L[-1] = 'Paul' 字符串list 首字母大写12c = ['zz','yy','xx'] c = [string.capitalize() for string in c] tuple即不可变的 list 1t = () # 空tuple 123t = ('Adam', 'Lisa', 'Bart')a = t[-2]# t[1] = 'Bob' # 报错 tuple和list外观唯一不同之处是用( )替代了[ ] tuple没有 append()方法，也没有insert()和pop()方法 ####单元素tuple 1t = (1) # 这是整数 1，而不是tuple 12t = (1,) # 可以加一个逗号\",\"避免歧义print t # (1,) 多元素 tuple 加不加这个额外的“,”效果是一样的： 12t = (1, 2, 3,)print t # (1, 2, 3) “可变”的 tuple1234t = ('a', 'b', ['A', 'B'])L = t[2]L[0] = 'X'print t # ('a', 'b', ['X', 'Y']) tuple所谓的“不变”是说，tuple的每个元素，指向永远不变。即指向’a’，就不能改成指向’b’，指向一个list，就不能改成指向其他对象，但指向的这个list本身是可变的！ 条件判断与循环if - elif - elseif 语句后接表达式，然后用:表示代码块开始。 注意: elif 和 else 后面有个 “:” 123456789age = 20if age &gt;= 18: print 'your age is', age print 'adult'elif age &gt; 10: print 10else: print ageprint 'END' 注意: **Python代码的缩进规则**。具有相同缩进的代码被视为代码块 缩进请严格按照Python的习惯写法：4个空格，不要使用Tab，更不要混合Tab和空格，否则很容易造成因为缩进引起的语法错误。 如果你在Python交互环境下敲代码，还要特别留意缩进，并且退出缩进需要多敲一行回车 循环123L = ['Adam', 'Lisa', 'Bart']for name in L: print name 12345N = 10x = 0while x &lt; N: print x x = x + 1 循环控制 break continue Dict 和 Set 类型###Dict { key : value } 123456789d = { 'Adam': 95, 'Lisa': 85, 'Bart': 59}print d # 注意：乱序存储，不会按顺序输出（和 list 不一样）len(d) # 3 len()用来求任意集合的大小print d['Adam'] # 95# print d['Paul'] # 报错：KeyError 判断 key 是否存在： 12if 'Paul' in d: print d['Paul'] dict 的 get 方法：在 Key 不存在的时候返回 None 12print d.get('Bart') # 59print d.get('Paul') # None Dict 的特点dict的第一个特点是查找速度快，无论dict有10个元素还是10万个元素，查找速度都一样 dict的缺点是占用内存大，还会浪费很多内容，list正好相反，占用内存小，但是查找速度慢。 由于dict是按 key 查找，所以，在一个dict中，key不能重复。 dict的第二个特点就是存储的key-value序对是没有顺序的！这和list不一样 打印的顺序不一定是我们创建时的顺序 dict的第三个特点是作为 key 的元素必须不可变：可变的 list 不能作为 key 1234{ '123': [1, 2, 3], # key 是 str，value是list ('a', 'b'): True # key 是 tuple，并且tuple的每个元素都是不可变对象，value是 boolean} 更新 dict1d['Paul'] = 72 如果 key 已经存在，则赋值会用新的 value 替换掉原来的 value ####遍历 dict 123d = { 'Adam': 95, 'Lisa': 85, 'Bart': 59 }for key in d: print key, d[key] # Lisa 95 \\n... setdict的作用是建立一组 key 和一组 value 的映射关系，dict的key是不能重复的。 set 持有一系列元素，这一点和 list 很像，但是set的元素没有重复，而且是无序的，这点和 dict 的 key很像。 创建 set 的方式是调用 set() 并传入一个 list，list的元素将作为set的元素： 12s = set(['A', 'B', 'C', 'A'])print s # set(['A', 'C', 'B']) 和 dict 一样是 乱序打印 ####访问 set 123s = set(['Adam', 'Lisa', 'Bart', 'Paul'])'Bart' in s # True'bart' in s # False （注意大小写） set 的特点key必须是不变对象 判断一个元素是否在set中速度很快 set存储的元素也是没有顺序的 遍历 set123s = set(['Adam', 'Lisa', 'Bart'])for name in s: print name # 注意：打印的顺序很可能是不同的 更新 set12s.add('Adam') # 如果添加的元素已经存在，不会报错，但是不会加进去了s.remove(4) # 删除 值为4 的元素。如果元素不存在，会报错（删除前要先判断） 函数内置函数12345int('123') # 转换到整数str(10) # 到字符串abs(10.1)sqrt(100) # math 包下help(abs) # 查看abs的帮助信息 自定义函数12345def my_abs(x): if x &gt;= 0: return x # 执行完毕，不继续下去 else: return -x return None可以简写为return 多返回值12345678import mathdef move(x, y, step, angle): nx = x + step * math.cos(angle) ny = y - step * math.sin(angle) return nx, nyx, y = move(100, 100, 60, math.pi / 6)print x, y # 151.961524227 70.0 但其实这只是一种假象，Python函数返回的仍然是单一值用print打印返回结果，原来返回值是一个tuple！在语法上，返回一个tuple可以省略括号，而多个变量可以同时接收一个tuple，按位置赋给对应的值 递归函数123456def fact(n): if n==1: return 1 return n * fact(n - 1)fact(5) # 120 使用递归函数需要注意防止栈溢出 默认参数1int('123', 8) # 83 两个参数的int：10进制转到8进制 12345678def power(x, n=2): # 求幂，默认平方 s = 1 while n &gt; 0: n = n - 1 s = s * x return spower(5) # 25 由于函数的参数按从左到右的顺序匹配，所以默认参数只能定义在必需参数的后面 可变参数12def fn(*args): print args 可变参数的名字前面有个 *** **号 解释器会把传入的一组参数组装成一个tuple传递给可变参数，直接把变量 args 看成一个 tuple 就好了 切片对list进行切片12L[0:3] # 取前3个元素：['Adam', 'Lisa', 'Bart']L[1:3] # 取 第2、3、4个元素 L[0:3]表示，从索引0开始取，直到索引3为止，但不包括索引3。即索引0，1，2，正好是3个元素。 如果第一个索引是0，还可以省略： 12L[:3] # 前三个L[:] # 表示从头到尾，实际上复制出了一个新list 切片操作还可以指定第三个参数： 1L[::2] # 表示每N个取一个 把list换成tuple，切片操作完全相同，只是切片的结果也变成了tuple。 倒序切片12345L = ['Adam', 'Lisa', 'Bart', 'Paul']L[-2:] # 倒数第二个直到结尾（最后两个） ['Bart', 'Paul']L[:-2] # 开头直到最后第二个（但不包括） ['Adam', 'Lisa']L[-3:-1] # 倒数第三个直到倒数第一个（不包括） ['Lisa', 'Bart']L[-4:-1:2] # -4、-2 ['Adam', 'Bart'] 记住倒数第一个元素的索引是-1。倒序切片包含起始索引，不包含结束索引。 字符串切片123'ABCDEFG'[:3] # 'ABC''ABCDEFG'[-3:] # 'EFG''ABCDEFG'[::2] # 'ACEG' 1234567'abc'.upper() # 所有字母变大写 'ABC'# 单词首字母大写函数def firstCharUpper(s): return s[0].upper() + s[1:] print firstCharUpper('hello') # Hello 迭代就是遍历 Python 的 for循环不仅可以用在list或tuple上，还可以作用在其他任何可迭代对象上 索引迭代 在 for 循环中拿到索引：enumerate() 函数 ，绑定索引index和元素name 123L = ['Adam', 'Lisa', 'Bart', 'Paul']for index, name in enumerate(L): print index, '-', name 输出结果是： 12340 - Adam1 - Lisa2 - Bart3 - Paul 实际上，enumerate() 函数把： 1['Adam', 'Lisa', 'Bart', 'Paul'] 变成了类似： 1[(0, 'Adam'), (1, 'Lisa'), (2, 'Bart'), (3, 'Paul')] 因此，迭代的每一个元素实际上是一个tuple： 1234for t in enumerate(L): index = t[0] name = t[1] print index, '-', name 如果我们知道每个tuple元素都包含两个元素，for循环又可以进一步简写为： 12for index, name in enumerate(L): # 最初的式子 print index, '-', name 额外：zip()函数zip()函数可以把两个 list 变成一个 list： 12zip([10, 20, 30], ['A', 'B', 'C'])# [(10, 'A'), (20, 'B'), (30, 'C')] 迭代dict的valuedict 对象有一个 values() 方法：把dict转换成一个包含所有value的list，这样，我们迭代的就是 dict的每一个 value： 12345678d = { 'Adam': 95, 'Lisa': 85, 'Bart': 59 }print d.values()# [85, 95, 59]for v in d.values(): print v# 85# 95# 59 dict除了values()方法外，还有一个itervalues() **方法，用itervalues()** 方法替代 values() 方法，迭代效果完全一样： 12345678d = { 'Adam': 95, 'Lisa': 85, 'Bart': 59 }print d.itervalues()# &lt;dictionary-valueiterator object at 0x106adbb50&gt;for v in d.itervalues(): print v# 85# 95# 59 那这两个方法有何不同之处呢？ values() 方法实际上把一个 dict 转换成了包含 value 的list。 但是 itervalues() 方法不会转换，它会在迭代过程中依次从 dict 中取出 value，所以 itervalues() 方法比 values() 方法节省了生成 list 所需的内存。 打印 itervalues() 发现它返回一个 &lt;dictionary-valueiterator&gt; 对象，这说明在Python中，for 循环可作用的迭代对象远不止 list，tuple，str，unicode，dict等，任何可迭代对象都可以作用于for循环，而内部如何迭代我们通常并不用关心。 如果一个对象说自己可迭代，那我们就直接用 for 循环去迭代它，可见，迭代是一种抽象的数据操作，它不对迭代对象内部的数据有任何要求。 迭代dict的key和value12d = { 'Adam': 95, 'Lisa': 85, 'Bart': 59 }print d.items() # [('Lisa', 85), ('Adam', 95), ('Bart', 59)] 123456for key, value in d.items(): print key, ':', value# Lisa : 85# Adam : 95# Bart : 59 和 values() 有一个 itervalues() 类似， items() *也有一个对应的 *iteritems()，iteritems() 不把dict转换成list，而是在迭代过程中不断给出 tuple，所以， iteritems() 不占用额外的内存。 列表生成式生成列表12# 生成list [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]range(1, 11) # [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] 123456# 生成[1x1, 2x2, 3x3, ..., 10x10] （方式一：循环）（繁琐）L = []for x in range(1, 11): L.append(x * x)L # [1, 4, 9, 16, 25, 36, 49, 64, 81, 100] 123# 生成[1x1, 2x2, 3x3, ..., 10x10] （方式二：列表生成式）[x * x for x in range(1, 11)]# [1, 4, 9, 16, 25, 36, 49, 64, 81, 100] 复杂表达式假设有如下的dict： 1d = { 'Adam': 95, 'Lisa': 85, 'Bart': 59 } 完全可以通过一个复杂的列表生成式把它变成一个 HTML 表格： 12345tds = ['&lt;tr&gt;&lt;td&gt;%s&lt;/td&gt;&lt;td&gt;%s&lt;/td&gt;&lt;/tr&gt;' % (name, score) for name, score in d.iteritems()]print '&lt;table&gt;'print '&lt;tr&gt;&lt;th&gt;Name&lt;/th&gt;&lt;th&gt;Score&lt;/th&gt;&lt;tr&gt;'print '\\n'.join(tds)print '&lt;/table&gt;' 注：字符串可以通过 % 进行格式化，用指定的参数替代%s。字符串的join()方法可以把一个 list 拼接成一个字符串。 条件过滤for 循环后面可以加上 if 判断 12[x * x for x in range(1, 11) if x % 2 == 0]# [4, 16, 36, 64, 100] 有了 if 条件，只有 if 判断为 True 的时候，才把循环的当前元素添加到列表中。 多层表达式对于字符串 ‘ABC’ 和 ‘123’，可以使用两层循环，生成全排列： 12&gt;&gt;&gt; [m + n for m in 'ABC' for n in '123']['A1', 'A2', 'A3', 'B1', 'B2', 'B3', 'C1', 'C2', 'C3'] 翻译成循环代码就像下面这样： 1234L = []for m in 'ABC': for n in '123': L.append(m + n) document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://blog.iwxyi.com/tags/学习笔记/"},{"name":"Python","slug":"Python","permalink":"http://blog.iwxyi.com/tags/Python/"}]},{"title":"这样学Java不枯燥-学习笔记","date":"2017-10-12T12:10:00.000Z","path":"2017/10/12/这样学Java不枯燥-学习笔记/","text":"12345678910import com.rupeng.game.GameCore;public class Main implements Runnable{ public static void main(String[] args) { GameCore.start(new Main()); } public void run() { // 游戏运行的函数 GameCore.alert(\"Hello World\"); }} 123456GameCore.pause(int x) // 暂停x毫秒GameCore.setGameTitle(char * name); // 设置名字GameCore.setGameSize(int width, int height); // 设置宽高GameCore.alert(Object msg); // 弹出提示框（整数、字符串都行）Dimension d = GameCore.getGameSize(); // d.width 、 d.height （imprt java.awt.Demension;） 123GameCore.loadBgView(String imgName); // 不重叠不拉伸显示图片。图片放到 src/Images 下面（注意大小写），可拖拽或者 ctrl+V粘贴playSound(String soundName, boolean repeat); // 播放音乐（仅支持mp3），音乐放到 src/Sounds 下面closeSound(String soundName); // 关闭音乐播放（包括重复播放的） 12long a = 99999L // 常数数字默认为整型，long赋值需要转换到intfloat f = 3.14 // 这样写是错的，需要加个F或f 123String s = GameCore.input(Object value, Object msg); // 输入框（默认信息， 提示信息）boolean b = GameCore.confirm(Object msg); // 确认框（提示信息）int i = Integer.parseInt(s); // 输入的内容到整数 123456789void createText(int txtNum, String text) // 创建只读文本void setTextPosition(int txtNum, int x, int y) // 修改文本位置void setText(int txtNum, String text) // 设置文本内容void setTextColor(int txtNum, Color color) // 设置文本颜色，color.RED、color.green、new color(int R, int G, int B)void setTextFontSize(int txtNum, int size) // 设置文本大小Point getTextPosition(final int num) // 获取文本位置（import java.awt.Point;）Dimension getTextSize(final int textNum)void hdieText(fina int labelNum) // 隐藏文字void showText(final int labelNum) // 显示文字 12345678void createImage(int num, String imgName) // 创建图片控件，图片放到 src/Images 里面（注意大小写）void createImage(int num) // 创建一个什么都不显示的图片void setImageSource(int num, String imgName) // 修改显示的图片源void setImagePosition(int num, int x, int y) // 修改坐标Point getImagePosition(final int num) // 获得坐标Dimension getImagePosition(final int num) // 获得大小void hideImage(int num) // 隐藏图片void showImage(int num) // 显示图片 12345678910精灵文件位置：src/Sprites/精灵名字[]/精灵动作[]/i.png图片 按顺序放好（多选文件夹粘贴）（分层：工作空间—右上角倒三角—包表示法）void createSprite(int num, String spriteName); // 创建精灵void palySpriteAnimate(int spriteNum, String animateName, boolean repeat); // 播放精灵的动作void setSpritePosition(int spriteNum, int x, int y); // 设置精灵的位置Point getSpritePosition(int spriteNum); //获得精灵的位置Dimension getSpriteSize(int spriteNum); // 获取精灵尺寸void hideSprite(int spriteNum); // 隐藏精灵void showSprite(int spriteNum); // 显示精灵void setSpriteFlipX(int spriteNum, boolean flipX); // 是否进行X方向翻转（左右对称,fip为true时翻转，false时还原）void setSpriteFlipY(int spriteNum, boolean flipY); // 是否设置Y方向翻转（上下对称） 123Java程序打包：拷贝bin和两个jar到单独的文件夹，拷贝jre，去掉src.zip、lib\\ext\\jfxrt.jar、bin\\server、bin\\jfxwebkit.dll，减小尺寸；创建一个.bat文件，内容：start jre\\bin\\javaw.exe -cp .\\bin\\ -Djava.ext.dirs=. Main1Main1 代表入口类，如果有包名则要写全名（xxx.Main1） 123String转int：Integer.parseInt(\"123\")String相等：s1.equal(s2); （必须用这种方式写）s1==s2 不使用原因： \"abc\"+\"123\" != \"abc123\" （初学者常犯错误） 12if (i = 10) // Java中这么写是错误的，C语言可以if (b = true) // 这样是正确的 1switch (表达式) // 表达式可以为byte/short/int/char，JDK5后可以是枚举，JDK7后可以是String类型 12345678910GameCore.getPressedKeyCode(); // 获得用户当前按键（只适合“连续动作”，一次性触发最好用“事件驱动”）与KeyEvent中的值作比较：（import java.awt.event.KeyEvent;）用法：if ( key == KeyEvent.VK_UP )数字键：VK_0、VK_1……字母键：VK_A、VK_B……功能键：VK_F1、VK_F2……回车：VK_ENTER空格：VK_SPACEESC：VK_ESCAPE方向键：VK_LEFT、VK_UP、VK_RIGHT、VK_DOWN 12int[10] a = new int[10]; 等价于 int a[10]; 但是前者有初始化int、double等默认为0，String、Integer等默认为null 1编译器认为，if(无else的)、for等操作可能不执行，所以里面的变量初始化会被忽略，若没有初始化则编译器报错 123import java.util.Random;double d = Math.random(); // 返回 [ 0, 1.0 ) 之间的 doubleint num = (int) (Math.random() * 3); // 0-2的整数 1GameCore.rand(int low, int high); // low &lt;= x &lt; high 12345678System.currentTimeMillis() // 返回当前的毫秒事件Date d = new Date(2009-1900,3-1,9); // 需-1900.1.0，为：2009.3.9System.out.println(d1);int year = d.getYear()+1900; getMonth()+1; getDate(); // 年月日getHours(); getMinutes(); getSeconds(); // 时分秒getDat(); //星期几，周日=0，周一=1long time = d.getTime(); // 获取时间的毫秒（相对时间）Date d = new Date(time); // 毫秒转换成时间 1int[][] a = { { 1 }, { 2, 3, 4, 5 }, { 6, 7 } }; // 每一行的列数可以不一样，a[i].length也不一样。 课程视频：如鹏网《这样学Java不枯燥》 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"学习笔记","slug":"学习笔记","permalink":"http://blog.iwxyi.com/tags/学习笔记/"},{"name":"Java","slug":"Java","permalink":"http://blog.iwxyi.com/tags/Java/"},{"name":"游戏开发","slug":"游戏开发","permalink":"http://blog.iwxyi.com/tags/游戏开发/"}]},{"title":"0x3F3F3F3F","date":"2017-09-01T11:40:00.000Z","path":"2017/09/01/0x3F3F3F3F/","text":"0x3f3f3f3f的十进制是1061109567，是10^9级别的（和0x7fffffff一个数量级），而一般场合下的数据都是小于10^9的，所以它可以作为无穷大使用而不致出现数据大于无穷大的情形。 另一方面，由于一般的数据都不会大于10^9，所以当我们把无穷大加上一个数据时，它并不会溢出（这就满足了“无穷大加一个有穷的数依然是无穷大”），事实上0x3f3f3f3f+0x3f3f3f3f=2122219134，这非常大但却没有超过32-bit int的表示范围，所以0x3f3f3f3f还满足了我们“无穷大加无穷大还是无穷大”的需求。 最后，0x3f3f3f3f还能给我们带来一个意想不到的额外好处：如果我们想要将某个数组清零，我们通常会使用memset(a,0,sizeof(a))，方便又高效，但是当我们想将某个数组全部赋值为无穷大时，就不能使用memset函数而得自己写循环了，因为memset是按字节操作的，它能够对数组清零是因为0的每个字节都是0（一般我们只有赋值为-1和0的时候才使用它）。现在好了，如果我们将无穷大设为0x3f3f3f3f，那么奇迹就发生了，0x3f3f3f3f的每个字节都是0x3f！所以要把一段内存全部置为无穷大，我们只需要memset(a,0x3f,sizeof(a))。 所以在通常的场合下，0x3f3f3f3f真的是一个非常棒的选择！ document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"C","slug":"C","permalink":"http://blog.iwxyi.com/tags/C/"}]},{"title":"平衡二叉树AVL","date":"2017-08-04T05:31:00.000Z","path":"2017/08/04/平衡二叉树AVL/","text":"## 二叉查找树 若它的左子树不为空，则左子树上所有的节点值都小于它的根节点值。 若它的右子树不为空，则右子树上所有的节点值均大于它的根节点值。 它的左右子树也分别可以充当为二叉查找树。 img 缺点：大部分节点都倾向一边的情况下时间复杂度几乎是线性的 平衡二叉树 具有二叉查找树的全部特性。 每个节点的左子树和右子树的高度差至多等于1。 右旋我们在进行节点插入的时候，可能会出现节点都倾向于左边的情况，例如： img 我们把这种倾向于左边的情况称之为 左-左型。这个时候，我们就可以对节点9进行右旋操作，使它恢复平衡。 即：顺时针旋转两个节点，使得父节点被自己的左孩子取代，而自己成为自己的右孩子 再举个例子： 节点4和9高度相差大于1。由于是左孩子的高度较高，此时是左-左型，进行右旋。 img 这里要注意，节点4的右孩子成为了节点6的左孩子了 左旋左旋和右旋一样，就是用来解决当大部分节点都偏向右边的时候，通过左旋来还原。例如： 我们把这种倾向于右边的情况称之为 右-右型。 注意：5 成为了 4 的右孩子 右-左旋 img 出现了这种情况怎么办呢?对于这种 右-左型 的情况，单单一次左旋或右旋是不行的。 img 这种我们就把它称之为 右-左 型吧。处理的方法是先对节点10进行右旋把它变成右-右型。 img 然后再进行左旋。 img 所以对于这种 右-左型的，我们需要进行一次右旋再左旋。 同理，也存在 左-右型的，例如： img 对于左-右型的情况和刚才的 右-左型相反，我们需要对它进行一次左旋，再右旋。 img 到此，我们的插入就结束了。 总结在插入的过程中，会出现一下四种情况破坏AVL树的特性，我们可以采取如下相应的旋转。 1、左-左型：做右旋。 2、右-右型：做左旋。 3、左-右型：先做左旋，后做右旋。 4、右-左型：先做右旋，再做左旋。 左右旋感觉怪怪的？ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105//定义节点class AvlNode { int data; AvlNode lchild;//左孩子 AvlNode rchild;//右孩子 int height;//记录节点的高度}//在这里定义各种操作public class AVLTree{ //计算节点的高度 static int height(AvlNode T) { if (T == null) { return -1; }else{ return T.height; } } //左左型，右旋操作 static AvlNode R_Rotate(AvlNode K2) { AvlNode K1; //进行旋转 K1 = K2.lchild; K2.lchild = K1.rchild; K1.rchild = K2; //重新计算节点的高度 K2.height = Math.max(height(K2.lchild), height(K2.rchild)) + 1; K1.height = Math.max(height(K1.lchild), height(K1.rchild)) + 1; return K1; } //右右型，进行左旋 static AvlNode L_Rotate(AvlNode K2) { AvlNode K1; K1 = K2.rchild; K2.rchild = K1.lchild; K1.lchild = K2; //重新计算高度 K2.height = Math.max(height(K2.lchild), height(K2.rchild)) + 1; K1.height = Math.max(height(K1.lchild), height(K1.rchild)) + 1; return K1; } //左-右型，进行右旋，再左旋 static AvlNode R_L_Rotate(AvlNode K3) { //先对其孩子进行右旋 K3.lchild = R_Rotate(K3.lchild); //再进行左旋 return L_Rotate(K3); } //右-左型，先进行左旋，再右旋 static AvlNode L_R_Rotate(AvlNode K3) { //先对孩子进行左旋 K3.rchild = L_Rotate(K3.rchild); //再右旋 return R_Rotate(K3); } //插入数值操作 static AvlNode insert(int data, AvlNode T) { if (T == null) { T = new AvlNode(); T.data = data; T.lchild = T.rchild = null; } else if(data &lt; T.data) { //向左孩子递归插入 T.lchild = insert(data, T.lchild); //进行调整操作 //如果左孩子的高度比右孩子大2 if (height(T.lchild) - height(T.rchild) == 2) { //左-左型 if (data &lt; T.lchild.data) { T = R_Rotate(T); } else { //左-右型 T = R_L_Rotate(T); } } } else if (data &gt; T.data) { T.rchild = insert(data, T.rchild); //进行调整 //右孩子比左孩子高度大2 if(height(T.rchild) - height(T.lchild) == 2) //右-右型 if (data &gt; T.rchild.data) { T = L_Rotate(T); } else { T = L_R_Rotate(T); } } //否则，这个节点已经在书上存在了，我们什么也不做 //重新计算T的高度 T.height = Math.max(height(T.lchild), height(T.rchild)) + 1; return T; }} 参考：https://mp.weixin.qq.com/s/dYP5-fM22BgM3viWg4V44A document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"STL","slug":"STL","permalink":"http://blog.iwxyi.com/tags/STL/"}]},{"title":"二叉树、平衡树、红黑树","date":"2017-08-04T05:29:00.000Z","path":"2017/08/04/二叉树、平衡树、红黑树/","text":"## 1、二叉查找树的缺点 二叉查找树，相信大家都接触过，二叉查找树的特点就是左子树的节点值比父亲节点小，而右子树的节点值比父亲节点大，如图 n 个节点的二叉查找树，正常的情况下，查找的时间复杂度为 O（logn）。 之所以说是正常情况下，是因为二叉查找树有可能出现一种极端的情况，例如 此时的二叉查找树已经近似退化为一条链表，时间复杂度顿时变成了 O(n)，为了解决这个问题，于是我们引申出了平衡二叉树。 2、平衡二叉树平衡二叉树就是为了解决二叉查找树退化成一颗链表而诞生了，平衡树具有如下特点 1、具有二叉查找树的全部特性。 2、每个节点的左子树和右子树的高度差至多等于1。 img 平衡树基于这种特点就可以保证不会出现大量节点偏向于一边的情况了。关于平衡树如何构建、插入、删除、左旋、右旋等操作这里不在说明，具体可以看我之前写的一篇文章：【漫画】以后在有面试官问你AVL树，你就把这篇文章扔给他。 于是，通过平衡树，我们解决了二叉查找树的缺点。对于有 n 个节点的平衡树，最坏的查找时间复杂度也为 O(logn)。 3、为什么有了平衡树还需要红黑树？虽然平衡树解决了二叉查找树退化为近似链表的缺点，能够把查找时间控制在 O(logn)，不过却不是最佳的，因为平衡树要求每个节点的左子树和右子树的高度差至多等于1，这个要求实在是太严了，导致每次进行插入/删除节点的时候，几乎都会破坏平衡树的第二个规则，进而我们都需要通过左旋和右旋来进行调整，使之再次成为一颗符合要求的平衡树。 显然，如果在那种插入、删除很频繁的场景中，平衡树需要频繁着进行调整，这会使平衡树的性能大打折扣，为了解决这个问题，于是有了红黑树，红黑树具有如下特点： 1、具有二叉查找树的特点。 2、根节点是黑色的； 3、每个叶子节点都是黑色的空节点（NIL），也就是说，叶子节点不存数据。 4、任何相邻的节点都不能同时为红色，也就是说，红色节点是被黑色节点隔开的。 5、每个节点，从该节点到达其可达的叶子节点是所有路径，都包含相同数目的黑色节点。 例如下面的图片（注意，图片中黑色的、空的叶子节点没有画出）（图片来自极客时间） 正是由于红黑树的这种特点，使得它能够在最坏情况下，也能在 O(logn) 的时间复杂度查找到某个节点。至于为什么就能够保证时间复杂度为 O(logn)，我这里就不细讲了，后面的文章可能会讲。 不过，与平衡树不同的是，红黑树在插入、删除等操作，不会像平衡树那样，频繁着破坏红黑树的规则，所以不需要频繁着调整，这也是我们为什么大多数情况下使用红黑树的原因。 不过，如果你要说，单单在查找方面的效率的话，平衡树比红黑树快。 所以，我们也可以说，红黑树是一种不大严格的平衡树。也可以说是一个折中发方案。 如果我上面讲的，你都懂，都能够在面试中说出来，应该是足够的了。我当时就是这么回答的。 总结所以，最后的答案是，平衡树是为了解决二叉查找树退化为链表的情况，而红黑树是为了解决平衡树在插入、删除等操作需要频繁调整的情况。 不过，红黑树还有挺多其他的知识点可以考，例如红黑树有哪些应用场景？向集合容器中 HashMap，TreeMap 等，内部结构就用到了红黑树了。还有构建一棵节点个数为 n 的红黑树，时间复杂度是多少？红黑树与哈希表在不同应该场景的选择？红黑树有哪些性质？红黑树各种操作的时间复杂度是多少？ 参考：https://zhuanlan.zhihu.com/p/72505589 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"STL","slug":"STL","permalink":"http://blog.iwxyi.com/tags/STL/"}]},{"title":"Java大数相加示例","date":"2017-03-05T12:02:00.000Z","path":"2017/03/05/Java大数相加/","text":"题目：两个整数和能否整除 86 123456789101112131415161718192021import java.util.Scanner;public class Main { public static void main(String[] args) { Scanner sc = new Scanner(System.in); while(sc.hasNext()) { int a = sc.nextInt(); int b = sc.nextInt(); if ((a + b) % 86 == 0) { System.out.println(\"yes\"); } else { System.out.println(\"no\"); } } }} document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"Java","slug":"Java","permalink":"http://blog.iwxyi.com/tags/Java/"}]},{"title":"正则二三事","date":"2017-01-02T11:40:00.000Z","path":"2017/01/02/正则二三事/","text":"一、校验数字的表达式 1、 数字：^[0-9]*$ 2、 n位的数字：^\\d{n}$ 3、 至少n位的数字：^\\d{n,}$ 4、 m-n位的数字：^\\d{m,n}$ 5、 零和非零开头的数字：^(0|[1-9][0-9]*)$ 6、 非零开头的最多带两位小数的数字：^([1-9][0-9]*)+(.[0-9]{1,2})?$ 7、 带1-2位小数的正数或负数：^(-)?\\d+(.\\d{1,2})?$ 8、 正数、负数、和小数：^(-|+)?\\d+(.\\d+)?$ 9、 有两位小数的正实数：^[0-9]+(.[0-9]{2})?$ 10、 有1~3位小数的正实数：^[0-9]+(.[0-9]{1,3})?$ 11、 非零的正整数：^[1-9]\\d$ 或 ^([1-9][0-9]){1,3}$ 或 ^+?[1-9][0-9]*$ 12、 非零的负整数：^-[1-9][]0-9\"$ 或 ^-[1-9]\\d$ 13、 非负整数：^\\d+$ 或 ^[1-9]\\d*|0$ 14、 非正整数：^-[1-9]\\d*|0$ 或 ^((-\\d+)|(0+))$ 15、 非负浮点数：^\\d+(.\\d+)?$ 或 ^[1-9]\\d.\\d|0.\\d[1-9]\\d|0?.0+|0$ 16、 非正浮点数：^((-\\d+(.\\d+)?)|(0+(.0+)?))$ 或 ^(-([1-9]\\d.\\d|0.\\d[1-9]\\d))|0?.0+|0$ 17、 正浮点数：^[1-9]\\d.\\d|0.\\d[1-9]\\d$ 或 ^(([0-9]+.[0-9][1-9][0-9])|([0-9][1-9][0-9].[0-9]+)|([0-9][1-9][0-9]))$ 18、 负浮点数：^-([1-9]\\d.\\d|0.\\d[1-9]\\d)$ 或 ^(-(([0-9]+.[0-9][1-9][0-9])|([0-9][1-9][0-9].[0-9]+)|([0-9][1-9][0-9])))$ 19、 浮点数：^(-?\\d+)(.\\d+)?$ 或 ^-?([1-9]\\d.\\d|0.\\d[1-9]\\d|0?.0+|0)$ 二、校验字符的表达式 1、 汉字：^[\\u4e00-\\u9fa5]{0,}$ 2、 英文和数字：^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]{4,40}$ 3、 长度为3-20的所有字符：^.{3,20}$ 4、 由26个英文字母组成的字符串：^[A-Za-z]+$ 5、 由26个大写英文字母组成的字符串：^[A-Z]+$ 6、 由26个小写英文字母组成的字符串：^[a-z]+$ 7、 由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$ 8、 由数字、26个英文字母或者下划线组成的字符串：^\\w+$ 或 ^\\w{3,20}$ 9、 中文、英文、数字包括下划线：^[\\u4E00-\\u9FA5A-Za-z0-9_]+$ 10、 中文、英文、数字但不包括下划线等符号：^[\\u4E00-\\u9FA5A-Za-z0-9]+$ 或 ^[\\u4E00-\\u9FA5A-Za-z0-9]{2,20}$ 11、 可以输入含有^%&amp;',;=?$\\\"等字符：[^%&amp;',;=?$\\x22]+ 12、 禁止输入含有~的字符：[^~\\x22]+ 三、特殊需求表达式 1、 Email地址：^\\w+([-+.]\\w+)@\\w+([-.]\\w+).\\w+([-.]\\w+)*$ 2、 域名：[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(/.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+/.? 3、 InternetURL：[a-zA-z]+://[^\\s] 或 ^http://([\\w-]+\\.)+[\\w-]+(/[\\w-./?%&amp;=])?$ 4、 手机号码：^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\\d{8}$ 5、 电话号码(“XXX-XXXXXXX”、”XXXX-XXXXXXXX”、”XXX-XXXXXXX”、”XXX-XXXXXXXX”、”XXXXXXX”和”XXXXXXXX)：^((\\d{3,4}-)|\\d{3.4}-)?\\d{7,8}$ 6、 国内电话号码(0511-4405222、021-87888822)：\\d{3}-\\d{8}|\\d{4}-\\d{7} 7、 身份证号(15位、18位数字)：^\\d{15}|\\d{18}$ 8、 短身份证号码(数字、字母x结尾)：^([0-9]){7,18}(x|X)?$ 或 ^\\d{8,18}|[0-9x]{8,18}|[0-9X]{8,18}?$ 9、 帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$ 10、 密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：^[a-zA-Z]\\w{5,17}$ 11、 强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：^(?=.\\d)(?=.[a-z])(?=.*[A-Z]).{8,10}$ 12、 日期格式：^\\d{4}-\\d{1,2}-\\d{1,2} 13、 一年的12个月(01～09和1～12)：^(0?[1-9]|1[0-2])$ 14 一个月的31天(01～09和1～31)：^((0?[1-9])|((1|2)[0-9])|30|31)$ 15、 钱的输入格式： 1.有四种钱的表示形式我们可以接受:”10000.00” 和 “10,000.00”, 和没有 “分” 的 “10000” 和 “10,000”：^[1-9][0-9]*$ 2.这表示任意一个不以0开头的数字,但是,这也意味着一个字符”0”不通过,所以我们采用下面的形式：^(0|[1-9][0-9]*)$ 3.一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：^(0|-?[1-9][0-9]*)$ 4.这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉,因为钱总不能是负的吧.下面我们要加的是说明可能的小数部分：^[0-9]+(.[0-9]+)?$ 5.必须说明的是,小数点后面至少应该有1位数,所以”10.”是不通过的,但是 “10” 和 “10.2” 是通过的：^[0-9]+(.[0-9]{2})?$ 6.这样我们规定小数点后面必须有两位,如果你认为太苛刻了,可以这样：^[0-9]+(.[0-9]{1,2})?$ 7.这样就允许用户只写一位小数.下面我们该考虑数字中的逗号了,我们可以这样：^[0-9]{1,3}(,[0-9]{3})*(.[0-9]{1,2})?$ 1到3个数字,后面跟着任意个 逗号+3个数字,逗号成为可选,而不是必须：^([0-9]+|[0-9]{1,3}(,[0-9]{3})*)(.[0-9]{1,2})?$ 16、 备注：这就是最终结果了,别忘了”+”可以用”*”替代如果你觉得空字符串也可以接受的话(奇怪,为什么?)最后,别忘了在用函数时去掉去掉那个反斜杠,一般的错误都在这里 17、 xml文件：^([a-zA-Z]+-?)+[a-zA-Z0-9]+\\.[x|X][m|M][l|L]$ 18、 中文字符的正则表达式：[\\u4e00-\\u9fa5] 19、 双字节字符：[^\\x00-\\xff] (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1)) 20、 空白行的正则表达式：\\n\\s*\\r (可以用来删除空白行) 21、 HTML标记的正则表达式：&lt;(\\S?)[^&gt;]&gt;.?&lt;/\\1&gt;|&lt;.? /&gt; (网上流传的版本太糟糕，上面这个也仅仅能部分，对于复杂的嵌套标记依旧无能为力) 22、 首尾空白字符的正则表达式：^\\s|\\s$或(^\\s)|(\\s$) (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式) 23、 腾讯QQ号：[1-9][0-9]{4,} (腾讯QQ号从10000开始) 24、 中国邮政编码：[1-9]\\d{5}(?!\\d) (中国邮政编码为6位数字) 25、 IP地址：\\d+.\\d+.\\d+.\\d+ (提取IP地址时有用) 26、 IP地址：((?:(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)\\.){3}(?:25[0-5]|2[0-4]\\d|[01]?\\d?\\d)) document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"RegExp","slug":"RegExp","permalink":"http://blog.iwxyi.com/tags/RegExp/"}]},{"title":"CGI-C语言也能干大事","date":"2016-07-12T11:42:00.000Z","path":"2016/07/12/CGI-C语言也能干大事/","text":"CGI &amp; DGI123char * qs = getenv(\"QUERY_STRING\");//获取环境变量char username[256];sscanf(qs, \"username=%s\", username);//获取地址栏后面的东西 断点调试：include \\&lt;windows.h&gt;，然后 MessageBoxA(0,\"ok\",\"ok\",0); 让程序启动后暂停，等待着按按钮；浏览器访问CGI，窗口弹出后，在VS中“调试”→“附加到进程”，设置断点，然后在关闭消息对话框。 123printf(\"Location:http://www.baidu.com\\r\\n\");//重定向，302 Found。注意\\r\\nprintf(\"Location:1.html\\r\\n\");//重定向至cgi程序同目录的1.html文件printf(\"Content-Type:text/html;charset=gbk\\r\\n\\r\\n\");//改成 text/plain，为普通文本，显示HTML标签。 注意\\r\\n\\r\\n（两个），表示报文头结束了（各个报文头顺序可调换）源代码中，\\n能换行，但是浏览器上要用&lt;br&gt;才换行，所以用： \\n&lt;br&gt; 12itoa(i, str, x); //int i 转换成 char str[]、x进制的文本int i = atoi(str); //字符串转换成int 1fprintf(cgiOut, \"&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;大家好，Querystring=%s，你的浏览器UserAgent是：%s，你的IP地址是：%s，当前cgi地址：%s&lt;/body&gt;&lt;/html&gt;\", cgiQueryString, cgiUserAgent, cgiRemoteAddr, cgiScriptName);//可以用printf 12cgiFormString(\"name\", name, sizeof name); // 获取用户名：name=xxxif (cgiFormString(\"password\", pwd, sizeof pwd) != cgiFormSuccess);//返回值表示有没有这个值 123456789101112131415161718 &lt;!--点击登陆转到网址：../11.cgi?name=admin&amp;pwd=123， 或者绝对网址：\"http://www.baidu.com\"。 method=\"get\"（默认）或者\"post\"，post时地址栏看不到表单 --&gt;&lt;form action=\"11.cgi\"&gt; 用户名：&lt;input type=\"text\" name=\"name\" value=\"admin\" /&gt; 密 码：&lt;input type=\"password\" name=\"pwd\" value=\"123\" /&gt; &lt;input type=\"submit\" value=\"登陆\" /&gt;&lt;/form&gt; &lt;!--form中的：input、textarea、select 中的名字和值都会提交给服务器 没有name值的表单将不会提交，包括submit。--&gt;&lt;select name=\"se\"&gt;&lt;option value=\"nan\"&gt;男&lt;/option&gt;&lt;option... /option&gt;&lt;/select&gt; &lt;!--提交的值为value属性，如：se=\"nan\"--&gt; &lt;input type=\"checkbox\" name=\"ch\" id=\"chk\" / &gt;&lt;lable for=\"chk\"&gt;我已阅读XXX&lt;/lable&gt; &lt;!--如果勾上了，会有 \"ch=on\" 提交给服务器。 radio 的 name 属性相同的为一组，提交选中的 value--&gt; &lt;input type=\"hidden\" ... /&gt; &lt;!--隐藏的字段，不会显示，但是也会提交--&gt; 1、select、input、textarea必须要在form中。2、当点击input type=\"submit\"的按钮的时候，会把它所在的form中的所有“有name属性的”input/select/textarea的值（value）提交给服务器。3、表单提交的值 input type=\"text\"的值就是用户输入的值； 对于input type=\"checkbox\"的值就是“选中是on，没选中则没有”； 对于inpu type=\"radio“的则是被选中的name、value提交给服务器； 对于input type=\"submit\"的则是被点击的name、value被提交给服务器； 对textarea就是输入的文本； 对于select就是选择项对应的option的value。 123456TMPL_varlist *varlist1 = 0;//空的参数列表 C99cgiHeaderContentType(\"text/html;charset=gbk\");varlist1 = TMPL_add_var(varlist1, \"test1\", \"特斯特1\", \"pwd\", \"小密码\", \"name\", \"小鹏\", 0); // 3对，最后一个必须为0表示可变char *age = \"38\";varlist1 = TMPL_add_var(varlist1, \"age\", age, 0);//执行完了varlist1四对参数TMPL_write(\"P1.htm\", 0, 0, varlist1, cgiOut, cgiOut); 变量使用：&lt;TMPL_VAR name=\"test1\" /&gt;&lt;br /&gt; 123456789TMPL_varlist * varlist1 = 0;TMPL_loop * loopUsers = 0;varlist1 = TMPL_add_var(varlist1, \"Title\", \"测试Loop\", 0);loopUsers = TMPL_add_varlist(loopUsers, TMPL_add_var(0, \"Name\", \"如鹏网\", \"Age\", \"8\", \"Title\", \"t1\", 0));//t1，同一行有的用同一行loopUsers = TMPL_add_varlist(loopUsers, TMPL_add_var(0, \"Name\", \"淘宝\", \"Age\", \"15\", \"Title\", \"t2\", 0));//t2loopUsers = TMPL_add_varlist(loopUsers, TMPL_add_var(0, \"Name\", \"京东\", \"Age\", \"10\", 0));//测试Loop，同一行没有的到上层去找varlist1 = TMPL_add_loop(varlist1, \"users\", loopUsers);//大List里面的小List（name=“users”的Loop）cgiHeaderContentType(\"text/html;charset=gbk\");TMPL_write(\"Users.htm\", 0, 0, varlist1, cgiOut, cgiOut); 12345&lt;table&gt;&lt;tbody&gt;&lt;TMPL_LOOP name=\"users\"&gt; &lt;tr&gt;&lt;td&gt;&lt;TMPL_VAR name=\"Name\" /&gt;&lt;/td&gt; &lt;td&gt;&lt;TMPL_VAR name=\"Age\" /&gt;&lt;/td&gt; &lt;td&gt;&lt;TMPL_VAR name=\"Title\" /&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/TMPL_LOOP&gt;&lt;/tbody&gt; &lt;/table&gt; MySQL 数据库1select * from Students // 表里面的数据 1insert into Students(ID, Name, Gender) value(3, 'asd', 1) // 插入数据，属性值对应（允许为空或者自动递增可不用写） 123update Persons set Name='hehehe',Age=Age+1 // 全部更新表中某几列的数据update Persons set Age=Age+1 where Name='Tom' // 名字为 Tom 的人年龄+1条件用法：where (Age&gt;20 and Age&lt;30) or(Age=80) // or、and、not、&lt;、&gt;、&gt;=、&lt;=、!=（或&lt;&gt;） 12delete from Person where ... // 删除表中的数据，没有where为删除所有drop table Persons // 删除表 1234select Age+1, Name from Persons where...// 显示表中的某几列（Age的列结果为Age+1）select Name 姓名, Age as 年龄 from Persons; // 为列取别名，可以不写asselect 1+1 // 检索不与表关联的数据，结果为2select now() // 返回时间 12345SQL聚合函数：MAX（最大值）、MIN（最小值）、AVG （平均值）、SUM （和）、COUNT（数量）select min(Age), max(Age) from Persons // 最低、最高年龄select count(*) from Persons where Age&gt;25 // 年龄大于25的人数select sum(Age), avg(Age) from Persons // 总年龄和平均年龄select count(Hobbies) from Persons // Hobbies 不为空的数量 12select * from Persons (where……) order by Age ASC, Salary DESC // 按照年龄升序(ASC,不写时默认)、薪水降序(DESC) 排列order 必须放在 where 后面 123单字符通配符：_多字符通配符：% （可以为0个）select * from Persons where Name like 'T%' // 名字为 T 开头的所有 1234nul 代表“不知道”，而不是“没有”。null+1 结果是 nullselect ...... name=null 或者 name != null 或者 nul=null 都没有任何返回结果select name+\"a\" from Personsselect * from Persons where name is (not) null // 判断是不是null 1limit 首行行号（行号从 0 开始）, 最大数目 // limit 必须放在所有语句的最后 12group by Age // 按照年龄分组，相同的为一组（重复的堆到一起）select age, count(*) from Persons group by age // 显示所有年龄段，并且显示数量 12345查询每张订单的订单号、价格、对应的客户姓名以及客户年龄SELECT o.Number 订单编号,o.Price 价格,c.Name 客户姓名,c.Age FROM T_Orders o // 表别名为 oLEFT JOIN T_Customers c ON o.CustomerId=c.Id // 别名为 c，当两个相等的时候，进行连接LEFT JOIN T_OrderTypes t ON o.TypeId=t.Id // 可以 join 多张表WHERE o.Price&gt;=150 // 可添加 where 条件 12设计表——外键——添加，然后删除时会提示无法删除（可设置）删除时、更新时：一般默认RESTRICT（一起删除）；SET NULL（删除后连接的项目设置为NULL）；NO ACTION/RESTRICT（拒绝删除） C + MySQL使用方法：需要修改三个目录，以及复制dll 1、在项目属性中【VC++目录】→“包含目录”，选择mysql的include文件夹；“库目录”选择mysql的lib文件夹；【链接器】→【输入】的“附加依赖项”增加“libmysql.lib”。 2、C代码里include头文件mysql.h，并且在之前要include头文件winsock.h。 3、MYSQL *pConn = mysql_init(0); 4、编译运行，会报错找不到“libmysql.dll”，把mysql的libmysql.dll复制到exe的目录下。 123456789101112131415161718192021222324#include &lt;stdlib.h&gt;#include &lt;stdio.h&gt;#include &lt;winsock.h&gt;#include &lt;mysql.h&gt;int main(){ MYSQL *mysql = mysql_init(0); if(!mysql_real_connect(mysql,\"localhost\",\"root\",\"root\",\"study3\",0,0,0)){ printf(\"连接数据库出错：%s\",mysql_error(mysql)); // mysql的上一次错误信息 goto exit;//goto一般不推荐使用，但是在错误处理的时候，很好用 } printf(\"连接数据库成功！\\n\"); if(mysql_query(mysql,\"set names gbk\")){ // 这样才能用中文。失败时 为 真 printf(\"设定连接编码失败%s\",mysql_error(mysql)); goto exit; } exit: mysql_close(mysql);//程序最后必须关闭连接，否则会有mysql服务器连接过多卡死的可能性 printf(\"exit\"); getchar(); return 0;} execute封装12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;winsock.h&gt;#include &lt;mysql.h&gt;void executeNonQuery(char * sql); // 没有返回值的MYSQL_RES * executeQuery(char * sql); // 有返回值的int main(){ executeNonQuery(\"insert into Persons(name, gender) value('aaa', 1)\"); MYSQL_RES * res = executeQuery(\"select * from Persons\"); MYSQL_ROW row; while (row = mysql_fetch_row(res)) { char * un = row[0]; char * pwd = row[1]; printf(\"username = %s, password = %s\\n\", un, pwd); } system(\"pause\"); return 0;}void executeNonQuery(char * sql){ MYSQL * pConn = mysql_init(0); if (!mysql_real_connect(pConn, \"localhost\", \"root\", \"root\", \"test\", 0, 0, 0)) { printf(\"连接失败：%s\\n\", mysql_error(pConn)); goto endd; } if (mysql_query(pConn, \"set names gbk\")) { printf(\"设置gbk失败：%s\\n\", mysql_error(pConn)); goto endd; } if (mysql_query(pConn, sql)) { printf(\"查询失败：%s\\n\", mysql_error(pConn)); goto endd; }endd: mysql_close(pConn);}MYSQL_RES * executeQuery(char * sql){ MYSQL * pConn = mysql_init(0); if (!mysql_real_connect(pConn, \"localhost\", \"root\", \"root\", \"test\", 0, 0, 0)) { printf(\"连接失败：%s\\n\", mysql_error(pConn)); return \"\"; } if (mysql_query(pConn, \"set names gbk\")) { printf(\"设置gbk失败：%s\\n\", mysql_error(pConn)); return \"\"; } if (mysql_query(pConn, sql)) { printf(\"查询失败：%s\\n\", mysql_error(pConn)); return \"\"; } MYSQL_RES * result = mysql_store_result(pConn); mysql_close(pConn); return result;} 表单数据12345char sql[1024]={0}; // 把用户输入的字符串动态拼接生成sql语句char userName, hexUserName[1024]={0}; // 把可能含有特殊符号的字符串进行16进制转换mysql_hex_string(hexUserName, userName, strlen(userName)); // 转换成安全的16进制sprintf(sql, \"Insert into T_Users(UserName,Password) values(0x%s,'%s')\", hexUserName,password);// 可以直接识别命令里面0x开头的16进制数据，并自动转换成原来的字符串(数字 0，不是 英文o) 123int age;cgiFormInteger(\"age\", &amp;age, 100); // 获取整型表单。注意，是地址！最后一个是失败后的age默认值// 例如，当 \"age=aaa\" 时，取不到整型的值，所以 age = 100 1234567int len; // 用来决定需要申请的长度char *txt;TMPL_varlist *varlist = 0;cgiFormStringSpaceNeeded(\"txt1\",&amp;len); // 用于获取可能会非常长的值的长度txt = (char *)malloc(len+1); // 动态申请内存cgiFormString(\"txt1\",txt,len);free(txt); // 最后别忘了 free 12if(cgiFormCheckboxSingle(\"agree\")!=cgiFormSuccess) // 多选框是否选中&lt;select&gt;&lt;option&gt;xxx&lt;/option&gt;&lt;/select&gt; 和 \"radio\" 都用 cgiFormString 来获取是否输入 文件操作HTML文件123&lt;form method=\"post\" enctype=\"multipart/form-data\"&gt; // 必须这样写 &lt;input type=\"file\" name=\"f1\"&gt;&lt;/form&gt; 文件参数 cgiFormFileName：上传的文件名 cgiFormFileSize：文件大小（单位为B） cgiFormFileRead：读取上传文件 cgiFormFileClose：关闭上传的文件 判断有没有上传文件1if(cgiFormFileName(\"file1\",uploadfilename,sizeof(uploadfilename))!=cgiFormSuccess) 获取扩展名1234_splitpath(uploadfilename,NULL,NULL,NULL,fileExt); // &lt;stdlib.h&gt;中 参数：全路径指针，盘符（带冒号），路径（纯目录无盘符，如 /aaa/），文件名（不包含后缀名），后缀名（带点） 文件格式：d:/aaa/bbb.jpgif(stricmp(fileExt,\".jpg\")!=0&amp;&amp;stricmp(fileExt,\".png\"))…… // stricmp 为不区分大小写的比较 获取文件大小12cgiFormFileSize(\"file1\",&amp;filesize);if(filesize&gt;1024*1024)…… // 1024 * 1024 = 1 M 总的操作12345678910111213cgiFilePtr file1; // 声明类似文件指针的变量，网络文件指针//读取本地文件，用于写入，本地文件指针FILE *fileLocal = fopen(uploadfilename,\"wb\"); // C语言读取文件，wb是二进制模式，默认是用文本char buffer[1024]; // 每次最多1024kbint lenRead; // 实际读的字节数cgiFormFileOpen(\"file1\",&amp;file1);while(cgiFormFileRead(file1,buffer,sizeof(buffer),&amp;lenRead)==cgiFormSuccess){ fwrite(buffer,lenRead,1,fileLocal); // buffer[] 的前 lenRead 字节写入到 fileLocal 中}fclose(fileLocal);cgiFormFileClose(file1);printFileUploadMsg(\"上传成功\"); 如鹏网《C语言也能干大事》学习笔记 document.querySelectorAll('.github-emoji') .forEach(el => { if (!el.dataset.src) { return; } const img = document.createElement('img'); img.style = 'display:none !important;'; img.src = el.dataset.src; img.addEventListener('error', () => { img.remove(); el.style.color = 'inherit'; el.style.backgroundImage = 'none'; el.style.background = 'none'; }); img.addEventListener('load', () => { img.remove(); }); document.body.appendChild(img); });","tags":[{"name":"C","slug":"C","permalink":"http://blog.iwxyi.com/tags/C/"},{"name":"学习笔记","slug":"学习笔记","permalink":"http://blog.iwxyi.com/tags/学习笔记/"},{"name":"CGI","slug":"CGI","permalink":"http://blog.iwxyi.com/tags/CGI/"},{"name":"Web","slug":"Web","permalink":"http://blog.iwxyi.com/tags/Web/"}]}]