<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
    <meta http-equiv="Content-Language" content="zh-cn">
    <meta charset="utf-8">
    
    
    <link rel="canonical" href="http://blog.iwxyi.com/2018/05/07/MFC函数总结/">
    
    
    <title>MFC函数总结 | 云笺 | 一些技术摘要和写作技巧</title>
    <meta name="viewport" content="width=device-width,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no">
    
    <meta name="theme-color" content="#77AAFF">
    
    
    <meta name="keywords" content="C++,整理,MFC">
    
    

    

    <!-- Baidu Push -->
<script>
	(function(){
		var bp = document.createElement('script');
		var curProtocol = window.location.protocol.split(':')[0];
		if (curProtocol === 'https') {
			bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
		}
		else {
			bp.src = 'http://push.zhanzhang.baidu.com/push.js';
		}
		var s = document.getElementsByTagName("script")[0];
		s.parentNode.insertBefore(bp, s);
	})();

	var _hmt = _hmt || [];
</script>



    
    <meta name="description" content="1、MFC编辑框、静态文本框相关的常用函数 《1》GetDlgItemText(ID ,str) 作用：从对话框中获取文本 第一个参数为要获取的编辑框(或者静态文本框、单选按钮等可以显示内容的控件)的ID，第二个参数为字符串(Cstring 类型)的变量，获取的文本存储在str中。">
<meta name="keywords" content="C++,整理,MFC">
<meta property="og:type" content="article">
<meta property="og:title" content="MFC函数总结">
<meta property="og:url" content="http://blog.iwxyi.com/2018/05/07/MFC函数总结/index.html">
<meta property="og:site_name" content="云笺">
<meta property="og:description" content="1、MFC编辑框、静态文本框相关的常用函数 《1》GetDlgItemText(ID ,str) 作用：从对话框中获取文本 第一个参数为要获取的编辑框(或者静态文本框、单选按钮等可以显示内容的控件)的ID，第二个参数为字符串(Cstring 类型)的变量，获取的文本存储在str中。">
<meta property="og:locale" content="zh-CN">
<meta property="og:updated_time" content="2019-10-13T01:05:57.916Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="MFC函数总结">
<meta name="twitter:description" content="1、MFC编辑框、静态文本框相关的常用函数 《1》GetDlgItemText(ID ,str) 作用：从对话框中获取文本 第一个参数为要获取的编辑框(或者静态文本框、单选按钮等可以显示内容的控件)的ID，第二个参数为字符串(Cstring 类型)的变量，获取的文本存储在str中。">
    
        <link rel="alternate" type="application/atom+xml" title="云笺" href="/atom.xml">
    
    <link rel="shortcut icon" href="/img/favicon.ico">
    <link id="style" rel="stylesheet" href="/css/style.css?v=3.0">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    
            
</head>

<body>
    <div id="loading" class="active"></div>
    <aside id="menu"  class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" >
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/avatar.jpg" alt="avatar">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname" id="name">命燃芯乂</h5>
          
            <div id="yiyanmotto" class="motto">&nbsp;</div>
          
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
              <li class="waves-block waves-effect">
                  <a href="/"  >
                    <i class="icon icon-lg icon-home"></i>
                    <span>主 页</span><i class="icon icon-lg icon-caret-left"></i>
                  </a>
              </li>
            
              <li class="waves-block waves-effect">
                  <a href="/archives"  >
                    <i class="icon icon-lg icon-archives"></i>
                    <span>归 档</span><i class="icon icon-lg icon-caret-left"></i>
                  </a>
              </li>
            
              <li class="waves-block waves-effect">
                  <a href="/categories"  >
                    <i class="icon icon-lg icon-th-list"></i>
                    <span>分 类</span><i class="icon icon-lg icon-caret-left"></i>
                  </a>
              </li>
            
              <li class="waves-block waves-effect">
                  <a href="/tags"  >
                    <i class="icon icon-lg icon-tags"></i>
                    <span>标 签</span><i class="icon icon-lg icon-caret-left"></i>
                  </a>
              </li>
            
              <li class="waves-block waves-effect">
                  <a href="/about"  >
                    <i class="icon icon-lg icon-smile-o"></i>
                    <span>关 于</span><i class="icon icon-lg icon-caret-left"></i>
                  </a>
              </li>
            
      <div class="nav2">
          
              <a class="nav2item" data-title="Email" href="mailto:wxy@iwxyi.com" target="_parent"title="Email" >
                <i class="icon icon-lg icon-envelope-o envelope-o"></i>
              </a>
          
              <a class="nav2item" data-title="Github" href="https://github.com/mrxy001" target="_blank"title="Github" >
                <i class="icon icon-lg icon-github github"></i>
              </a>
          
              <a class="nav2item" data-title="微博" href="https://weibo.com/u/6065548594" target="_blank"title="微博" >
                <i class="icon icon-lg icon-weibo weibo"></i>
              </a>
          

            </div>
        
      </ul>
        
    </div>
  </div>
 
</aside>


    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">MFC函数总结</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        <a href="../../atom.xml" target="_blank" class="header-icon waves-effect waves-circle waves-light" id="Rss">
            <i class="icon icon-lg icon-rss"></i>
        </a>
    </div>
</header>
<header class="content-header post-header">
    
    
    <div class="container fade-scale">
        <div id="myheader">
            <h1 class="title">
                
            </h1>
            <h5 class="subtitle">
                
                
            </h5>
        </div>
    </div>

</header>


<div class="container body-wrap">
    
<article id="post-MFC函数总结"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">MFC函数总结</h1>
        <div class="post-meta">
            <i class="icon icon-lg icon-calendar-o"></i>
            发表于
            <time class="post-time" title="2018-05-07 08:43:00" datetime="2018-05-07T00:43:00.000Z"  itemprop="datePublished">2018-05-07</time>

            <br id="mybreak"/>
            
	<i class="icon icon-lg icon-folder-o"></i>
	分类：<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/Code/">Code</a></li></ul>


            <i>·</i>
            
<span id="busuanzi_container_page_pv" title="文章总阅读量" style='display:none'>
    <i class="icon icon-eye icon-pr"></i><span id="busuanzi_value_page_pv"></span>次浏览
</span>


        </div>
        <div class="post-count-custom">
            <i class="icon icon-lg icon-comment-o"></i>
            阅读本文可能花费您&nbsp;<span class="post-count">19</span>&nbsp;分钟
        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <p><strong>1、MFC编辑框、静态文本框相关的常用函数</strong></p>
<p>《1》<code>GetDlgItemText(ID ,str)</code></p>
<p>作用：从对话框中获取文本</p>
<p>第一个参数为要获取的编辑框(或者静态文本框、单选按钮等可以显示内容的控件)的ID，第二个参数为字符串(Cstring 类型)的变量，获取的文本存储在str中。</p>
<a id="more"></a>

<p>《2》<code>SetDlgItemText(ID,str)</code></p>
<p>作用：将字符串显示在控件中</p>
<p>第一个参数为要显示的编辑框(或者静态文本框、单选按钮、组合框等可以显示内容的控件)的ID，第二个参数为字符串(Cstring 类型)的变量，显示的文本存储在str中。如果要显示的变量的类型不是Cstring，则通过Format函数强制转换。</p>
<p>通常还要加一个<code>UpDateData(FALSE)</code>。</p>
<p>《3》<code>UINT nID=GetCheckedRadioButton(IDC1, IDC2);</code></p>
<p>作用：获取单选框的选项的ID</p>
<p>第一个参数为该组合框中第一个单选按钮的ID，第二个参数为该组合框中最后一个按钮的ID。</p>
<p>《4》<code>CheckRadioButton(IDC1, IDC2, IDC3);</code></p>
<p>作用：初始化单选按钮</p>
<p>第一个参数为该组合框中第一个单选按钮的ID，第二个参数为该组合框中最后一个按钮的ID，第三个参数为为缺省选项的ID。</p>
<p>《5》<code>m_scrollBar.SetScrollRange(0, 500) ;</code></p>
<p>作用：设置水平滚动条的取值范围，m_scrollBar为水平滚动条的控制类型的变量，0为设置最小值，500为设置的最大值。</p>
<p>《6》<code>m_nAmount = m_slider.GetPos() ;</code></p>
<p>作用：获取滑块的当前位置。</p>
<p>《7》<code>m_slider.SetRange(0,1000) ;</code></p>
<p>作用：设置滑块取值范围</p>
<p>第一个参数为设置的最小值，第二个参数为设置的最大值。</p>
<p>《8》<code>double Volum = atof(strCtrl);</code></p>
<p>作用：将字符串strCtl转换成浮点型的Volum</p>
<p>《9》<code>int Volum = atof(strCtrl);</code></p>
<p>作用：将字符串strCtl转换成整型的Volum</p>
<p>《10》<code>MessageBox(str) ;</code>（局部函数）</p>
<p>作用：输出字符串str</p>
<p>《11》<code>AfxMessageBox(str) ;</code>（全局函数）</p>
<p>作用：输出字符串str</p>
<p>《12》<code>tempt = m_time2.Format("%H:%m:%S") ;</code></p>
<p>作用：将时间转化成字符型（时、分、秒）</p>
<p>m_time2为日历时间选取器的变量，tempt为CString型变量</p>
<p>《13》<code>tempt = m_time.Format("%Y-%m-%d") ;</code>//将时间转化成字符型</p>
<p>作用：将时间转化成字符型（年、月、日）</p>
<p>m_time2为日历时间选取器的变量，tempt为CString型变量</p>
<p>《14》<code>m_time = CTime::GetCurrentTime();</code></p>
<p>作用：获取系统当前时间</p>
<p>m_time为Ctime类型的变量。</p>
<p>《15》<code>m_list.AddString(str);</code></p>
<p>功能：将Cstrig类型的变量的内容显示在列表框中(或者组合框中)。</p>
<p>m_str为ClistBox类型的变量（或者是CcomboBox类型的变量）。</p>
<p>《16》<code>m_time = CTime(2012 ,5 ,28 ,0 ,0 ,0) ;</code></p>
<p>功能：初始化日期</p>
<p>m_time为Ctime类型的变量</p>
<p>《17》<code>str.TrimLeft();</code></p>
<p>功能：去掉Cstring类型变量的左边的空格</p>
<p>《18》<code>str.TrimRight();</code></p>
<p>功能：去掉Cstring类型变量的右边的空格</p>
<p>《19》<code>str.IsEmpty();</code></p>
<p>功能：判断Cstring类型的变量str是否为空，如果为空则返回1，否则返回零。</p>
<p>《20》<code>int nIndex=m_list.FindString(int k,str);</code></p>
<p>功能：列表框中查找与str匹配的列表项，m_list为ClistBox类型变量。</p>
<p>从第k个位置开始查找，若为-1，则从头至尾查找。</p>
<p>函数原型：</p>
<p><code>int FindString(int nStartAfter,LPCTSTR lpszItem) const;</code></p>
<p><code>int FindStringExact(int nIndexStart,LPCTSTR lpszFind) const;</code></p>
<p>其中，<code>FindStringExact</code>的查找精度最高</p>
<p>《21》<code>m_list.ResetContent() ;</code></p>
<p>功能：清空列表框中的内容</p>
<p>m_list为ClistBox类型变量。</p>
<p>《22》<code>m_listSearch.DeleteString(int  nIndex);</code></p>
<p>功能：删除列表框中的第nIndex条记录。</p>
<p>m_listSearch为ClistBox类型变量。</p>
<p>《23》<code>GetDlgItem(IDC_BUTTON_DELETE)-&gt;EnableWindow(FALSE);</code></p>
<p>功能：是ID为IDC_BUTTON_DELETE的按钮灰选。</p>
<p>《24》<code>GetDlgItem(IDC_BUTTON_DELETE)-&gt;EnableWindow(TRUE);</code></p>
<p>功能：是ID为IDC_BUTTON_DELETE的按钮还原。</p>
<p>《25》<code>str.Left(length);</code></p>
<p>功能：获取字符串str左边长度为length的值。</p>
<p>《26》<code>int length = str.GetLength() ;</code></p>
<p>功能：获取字符串str的长度</p>
<p>《27》<code>dlg.DoModal() ;</code></p>
<p>功能：建立一个对话框</p>
<p>dlg为该对话框的类的对象。</p>
<p>《28》<code>CDialog::OnCancel();</code></p>
<p>功能：关闭窗口</p>
<p>《29》<code>CMenu* pSysMenu=GetMenu();</code></p>
<p>功能：获取程序菜单指针</p>
<p>《30》<code>int nCount=pSysMenu-&gt;GetMenuItemCount();</code></p>
<p>功能：获取项层菜单项的项数</p>
<p>《31》<code>int nIndex=m_ListBox.GetCurSel();</code></p>
<p>功能：获取指针在列表框中的位置</p>
<p>m_ListBox为ClistBox类型变量。</p>
<p>《32》<code>GetWindowText(str) ;</code></p>
<p>功能：获取当前窗口的标题</p>
<p>Str为Cstring 类型的变量</p>
<p>《33》<code>GetDlgItem(IDC_CLICKHERE)-&gt;SetFocus();</code></p>
<p>将光标设置在控件IDC_CLICKHERE处,若是在打开某个对话框时候做此设置，则将该语句加到消息处理函数OnInitDialog的return语句前，并且将最后的语句 return TRUE; 该为 return FALSE;</p>
<p><code>GetDlgItem(IDC_CLICKHERE)-&gt;SetFocus();</code>也可写成<code>m_strit.SetFocus();</code></p>
<p>其中m_strit为该控件对应的变量。</p>
<p>《34》<code>GetDlgItem(IDC_STATIC_NUMBER1)</code></p>
<p>功能：获取ID为IDC_STATIC_NUMBER1控件的指针.</p>
<p>例如：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CString str ;</span><br><span class="line">GetDlgItem(IDC_STATIC_NUMBER1)-&gt;GetWindowText(str) ;<span class="comment">//此句等价于</span></span><br><span class="line">GetDlgItemText(IDC_STATIC_NUMBER1,str);</span><br></pre></td></tr></tbody></table></figure>

<p>《35》<code>int  num1 = GetDlgItemInt(IDC_EDIT1);</code></p>
<p>功能：获取ID为IDC_EDIT1控件的文本并且转化成整形的值，如果文本中含有非数字字符则转化失败.</p>
<p>《36》<code>SetDlgItemInt(IDC_EDIT3,num3) ;</code></p>
<p>功能：将整数num3显示在ID为IDC_EDIT3的编辑框中.</p>
<p>《37》<code>::SendMessage(GetDlgItem(IDC_EDIT1)-&gt;m_hWnd,WM_GETTEXT,10,(LPARAM)ch1);</code></p>
<p>注意：在函数前面加上作用域分节符表示调用的是全局函数.</p>
<p>功能：取ID为IDC_EDIT1控件的文本,获取的最大长度为10，并且将获取的内容存储在ch1中.相当于<code>GetDlgItemText(IDC_EDIT1,ch1,10);</code></p>
<p>说明：第一个参数为对应控件的句柄，第二个参数为消息名称，第三个参数为获取文本的最大长度，第四个参数为存储文本的缓冲区，此处ch1为字符数组,即 char ch1[10];第四个参数的类型必须强制转换成LPARAM.</p>
<p>此函数有多种调用方式，其功能是相同的。列举如下：</p>
<p>(1) <code>::SendMessage(GetDlgItem(IDC_EDIT1)-&gt;m_hWnd,WM_GETTEXT,10,(LPARAM)ch1);</code></p>
<p>(2) <code>GetDlgItem(IDC_EDIT1)-&gt;SendMessage(WM_GETTEXT,10,(LPARAM)ch1);</code></p>
<p>(3) <code>m_edit1.SendMessage(WM_GETTEXT,10,(LPARAM)ch1);</code></p>
<p>(4) <code>::SendMessage(m_edit1.m_hWnd,WM_GETTEXT,10,(LPARAM)ch1);</code></p>
<p>其中m_edit1是IDC_EDIT1控件的类别为Control，类型为CEdit的变量.</p>
<p>《38》<code>::SendMessage(GetDlgItem(IDC_EDIT3)-&gt;m_hWnd,WM_SETTEXT,0,(LPARAM)ch3);</code></p>
<p>功能：将缓冲区ch3的内容显示在D为IDC_EDIT1控件上.其作用相当于<code>SetDlgItemText(IDC_EDIT1,ch1);</code></p>
<p>说明：第一个参数为对应控件的句柄，第二个参数为消息名称，第三个参数用不上，故设置为零，第四个参数为要显示的文本内容, 第四个参数的类型必须强制转换成LPARAM.</p>
<p>《39》<code>SendDlgItemMessage(IDC_EDIT1,WM_GETTEXT,10,(LPARAM)ch1);</code></p>
<p>功能等价于<code>::SendMessage(GetDlgItem(IDC_EDIT1)-&gt;m_hWnd,WM_GETTEXT,10,(LPARAM)ch1);</code></p>
<p>《40》<code>SendDlgItemMessage(IDC_EDIT3,WM_SETTEXT,0,(LPARAM)ch3);</code></p>
<p>功能等价于<code>::SendMessage(GetDlgItem(IDC_EDIT3)-&gt;m_hWnd,WM_SETTEXT,0,(LPARAM)ch3);</code></p>
<p><strong>2、常用函数（比较全）</strong></p>
<ul>
<li><code>WinExec()</code></li>
<li><code>ExitWindowsEx()</code></li>
<li><code>GlobalMemoryStatus()</code></li>
<li><code>GetSystemInfo()</code></li>
<li><code>GetSystemDirectory()</code></li>
<li><code>GetWindowsDirectory()</code></li>
<li><code>GetTaskmanWindow()</code> user32.dll中 获取任务栏窗口句柄</li>
<li><code>OpenProcessToken()</code> 打开一个进程的访问令牌</li>
<li><code>GetCurrentProcess()</code> 获取本进程句柄</li>
<li><code>LookupPrivilegeValue()</code> 修改进程权限</li>
<li><code>AdjustTokenProvileges()</code> 通知WindowsNT修改本进程权利</li>
<li><code>CreateRectRgn()</code></li>
<li><code>CreateEllipticRgnIndirect()</code></li>
<li><code>PtInRegion()</code></li>
<li><code>CommandToIndex()</code> ID号转换为索引值</li>
</ul>
<p>菜单类:</p>
<ul>
<li><code>DrawMenuBar()</code> 重画菜单</li>
<li><code>SetDefaultItem()</code> 设置默认菜单项</li>
<li><code>CheckMenuItem()</code>设置菜单项Check状态</li>
<li><code>CreatePopupMenu()</code>创建弹出菜单</li>
</ul>
<p>窗口类:</p>
<ul>
<li><code>MoveWindow()</code></li>
<li><code>Invalidate()</code>使窗口无效,窗口无效时会进行窗口重绘</li>
<li><code>GetParent()</code> 获得窗口的父窗口句柄</li>
<li><code>BringWindowToTop()</code>把窗口放到顶部</li>
<li><code>SetWindowPos()</code></li>
<li><code>DeferWindowPos()</code></li>
<li><code>SetActiveWindow()</code>激活顶层窗口</li>
<li><code>Set/GetForegroundWindow()</code> 设置/获取前台窗口,返回句柄</li>
<li><code>Set/GetWindowLong()</code>改变窗口属性</li>
<li><code>GetNextWindow()</code>获取下一个窗口句柄</li>
<li><code>GetWindow()</code> 获取窗口句柄</li>
<li><code>FromHandle()</code> 通过句柄获取指针</li>
<li><code>AfxGetInstanceHandle()</code>获取程序当前实例句柄</li>
<li><code>AfxRegisterWndClass()</code></li>
<li><code>Set/GetClassLong()</code></li>
<li><code>Set/GetWindowLong()</code></li>
<li><code>GetWindowRect()</code>获取窗口在屏幕中的Rect</li>
</ul>
<p>对话框:</p>
<ul>
<li><code>GetDlgItem()</code></li>
<li><code>Set/GetDlgItemText()</code></li>
<li><code>Set/GetDlgItemInt()</code></li>
<li><code>Set/GetDlgItem()</code></li>
<li><code>SendDlgItemMessage()</code></li>
<li><code>SetFocus()</code>文本编辑框Edit控件若要响应回车按键消息，必须设置为多行类型</li>
<li><code>GetNextDlgTabItem()</code>获取下一个有TABStop属性的控件句柄</li>
<li><code>OnCtlColor()</code> WM_CTLCOLOR窗口绘制消息响应函数</li>
<li><code>GetDlgCtrlID()</code></li>
<li><code>SetButtonText()</code>设置按钮文本CreateRectRgn</li>
<li><code>GetStartPosition()</code></li>
<li><code>GetNextPathName()</code></li>
<li><code>SetHorizontalExtent()</code></li>
<li><code>SHBrowseForFolder()</code></li>
</ul>
<p>属性表单:</p>
<ul>
<li><code>SetWizardMode()</code></li>
<li><code>SetWizardButtons()</code></li>
<li><code>OnSetActive()</code></li>
</ul>
<p>工具栏:</p>
<ul>
<li><code>RecalcLayout()</code></li>
<li><code>ShowControlBar()</code></li>
</ul>
<p>状态栏:</p>
<ul>
<li><code>CommandToIndex()</code> 根据ID号获取索引值</li>
<li><code>SetMessageText()</code></li>
<li><code>GetMessageBar()</code></li>
<li><code>GetDescendantWindow()</code></li>
</ul>
<p>图形类</p>
<ul>
<li><p><code>OnEraseBkgnd()</code></p>
</li>
<li><p><code>CButton::DrawItem()</code></p>
</li>
<li><p><code>SetBkMode()</code>设置文字背景</p>
</li>
<li><p><code>SetTextColor()</code></p>
</li>
<li><p><code>SetBkColor()</code></p>
</li>
<li><p><code>SetROP2()</code></p>
</li>
<li><p><code>SetClipRtn()</code></p>
</li>
<li><p><code>DrawText()</code></p>
</li>
<li><p><code>BeginPath()</code></p>
</li>
<li><p><code>EndPath()</code></p>
</li>
<li><p><code>BeginPaint()</code></p>
</li>
<li><p><code>EndPaint()</code></p>
</li>
<li><p><code>GetTextExtend()</code></p>
</li>
<li><p><code>SetWorldTransform()</code></p>
</li>
<li><p><code>GetDeviceCaps()</code></p>
</li>
<li><p><code>Set/GetViewportOrg()</code></p>
</li>
<li><p><code>Set/GetWindowOrg()</code></p>
</li>
<li><p><code>DPtoLP()</code>将设备坐标点转换为逻辑坐标点</p>
</li>
<li><p><code>LPtoDP()</code>将逻辑坐标点转换为设备坐标点</p>
</li>
<li><p><code>DeleteMetaFile()</code></p>
</li>
<li><p><code>CopyMetaFile()</code></p>
</li>
<li><p><code>GetMetaFile()</code></p>
</li>
<li><p><code>GetEnhMetaFile()</code></p>
</li>
<li><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> CView::OnPaint()</span><br><span class="line">{</span><br><span class="line">    <span class="function">CPaintDC <span class="title">dc</span><span class="params">(<span class="keyword">this</span>)</span></span>;</span><br><span class="line">    OnPrepareDC(&amp;dc);</span><br><span class="line">    OnDraw(&amp;dc);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

</li>
</ul>
<p>文件操作:</p>
<ul>
<li><p><code>EncryptFile()</code></p>
</li>
<li><p><code>CreateFile()</code></p>
</li>
<li><p><code>ReadFile()</code></p>
</li>
<li><p><code>WriteFile()</code></p>
</li>
<li><p><code>SetFilePointer()</code></p>
</li>
<li><p><code>::WriteProfileString()</code> 向win.ini写入相关信息</p>
</li>
<li><p><code>::GetProfileString()</code> 从win.ini获取相关信息</p>
</li>
<li><p><code>CWinApp::WriteProfileString()</code>向注册表中写入相关信息</p>
</li>
<li><p><code>CWinApp::GetProfileString()</code> 从注册表中获取相关信息</p>
</li>
<li><p><code>::WritePrivateProfileString()</code></p>
</li>
<li><p><code>RegCreateKeyEx()</code>创建注册表项</p>
</li>
<li><p><code>RegCloseKey()</code>关闭注册表项</p>
</li>
<li><p><code>RegOpenKeyEx()</code> 打开注册表项</p>
</li>
<li><p><code>RegSetValueEx()</code> 写入注册表项</p>
</li>
<li><p><code>RegQueryValueEx()</code> 读取注册表项</p>
</li>
<li><p><code>RegEnumKeyEx()</code></p>
</li>
<li><p><code>RegDeleteKey()</code></p>
</li>
</ul>
<p>文档视图:</p>
<p>钩子:</p>
<ul>
<li><code>SetWindowsHookEx()</code></li>
<li><code>CallNextHookEx()</code></li>
<li><code>UnhookWindowsHookEx()</code></li>
<li><code>GetCurrentThreadID()</code></li>
<li><code>GetModuleHandle()</code></li>
</ul>
<p>动态库:</p>
<ul>
<li><code>#pragma data_seg()</code></li>
<li><code>#pragma comment(linker,"/section:XXX,RWS")</code> R可读W可写S共享</li>
<li><code>SEGMENTS</code></li>
<li><code>XXX READ WRITE SHARED</code></li>
<li><code>MAKEINTRESOURCE()</code></li>
<li><code>GetProcAddress()</code>获取函数地址</li>
<li><code>LoadLibrary()</code>加载Dll</li>
<li><code>FreeLibrary()</code>减少Dll的引用计数</li>
</ul>
<p>多线程:</p>
<ul>
<li><code>CreateThread()</code></li>
<li><code>CloseHandle()</code></li>
</ul>
<p>互斥:</p>
<ul>
<li><p><code>CreateMutex()</code></p>
</li>
<li><p><code>ReleaseMutex()</code></p>
</li>
<li><p><code>WaitForSingleObject()</code></p>
</li>
</ul>
<p>事件:</p>
<ul>
<li><p><code>CreateEvent()</code></p>
</li>
<li><p><code>SetEvent()</code> 设置有信号状态</p>
</li>
<li><p><code>ResetEvent()</code> 设置无信号状态</p>
</li>
</ul>
<p>临界区:</p>
<ul>
<li><p><code>EnterCriticalSection()</code></p>
</li>
<li><p><code>InitializeCriticalSection()</code></p>
</li>
<li><p><code>LeaveCriticalSection()</code></p>
</li>
<li><p><code>DeleteCriticalSection()</code></p>
</li>
</ul>
<p>异步套接字:</p>
<ul>
<li><p><code>WSAAsyncSelect()</code> 为一个套接字请求网络消息通知</p>
</li>
<li><p><code>WSAEnumProtocols()</code>检索可用的网络通信协议</p>
</li>
<li><p><code>WSASocket()</code></p>
</li>
</ul>
<p>剪贴板:</p>
<ul>
<li><p><code>OpenClipboard()</code> 打开剪贴板</p>
</li>
<li><p><code>CloseClipboard()</code>关闭剪贴板</p>
</li>
<li><p><code>EmptyClipboard()</code>清空剪贴板</p>
</li>
<li><p><code>SetClipboardData()</code></p>
</li>
<li><p><code>GetClipboardData()</code></p>
</li>
<li><p><code>GlobalAlloc()</code></p>
</li>
<li><p><code>GlobalLock()</code></p>
</li>
<li><p><code>GlobalUnlock()</code></p>
</li>
<li><p><code>IsClipboardFormatAvailable()</code></p>
</li>
</ul>
<p>匿名管道:</p>
<ul>
<li><p><code>CreatePipe()</code></p>
</li>
<li><p><code>CreateProcess()</code></p>
</li>
<li><p><code>CreateFile()</code></p>
</li>
<li><p><code>ReadFile()</code></p>
</li>
<li><p><code>WriteFile()</code></p>
</li>
</ul>
<p>命名管道:</p>
<ul>
<li><p><code>CreateNamedPipe()</code></p>
</li>
<li><p><code>ConnectNamedPipe()</code></p>
</li>
<li><p><code>WaitNamedPipe()</code></p>
</li>
<li><p><code>CreateFile()</code></p>
</li>
<li><p><code>ReadFile()</code></p>
</li>
<li><p><code>WriteFile()</code></p>
</li>
</ul>
<p>邮槽:</p>
<ul>
<li><code>CreateMailslot()</code></li>
</ul>
<p>多媒体:</p>
<ul>
<li><code>mciSendCommand()</code> <code>&lt;mmsystem.h&gt;</code></li>
</ul>
<p>窗口、控件的指针和句柄的相互转化</p>
<p>1指针转化为句柄</p>
<p>在MFC应用程序中首先要获得窗口的指针，然后将其转化为句柄</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CWnd* pWnd;</span><br><span class="line">HANDLE hWnd = pWnd-&gt;GetSafeHwnd();</span><br></pre></td></tr></tbody></table></figure>

<p>2句柄转化为指针</p>
<p>在MFC应用程序中首先获得对话框控件的句柄，然后获得其指针</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">HANDLE hWnd;</span><br><span class="line">GetDlgItem(IDC_xxx,&amp;hWnd);</span><br><span class="line">CWnd * pWnd = FromHandle(hWnd);</span><br></pre></td></tr></tbody></table></figure>

<p>获得程序窗口指针的办法</p>
<p>1获得主框架窗口指针(任何时候都可以用，只要是MFC程序中)</p>
<p><code>CWnd* pWnd = AfxGetMainWnd();</code></p>
<p>2获得对话框中控件指针</p>
<p><code>CWnd* pWnd = GetDlgItem(IDC_xxx);</code></p>
<p>3获得对话框中某控件的句柄</p>
<p><code>HANDLE GetDlgItem(m_hDLG,m_nID_DlgItem);</code></p>
<p>4获得GDI对象的句柄</p>
<p><code>HANDLE m_hGDIObj = m_pGDIObj-&gt;GetSafeHanle();</code></p>
<p>1. 如何获取应用程序的 实例句柄? <code>AfxGetInstanceHandle()</code></p>
<pre><code>应用程序的 实例句柄保存在`CWinAppIm_hInstance` 中,可以这么调用 `AfxGetInstancdHandle`获得句柄.

  `Example: HANDLE hInstance=AfxGetInstanceHandle();`</code></pre><p>2. 如何通过代码获得应用程序主窗口的 指针? <code>AfxGetMainWnd</code>   <code>GetSafeHwnd()</code> <code>AfxGetAppName()</code>   `AfxGetThread``</p>
<pre><code>主窗口的 指针保存在`CWinThread::m_pMainWnd`中,调用 `AfxGetMainWnd`实现。 </code></pre><p>   【例】    <code>AfxGetMainWnd() -&gt;ShowWindow(SW_SHOWMAXMIZED);</code> //使程序最大化. </p>
<p>   【例】此例的主窗口是对话框，下面的代码是在另外一个CFileTreeCtrl 类（子窗）中相关函数实现在主对话框（主窗）中的几个 静态文本框（子窗）中显示路径：</p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">CWnd* m_pCWnd= AfxGetMainWnd(); <span class="comment">//得到主窗口指针,通过主窗指针访问其他子窗资源</span></span><br><span class="line"><span class="comment">//方法一</span></span><br><span class="line">m_pCWnd-&gt;SetDlgItemText(IDC_STATIC_path,<span class="string">"CWnd* "</span>+m_sCurPath); <span class="comment">//在主窗中的子窗（ID：IDC_STATIC_path）中显示字符串</span></span><br><span class="line">m_pCWnd-&gt;SetDlgItemText(IDC_STATIC_who,<span class="string">"路径显示由FileTreeCtrl类完成："</span>);</span><br><span class="line"><span class="comment">//方法二</span></span><br><span class="line">m_pCWnd-&gt;SendMessage(STN_CLICKED); <span class="comment">//向主窗口发送一个消息,显示任务由主窗完成。</span></span><br><span class="line"><span class="comment">//在主窗的.cpp中有：ON_MESSAGE(STN_CLICKED, OnSTATICpath3)相关描述&nbsp;</span></span><br><span class="line"><span class="comment">//有的函数必须通过窗口的 句柄 来访问，我们可以使用下面的方法三</span></span><br><span class="line"><span class="comment">//CWnd::GetSafeHwnd&nbsp;</span></span><br><span class="line"><span class="comment">//Returns the window handle for a window</span></span><br><span class="line"><span class="comment">//HWND GetSafeHwnd( ) const;</span></span><br><span class="line">HWND m_hWnd_tree =GetSafeHwnd();<span class="comment">//【注】此处得到的只是当前窗口（FileTree类）的句柄</span></span><br><span class="line">HWND m_hWnd = m_pCWnd-&gt;GetSafeHwnd();<span class="comment">// 这里才是主窗口的句柄（由主窗指针得到主窗的句柄）</span></span><br><span class="line"><span class="comment">//BOOL SetWindowText( HWND hWnd, LPCTSTR lpString )</span></span><br><span class="line">::SetWindowText(m_hWnd,<span class="string">"ok2222"</span>);<span class="comment">//修改主窗口标题</span></span><br><span class="line">::SetDlgItemText(m_hWnd,IDC_STATIC_path2,<span class="string">"HWND: "</span>+m_sCurPath);</span><br></pre></td></tr></tbody></table></figure>

<p>   【另】AfxGetThread</p>
<pre><code>`CWinThread* AfxGetThread( );`

Return Value：Pointer to the currently executing thread. </code></pre><p>3. 如何在程序中获得其他程序的 图标? <code>AfxGetInstanceHandle()</code></p>
<p>   <code>HINSTANCE AfxGetInstanceHandle( );</code></p>
<pre><code>Return Value

  An HINSTANCE to the current instance of the application. If called from within a DLL linked with the USRDLL version of MFC, an HINSTANCE to the DLL is returned.

Remarks

  This function allows you to retrieve the instance handle of the current application. AfxGetInstanceHandle always returns the HINSTANCE of your executable file (.EXE) unless it is called from within a DLL linked with the USRDLL version of MFC. In this case, it returns an HINSTANCE to the DLL.

  两种方法:

     (1) SDK函数 `SHGetFileInfo` 或使用 ExtractIcon获得图标资源的 handle(句柄),

     (2) SDK函数 `SHGetFileInfo`获得有关文件的 很多信息,如大小图标,属性,类型等.

       Example(1): 在程序窗口左上角显示 NotePad图标.</code></pre><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> CSampleView: OnDraw(CDC * pDC)</span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span>( :: SHGetFileInfo(_T(<span class="string">"c:\\pwin95\\notepad.exe"</span>),<span class="number">0</span>,</span><br><span class="line">                         &amp;stFileInfo,<span class="keyword">sizeof</span>(stFileInfo),SHGFI_ICON))</span><br><span class="line">    {</span><br><span class="line">        pDC -&gt;DrawIcon(<span class="number">10</span>,<span class="number">10</span>,stFileInfo.hIcon);</span><br><span class="line">    }</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<pre><code>Example(2):同样功能,Use ExtractIcon Function</code></pre><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> CSampleView:: OnDraw(CDC *pDC)</span><br><span class="line">{</span><br><span class="line">    HICON hIcon=:: ExtractIcon(AfxGetInstanceHandle(),_T</span><br><span class="line">                               (<span class="string">"NotePad.exe"</span>),<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (hIcon &amp;&amp;hIcon!=(HICON)<span class="number">-1</span>)</span><br><span class="line">        pDC-&gt;DrawIcon(<span class="number">10</span>,<span class="number">10</span>,hIcon);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<pre><code>【说明】关于如何得到系统文件的正确路径，象win.ini system32.ini等的路径，各种系统中具体的路径是不一样的。如：

        获得notepad.exe的路径正规上来说用`GetWindowsDirectory` 函数得到；

        如果是调用 win95下的画笔，应该用访问注册表的方法获得其路径；

        要作成一个比较考究的程序，考虑应该全面点.

【另】

             `HINSTANCE AfxGetResourceHandle( );`

             Return Value：An HINSTANCE handle where the default resources of the application are loaded. </code></pre><p>4.    有关取得桌面句柄 <code>GetDesktopWindow()</code></p>
<p>MSDN中的例子： </p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 静态函数CWnd:: GetDesktopWindow 返回桌面窗口的指针。下例说明了MFC</span></span><br><span class="line"><span class="keyword">void</span> CFrameWnd::BeginModalState ()</span><br><span class="line">{</span><br><span class="line">    <span class="comment">//first count all windows that need to be disabled</span></span><br><span class="line">    UINT nCount=<span class="number">0</span>;</span><br><span class="line">    HWND hWnd=:: GetWindow (:: GetDesktopWindow (), GW_CHILD);</span><br><span class="line">    <span class="keyword">while</span> (hWnd!=<span class="literal">NULL</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="keyword">if</span> (:: IsWindowEnabled (hwnd) &amp;&amp;</span><br><span class="line">            CWnd::FromHandlePermanent (hWnd)!=<span class="literal">NULL</span> &amp;&amp;</span><br><span class="line">            AfxIsDescendant (pParent-&gt;m_hWnd, hWnd) &amp;&amp;</span><br><span class="line">            :: SendMessage (hWnd, WM_DISABLEMODAL, <span class="number">0</span>, <span class="number">0</span>) == <span class="number">0</span>)</span><br><span class="line">        {</span><br><span class="line">            ++nCount;</span><br><span class="line">        }</span><br><span class="line">        hWnd=:: GetWindow (hWnd, GW_HWNDNEXT);</span><br><span class="line">    }</span><br><span class="line">}&nbsp;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用户的问题：下面程序取的不是同一程序的句柄,但是GetModuleFileName返回的结果一样请问为什莫&nbsp;</span></span><br><span class="line">HWND ChWnd;<span class="comment">//子窗口句柄&nbsp;</span></span><br><span class="line">HWND hwDesktop=::GetDesktopWindow();<span class="comment">//取得桌面句柄&nbsp;</span></span><br><span class="line">ChWnd=::GetWindow(hwDesktop,GW_CHILD);<span class="comment">//取得桌面子句柄&nbsp;</span></span><br><span class="line">CString csTitle,csClass,csTm,mLookstring;&nbsp;</span><br><span class="line"><span class="keyword">char</span> szBuffer[<span class="number">255</span>];&nbsp;</span><br><span class="line"><span class="keyword">while</span>(ChWnd!=<span class="literal">NULL</span>)<span class="comment">//循环取子句柄的同级句柄&nbsp;</span></span><br><span class="line">{</span><br><span class="line">    <span class="keyword">if</span>(::IsWindowVisible(ChWnd))<span class="comment">//判断是否为可显示窗口&nbsp;</span></span><br><span class="line">    {&nbsp;</span><br><span class="line">        ::GetWindowText(ChWnd,csTitle.GetBuffer(<span class="number">255</span>),<span class="number">254</span>);&nbsp;</span><br><span class="line">        ::GetClassName(ChWnd,csClass.GetBuffer(<span class="number">255</span>),<span class="number">254</span>);&nbsp;</span><br><span class="line">        csTitle.ReleaseBuffer();<span class="comment">//标题&nbsp;</span></span><br><span class="line">        csClass.ReleaseBuffer();<span class="comment">//类名&nbsp;</span></span><br><span class="line">        csTm.Format(<span class="string">"%08X:"</span>,ChWnd);&nbsp;</span><br><span class="line">        <span class="keyword">if</span>(csTitle==<span class="string">""</span>)&nbsp;</span><br><span class="line">        {&nbsp;</span><br><span class="line">            mLookstring=csTm+csClass;&nbsp;</span><br><span class="line">        }<span class="keyword">else</span>&nbsp;</span><br><span class="line">        {&nbsp;</span><br><span class="line">            mLookstring=csTm+csTitle;&nbsp;</span><br><span class="line">        }&nbsp;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//这里的窗口句柄不是同一个程序吧?（问题所在！）可是为什莫结果一样&nbsp;</span></span><br><span class="line">        HINSTANCE hInstance = (HINSTANCE)::GetWindowLong(ChWnd,DWL_USER);&nbsp;</span><br><span class="line">        ::GetModuleFileName(hInstance, szBuffer, <span class="keyword">sizeof</span>(szBuffer));&nbsp;</span><br><span class="line">        MessageBox(szBuffer,mLookstring);&nbsp;</span><br><span class="line">    }&nbsp;</span><br><span class="line">    ChWnd=::GetWindow(ChWnd,GW_HWNDNEXT);&nbsp;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>回答: </p>
<p>问题在于Win32下GetWindowLong(ChWnd,DWL_USER)总是返回当前程序运行的hInstance，所以你得到的文件名总是一个。所以你要用枚举所有”进程的程序名”来获得程序名。 </p>
<p>=== 再谈句柄与指针的区别 </p>
<p>许多开始学习VC的朋友，最多听说的两个词莫过于指针和句柄了。 </p>
<p>但是，确经常搞不清他们之间的区别。 </p>
<p>首先，句柄是一个窗口的标志，也就是所有从CWND类继承下来的，多有句柄这个成员。 </p>
<p>他能做的，也就是唯一代表一个桌面上的窗口罢了。而指针是一个地址，如果它指向了一个内存中的对象，那么就可以对它进行任意操作了，当然，并不局限于自己的应用程序，你如果能够获得别的应用程序的某个对象的指针，也可以进行操作。然而，如果要获得指针，首先，必须找到那个窗口的句柄，然后用函数FromHandle就可以得到他的指针了。 </p>
<p>===   问题1: </p>
<p>如何在自定义的消息中发送一个字符串？例如: </p>
<p><code>SendMessage(MyWnd,WM_USERDEFINED, 0,0)</code></p>
<p>如何将字符串Buffer写入wParam或lParam? </p>
<p>你可以把字符串的地址传递过去，因为地址正好是32位。如： </p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> s[<span class="number">256</span>];&nbsp;</span><br><span class="line">SendMessage(MyWnd,WM_USERDEFINED, (WPARAM) s,<span class="number">0</span>)</span><br></pre></td></tr></tbody></table></figure>

<p>接收方只需要将wParam赋给一个char*就可以了。但此方法只能使用于在一个进程内部传递数据。 </p>
<p>===   问题2: </p>
<p>1.在VC应用程序框架中,如何加入自己做的类,如何定义这个类的对象,我想在鼠标点击某个菜单项的时候才生成这个对象,做得到吗?(这个类的构造函数是带参数的)。 </p>
<p>2.消息发送函数: </p>
<p>   <code>PostMessage(HWND handle,WM_MYMESSAGE,  WPARAM wParam,LPARAM lParam)</code></p>
<p>   中: </p>
<p>第一个参数如何获得?</p>
<p>如果我的消息是在自己的应用程序中生成的,想发给应用程序的窗口让它显示某些数据(用TextOut函数),能做到吗?</p>
<p>(也可以说是这样的问题:用Appwizard生成应用程序框架,在生成的类(如CView)中如何得到窗口的句柄,并放在PostMessage函数中。) </p>
<p>3.wParam,lParam,在消息响应函数中如何用?vc是怎样保证这两个数传到函数中的?问题比较多,谢谢! </p>
<p>水平: 刚入门 </p>
<p>回答: </p>
<p>1、这个问题是肯定的。你可以使用ClassWizard定义类，也可以手工输入。如果类定义已经在某个文件中，只要使用Project|Add files将文件加入工程就可以了。要想定义类的对象，只要在你的菜单项的相应事件中就可以了。如： </p>
<figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">{&nbsp;</span><br><span class="line">    ...&nbsp;</span><br><span class="line">    <span class="function">MyClass <span class="title">myObject</span><span class="params">(<span class="string">"Hello"</span>)</span></span>;&nbsp;</span><br><span class="line">    myObject.MyMethod();&nbsp;</span><br><span class="line">    ...&nbsp;</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<p>2、在你自己的程序中传递消息当然没有任何问题,只要你知道要调用的窗口类是从CWnd继承来的，你就可以使用GetSafeHwnd函数获得窗口句柄。不过一般在自己的同一个程序中有时不愿意使用自定义消息，因为太麻烦。你完全可以给要调用的类添加一个成员函数，只要想显示数据，直接调用这个成员函数不就可以了？何必使用PostMessage呢？一般只有在程序间调用，才愿意使用自定义消息。这时，你通常可以使用FindWindow获得窗口句柄(QA000251 “如何利用<code>FindWindow()</code>函数查找程序”)。 </p>
<p>3、对于MFC已经定义了消息处理函数的消息，MFC会自动把wParam和lParam映射为更容易使用的方式。如OnMouseMove( UINT nFlags, CPoint point )。对于MFC不能自动处理的函数，如你使用ON_MESSAGE定义消息函数，则MFC会把wParam和lParam原原本本的传递给你的函数，不做任何处理。 </p>
<p>===   一个未公开的Win32 API函数：<code>GetTaskmanWindow()</code> </p>
<pre><code>下例中还用到： `GetProcAddress`     `GetParent(hWnd)`

                `HMODULE hUser32 = GetModuleHandle("user32");` </code></pre><figure class="highlight c++"><table><tbody><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// getaskmanwnd.cpp (Windows NT/2000)</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 利用一个未公开的Win32 API函数：GetTaskmanWindow，</span></span><br><span class="line"><span class="comment">// 对Windows的任务栏进行操作(显示/隐藏)。这个函数返回拥有任务栏按钮的窗口句柄。</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// This example will show you how you can obtain a handle to the</span></span><br><span class="line"><span class="comment">// Windows Taskbar window.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// (c)1999 Ashot Oganesyan K, SmartLine, Inc</span></span><br><span class="line"><span class="comment">// mailto:ashot@aha.ru, http://www.protect-me.com, http://www.codepile.com</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">// User32!GetTaskmanWindow (NT specific!)</span></span><br><span class="line"><span class="comment">// This function returns a handle to the window that ownes the taskbar buttons</span></span><br><span class="line"><span class="comment">// HWND GetTaskmanWindow()</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">HWND</span> <span class="params">(WINAPI *PROCGETTASKMANWND)</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">PROCGETTASKMANWND GetTaskmanWindow;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>{</span><br><span class="line">    <span class="keyword">if</span> (argc&lt;<span class="number">2</span>)</span><br><span class="line">    {</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Usage:\n\ngetaskmanwnd.exe S|H\n"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    }</span><br><span class="line">    HMODULE hUser32 = GetModuleHandle(<span class="string">"user32"</span>);</span><br><span class="line">    <span class="keyword">if</span> (!hUser32)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    GetTaskmanWindow = (PROCGETTASKMANWND)GetProcAddress(hUser32,<span class="string">"GetTaskmanWindow"</span>);&nbsp;</span><br><span class="line">    <span class="keyword">if</span> (!GetTaskmanWindow)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    HWND hWnd = GetTaskmanWindow();</span><br><span class="line">    <span class="keyword">if</span> (!hWnd)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span> (*argv[<span class="number">1</span>]==<span class="string">"H"</span> || *argv[<span class="number">1</span>]==<span class="string">"h"</span>)</span><br><span class="line">        ShowWindow(GetParent(hWnd),SW_HIDE);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ShowWindow(GetParent(hWnd),SW_SHOW);</span><br><span class="line">}</span><br></pre></td></tr></tbody></table></figure>

<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
        </div>

        <blockquote class="post-copyright">
    <div class="content">
        
<span class="post-time">
    最后更新：<time datetime="2019-10-13T01:05:57.916Z" itemprop="dateUpdated">2019-10-13 09:05:57</time>
</span>


        
        原文链接：<a href="/2018/05/07/MFC函数总结/" target="_blank" rel="external">http://blog.iwxyi.com/2018/05/07/MFC函数总结/</a>
        
    </div>
    <footer>
        <div onclick="location.href='http://blog.iwxyi.com'">
            <img src="/img/avatar.jpg" alt="命燃芯乂">
            <a>命燃芯乂</a>
        </div>
    </footer>
</blockquote>

        
    <div class="page-reward">
        <nav class="myreward">
            <a id="rewardBtn" href="javascript:;"><span>打&nbsp;赏</span><span>装成好像很多人打赏的样子</span></a>
        </nav>
    </div>



        <div class="post-footer">
            
	<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/">C++</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/MFC/">MFC</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/整理/">整理</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://blog.iwxyi.com/2018/05/07/MFC函数总结/&title=《MFC函数总结》 — 云笺&pic=http://blog.iwxyi.com/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://blog.iwxyi.com/2018/05/07/MFC函数总结/&title=《MFC函数总结》 — 云笺&source=1、MFC编辑框、静态文本框相关的常用函数
《1》GetDlgItemText(ID ,str)
作用：从对话框中获取文本
第一个参数为要获取的编辑框(或..." data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://blog.iwxyi.com/2018/05/07/MFC函数总结/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《MFC函数总结》 — 云笺&url=http://blog.iwxyi.com/2018/05/07/MFC函数总结/&via=http://blog.iwxyi.com" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://blog.iwxyi.com/2018/05/07/MFC函数总结/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="/2018/05/07/Win32-SDK列出目录下子文件/" id="post-prev" class="post-nav-link">
        <h4 class="title" >
          上一篇：Win32 SDK列出目录下子文件
        </h4>
      </a>
    </div>
  

  
    <div class="waves-block waves-effect next">
      <a href="/2018/05/01/Win32-SDK窗口模板/" id="post-next" class="post-nav-link">
        <h4 class="title" data-hover="下一篇：Win32 SDK窗口模板">下一篇：Win32 SDK窗口模板</h4>
      </a>
    </div>
  
</nav>



    
    

    

    
    <!-- Valine Comments -->
    <div class="comments vcomment" id="comments"></div>
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src="//unpkg.com/valine@latest/dist/Valine.min.js"></script>
    <!-- Valine Comments script -->
    <script>
        var GUEST_INFO = ['nick','mail','link'];
        var guest_info = 'nick,mail,link'.split(',').filter(function(item){
          return GUEST_INFO.indexOf(item) > -1
        });
        new Valine({
            el: '#comments',
            notify: 'true' == 'true',
            verify: 'false' == 'true',
            appId: "sVjY7bBJXEfCtStMqASgnlL6-gzGzoHsz",
            appKey: "8mL43PwxikVMVpiQx4Pq7wwt",
            avatar: "mm",
            placeholder: "留下您宝贵的建议——",
            guest_info: guest_info.length == 0 ? GUEST_INFO : guest_info,
            pageSize: "10"
        })
    </script>
    <!-- Valine Comments end -->



</article>

</div>

        <footer class="footer">
    <div class="footer-content">
        <span class="power">
            <i class="icon icon-lg icon-copyright"></i>
            2019
            <i class="icon icon-lg icon-heart"></i>
            <a href="http://blog.iwxyi.com">http://blog.iwxyi.com</a>
            <br/>
            Power by
            <a href="https://hexo.io/" target="_blank" rel="external nofollow">Hexo</a>&nbsp;·&nbsp;
            Theme
            <a class="tomotoeslink" href="https://github.com/tomotoes/hexo-theme-tomotoes/" target="_blank" rel="external nofollow">tomotoes</a>
        </span>

        <br/>

        <span id="RunTime" style="color:#a7a7a2;"></span>
        <br/>

        <span>
            
	<i class="icon icon-lg icon-user">
<span id="busuanzi_container_site_uv" style='display:none'>
       访问用户：<span id="busuanzi_value_site_uv"></span>
    </span>人</i>
    ·
    <i class="icon icon-lg icon-eye">
    <span id="busuanzi_container_site_pv" style='display:none'>
      访问次数：<span id="busuanzi_value_site_pv"></span>
    </span>次
    </i>


        </span>
        <br/>

        <span class="license"><a  target="_blank" rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh">博客内容遵循 知识共享 署名 - 非商业性 - 相同方式共享 4.0 国际协议</a></span>
    </div>
</footer>

    </main>
    
        
<div id="reward" class="page-modal reward-lay">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <h3 class="reward-title">
        <i class="icon icon-quote-left"></i>
        <span>感谢您的鼓励支持！</span>
        <i class="icon icon-quote-right"></i>
    </h3>
    <div class="reward-content">
        
        <div class="reward-code">
            <img id="rewardCode" data-img="/img/dog.png" alt="打赏二维码">
        </div>
        
        <label class="reward-toggle">
            <input id="rewardToggle" type="checkbox" class="reward-toggle-check"
                data-wechat="/img/wechat.png" data-alipay="/img/alipay.png">
            <div class="reward-toggle-ctrol">
                <span class="reward-toggle-item wechatPay">&nbsp;&nbsp;微信&nbsp;&nbsp;</span>
                <span class="reward-toggle-item alipayPay">支付宝</span>
            </div>
        </label>
        
        <i class="icon icon-caret-up"></i>
    </div>
</div>


    
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=http://blog.iwxyi.com/2018/05/07/MFC函数总结/&title=《MFC函数总结》 — 云笺&pic=http://blog.iwxyi.com/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://blog.iwxyi.com/2018/05/07/MFC函数总结/&title=《MFC函数总结》 — 云笺&source=1、MFC编辑框、静态文本框相关的常用函数
《1》GetDlgItemText(ID ,str)
作用：从对话框中获取文本
第一个参数为要获取的编辑框(或..." data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=http://blog.iwxyi.com/2018/05/07/MFC函数总结/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《MFC函数总结》 — 云笺&url=http://blog.iwxyi.com/2018/05/07/MFC函数总结/&via=http://blog.iwxyi.com" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=http://blog.iwxyi.com/2018/05/07/MFC函数总结/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p class="wechatshare">扫一扫，分享到微信</p>
    <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMYAAADGCAAAAACs8KCBAAACLElEQVR42u3aS7LbMAwEwHf/SzvrVGJ7BpBTMdVaqWx92FxABIGfn/h4/HG8/je/Pvn9sgMDA+NrGcnrX/+SDPrZef7e12/BwMC4A+NZBLvqmmdDzM/fjBkDAwPjZfBNgvJsaYiBgYGxYSRPyIe+CfQYGBj3YSTJZLL1loTO5N4P5uIYGBhfyMh33f/9+UfqGxgYGF/FeJRHG1LzwmQeZP8yKgwMjKMZsxR01kgxm4IiJcbAwDiU0bZTbGZrc9ebycLAwDia0Qa72bA2QbYoSGBgYBzKmKWvV22cJcXLaOsNAwPjaEbePJEv19o2iw0VAwPjDowkaZw1RmwS4xaGgYFxH8YspLYNW7NnvnkaBgbGzRizUmXbkJG3ZRT1DQwMjEMZ1xYX2zaLonaRLB8xMDAOZeQp5SwUJuF4v/2HgYFxH0a7ldYuEJMJGi4iMTAwjma0TRizFq5Nalo0W2BgYBzKyNsj2sy4DaOzd/323cDAwDiU0aaU7eJvs8VWt1xgYGAczZgt9fLGr/1wo4nAwMC4GWNWJJgNtN2Ge1MewMDAOJqRb6jlG/qbJLlepGJgYBzKeJRHuxxsp6YN69HsYmBgfDnjqqLmZsE3KwPkY8DAwDiDMQuX+620fMowMDAw9oWBTYNF+wV4ehcGBgZGEHD3gLzYsOoWwcDAuAGjfVlb7Myv+ch3AwMD4z9mzIoBCWCzPVcvDTEwMA5l5KljG3zbMsNsMYqBgXE04xdCsEHPCYQkMQAAAABJRU5ErkJggg==" alt="微信分享二维码">
</div>




    <!-- waves按钮特效 -->
<script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>

<!-- 主题配置脚本 -->
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: true };
</script>

<!-- jquery -->
<script src="/js/jquery.min.js?v=3.0"></script>

<!-- 搜索 -->

<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item waves-block waves-effect" onclick="location.href='{path}'">
    <div class="title ellipsis" title="{title}">{title}</div>
</li>
</template>


<!-- main博客脚本 -->
<script src="/js/main.min.js?v=3.0" ></script>

<!-- 动画&配置 -->
<script src="/js/script.min.js?v=3.0" ></script>

<!-- 脚本管理 -->
<script>

if(window.innerWidth > 800){
	/* 3D标题 */
	$(".content-header").on("mousemove", threedee);

	/* 底部追随鼠标 */
	$(".footer").hover(2);

	/* gotop键的涟漪 */
	$("#gotop").hover(1);

	/* 赞赏的粒子雨 */
	$("#reward").hover(3);

	/* 微信公众号的底部渲染 */
	$("#wechat").hover(4);

    /* 标题跳动 */
    $(".archivestitle").bumpyText();

	/* 图片点击放大 */
	const postimg = jQuery(".post-content img:not(.github-emoji)");
	postimg.on("click",function(){

		mask.classList.add("in");
		main.classList.add("Mask");
		menu.classList.add("Mask");
		var myimg = this.cloneNode(true);
		myimg.classList.add("imgShow");

		setTimeout(function(){
			jQuery(myimg).animate({
				opacity:"1"
			},1000);
		},0);

		document.body.appendChild(myimg);

		myimg.onclick=function(){
			document.body.removeChild(myimg);
			mask.classList.remove("in");
			main.classList.remove("Mask");
			menu.classList.remove("Mask");
		};

	});

}

/* 名字跳动 */
$("#name").bumpyText();


/* 网站运行时间 */
setInterval(function () {
	setTime("2019/10/11");
}, 1000);

/* 文章块的淡出 */
postshow();

/* 座右铭 */

   getHitokoto();



/* 粘贴提示 */
G($(".post-content"), location.href, "命燃芯乂");


/* 控制台 */
if (window.console && window.console.log) {
	setTimeout(function () {
		console.log("\n %c 一个坏掉的番茄 %c  © Simon Ma  http://tomotoes.com \n\n", "color:#FFFFFB;background:#1abc9c;padding:5px 0;border-radius:.5rem 0 0 .5rem;", "color:#FFFFFB;background:#080808;padding:5px 0;border-radius:0 .5rem .5rem 0;");
	}, 0);
}

</script>




<!-- 公式渲染 -->



<!-- 不蒜子 -->

<script defer src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>


<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"log":false,"model":{"jsonPath":"/live2dw/assets/z16.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false}});</script></body>
</html>
